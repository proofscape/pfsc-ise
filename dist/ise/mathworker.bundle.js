/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/browser-peers/src/dedworkerpeer.js":
/*!*********************************************************!*\
  !*** ./node_modules/browser-peers/src/dedworkerpeer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DedicatedWorkerPeer\": () => (/* binding */ DedicatedWorkerPeer)\n/* harmony export */ });\n/* harmony import */ var _peer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./peer */ \"./node_modules/browser-peers/src/peer.js\");\n/*! browser-peers v0.1.0 | Copyright (c) 2020-2022 Steve Kieffer | MIT license */\n/* SPDX-License-Identifier: MIT */\n\n\n\n\n/*\n * This peer class supports communication between a page and a web worker,\n * specifically a *dedicated* worker.\n *\n * Usage:\n *\n *  In the page:\n *\n *      const worker = new Worker('worker.js');\n *      const peer = new DedicatedWorkerPeer(worker);\n *\n *  In the worker script (worker.js in this example):\n *\n *      const peer = new DedicatedWorkerPeer(self);\n *\n */\nclass DedicatedWorkerPeer extends _peer__WEBPACK_IMPORTED_MODULE_0__.Peer {\n\n    /*\n     * @param iface {Worker, DedicatedWorkerGlobalScope} An interface that has a `postMessage` method,\n     *   and an `onmessage` property. On the page side this will be the `Worker` instance with which you\n     *   want to communicate, and in the worker script this will be `self`.\n     */\n    constructor(iface) {\n        const [myName, nameOfPeer] = iface instanceof Worker ? ['page', 'worker'] : ['worker', 'page'];\n        super(myName);\n        this.nameOfPeer = nameOfPeer;\n        this.iface = iface;\n        this.boundMessageHandler = this.handleMessageEvent.bind(this);\n        this.activateMessaging();\n    }\n\n    // Convenient way to terminate the Worker, from the page side.\n    terminate() {\n        if (this.nameOfPeer === 'worker') {\n            this.iface.terminate();\n        }\n    }\n\n    activateMessaging() {\n        this.iface.onmessage = this.boundMessageHandler;\n    }\n\n    handleMessageEvent(event) {\n        const wrapper = event.data;\n        super.handleMessage(wrapper);\n    }\n\n    // ------------------------------------------------------------------------\n    // Override abstract base class methods\n\n    postMessageAsPeer(peerName, wrapper) {\n        wrapper.to = peerName;\n        this.iface.postMessage(wrapper);\n    }\n\n    /* Shortcut for makeRequest, so that you don't need to pass the name of the peer\n     * as the first argument.\n     */\n    postRequest(handlerDescrip, args, options) {\n        return this.makeRequest(this.nameOfPeer, handlerDescrip, args, options);\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvZGVkd29ya2VycGVlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGZzYy1pc2UvLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvZGVkd29ya2VycGVlci5qcz82OTRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBicm93c2VyLXBlZXJzIHYwLjEuMCB8IENvcHlyaWdodCAoYykgMjAyMC0yMDIyIFN0ZXZlIEtpZWZmZXIgfCBNSVQgbGljZW5zZSAqL1xuLyogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVCAqL1xuXG5cbmltcG9ydCB7IFBlZXIgfSBmcm9tIFwiLi9wZWVyXCI7XG5cbi8qXG4gKiBUaGlzIHBlZXIgY2xhc3Mgc3VwcG9ydHMgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIGEgcGFnZSBhbmQgYSB3ZWIgd29ya2VyLFxuICogc3BlY2lmaWNhbGx5IGEgKmRlZGljYXRlZCogd29ya2VyLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICBJbiB0aGUgcGFnZTpcbiAqXG4gKiAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoJ3dvcmtlci5qcycpO1xuICogICAgICBjb25zdCBwZWVyID0gbmV3IERlZGljYXRlZFdvcmtlclBlZXIod29ya2VyKTtcbiAqXG4gKiAgSW4gdGhlIHdvcmtlciBzY3JpcHQgKHdvcmtlci5qcyBpbiB0aGlzIGV4YW1wbGUpOlxuICpcbiAqICAgICAgY29uc3QgcGVlciA9IG5ldyBEZWRpY2F0ZWRXb3JrZXJQZWVyKHNlbGYpO1xuICpcbiAqL1xuZXhwb3J0IGNsYXNzIERlZGljYXRlZFdvcmtlclBlZXIgZXh0ZW5kcyBQZWVyIHtcblxuICAgIC8qXG4gICAgICogQHBhcmFtIGlmYWNlIHtXb3JrZXIsIERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlfSBBbiBpbnRlcmZhY2UgdGhhdCBoYXMgYSBgcG9zdE1lc3NhZ2VgIG1ldGhvZCxcbiAgICAgKiAgIGFuZCBhbiBgb25tZXNzYWdlYCBwcm9wZXJ0eS4gT24gdGhlIHBhZ2Ugc2lkZSB0aGlzIHdpbGwgYmUgdGhlIGBXb3JrZXJgIGluc3RhbmNlIHdpdGggd2hpY2ggeW91XG4gICAgICogICB3YW50IHRvIGNvbW11bmljYXRlLCBhbmQgaW4gdGhlIHdvcmtlciBzY3JpcHQgdGhpcyB3aWxsIGJlIGBzZWxmYC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSkge1xuICAgICAgICBjb25zdCBbbXlOYW1lLCBuYW1lT2ZQZWVyXSA9IGlmYWNlIGluc3RhbmNlb2YgV29ya2VyID8gWydwYWdlJywgJ3dvcmtlciddIDogWyd3b3JrZXInLCAncGFnZSddO1xuICAgICAgICBzdXBlcihteU5hbWUpO1xuICAgICAgICB0aGlzLm5hbWVPZlBlZXIgPSBuYW1lT2ZQZWVyO1xuICAgICAgICB0aGlzLmlmYWNlID0gaWZhY2U7XG4gICAgICAgIHRoaXMuYm91bmRNZXNzYWdlSGFuZGxlciA9IHRoaXMuaGFuZGxlTWVzc2FnZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNZXNzYWdpbmcoKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW50IHdheSB0byB0ZXJtaW5hdGUgdGhlIFdvcmtlciwgZnJvbSB0aGUgcGFnZSBzaWRlLlxuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZU9mUGVlciA9PT0gJ3dvcmtlcicpIHtcbiAgICAgICAgICAgIHRoaXMuaWZhY2UudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZU1lc3NhZ2luZygpIHtcbiAgICAgICAgdGhpcy5pZmFjZS5vbm1lc3NhZ2UgPSB0aGlzLmJvdW5kTWVzc2FnZUhhbmRsZXI7XG4gICAgfVxuXG4gICAgaGFuZGxlTWVzc2FnZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBldmVudC5kYXRhO1xuICAgICAgICBzdXBlci5oYW5kbGVNZXNzYWdlKHdyYXBwZXIpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE92ZXJyaWRlIGFic3RyYWN0IGJhc2UgY2xhc3MgbWV0aG9kc1xuXG4gICAgcG9zdE1lc3NhZ2VBc1BlZXIocGVlck5hbWUsIHdyYXBwZXIpIHtcbiAgICAgICAgd3JhcHBlci50byA9IHBlZXJOYW1lO1xuICAgICAgICB0aGlzLmlmYWNlLnBvc3RNZXNzYWdlKHdyYXBwZXIpO1xuICAgIH1cblxuICAgIC8qIFNob3J0Y3V0IGZvciBtYWtlUmVxdWVzdCwgc28gdGhhdCB5b3UgZG9uJ3QgbmVlZCB0byBwYXNzIHRoZSBuYW1lIG9mIHRoZSBwZWVyXG4gICAgICogYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqL1xuICAgIHBvc3RSZXF1ZXN0KGhhbmRsZXJEZXNjcmlwLCBhcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KHRoaXMubmFtZU9mUGVlciwgaGFuZGxlckRlc2NyaXAsIGFyZ3MsIG9wdGlvbnMpO1xuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/browser-peers/src/dedworkerpeer.js\n");

/***/ }),

/***/ "./node_modules/browser-peers/src/errors.js":
/*!**************************************************!*\
  !*** ./node_modules/browser-peers/src/errors.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NoGroupError\": () => (/* binding */ NoGroupError),\n/* harmony export */   \"ExtensionUnavailableError\": () => (/* binding */ ExtensionUnavailableError),\n/* harmony export */   \"UnknownPeerError\": () => (/* binding */ UnknownPeerError),\n/* harmony export */   \"LackingHostPermissionError\": () => (/* binding */ LackingHostPermissionError),\n/* harmony export */   \"FetchResolvedNotOkError\": () => (/* binding */ FetchResolvedNotOkError),\n/* harmony export */   \"FetchRejectedError\": () => (/* binding */ FetchRejectedError),\n/* harmony export */   \"FetchWrongContentTypeError\": () => (/* binding */ FetchWrongContentTypeError),\n/* harmony export */   \"reconstituteError\": () => (/* binding */ reconstituteError)\n/* harmony export */ });\n/*! browser-peers v0.1.0 | Copyright (c) 2020-2022 Steve Kieffer | MIT license */\n/* SPDX-License-Identifier: MIT */\n\n/*\n * Here we define special error classes that are designed to be serializable.\n * This is so that they can be communicated via various messaging systems,\n * and then reconstructed on the other side.\n *\n * All error classes defined here MUST:\n *\n *   * have a constructor that accepts an object\n *\n *   * define `this.name` equal to their own class name (as string!)\n *\n *   * be registered in `KNOWN_ERROR_CLASSES` (see below) under their class name\n *\n *   * have a `serialize()` method that returns the JSON.stringify of an\n *     object that:\n *       - can be passed to the class's constructor, and\n *       - includes `_error_class_name: this.name`\n *\n */\n\n// ---------------------------------------------------------------------------\n// Special error classes\n\n/*\n * This error class represents cases in which we are trying to do something\n * that involves belonging to a group, but we do not (yet) belong to one.\n */\nclass NoGroupError extends Error {\n\n    constructor({ message }) {\n        super(message);\n        this.name = \"NoGroupError\";\n    }\n\n    serialize() {\n        return JSON.stringify({\n            _error_class_name: this.name,\n            message: this.message,\n        });\n    }\n\n}\n\n/*\n * This error class is intended to represent cases in which the extension has\n * become unavailable. Usually (actually the only case I'm currently aware of)\n * this is because the extension was uninstalled after that page was loaded.\n */\nclass ExtensionUnavailableError extends Error {\n\n    constructor({ message }) {\n        super(message);\n        this.name = \"ExtensionUnavailableError\";\n    }\n\n    serialize() {\n        return JSON.stringify({\n            _error_class_name: this.name,\n            message: this.message,\n        });\n    }\n\n}\n\n/* Represents cases in which a Peer is attempting to look up another\n * Peer, but cannot find it.\n */\nclass UnknownPeerError extends Error {\n\n    constructor({ message }) {\n        super(message);\n        this.name = \"UnknownPeerError\";\n    }\n\n    serialize() {\n        return JSON.stringify({\n            _error_class_name: this.name,\n            message: this.message,\n        });\n    }\n\n}\n\n/*\n * This represents cases in which the extension is lacking host permission\n * for a given URL.\n */\nclass LackingHostPermissionError extends Error {\n\n    constructor({ url }) {\n        super(`Extension lacks host permission for ${url}.`);\n        this.name = \"LackingHostPermissionError\";\n        this.url = url;\n    }\n\n    serialize() {\n        return JSON.stringify({\n            _error_class_name: this.name,\n            url: this.url,\n        });\n    }\n}\n\n/*\n * Superclass of more specific fetch error types defined below.\n * For now, not exported, since I think users only need the more specific types.\n */\nclass FetchError extends Error {\n\n    /* We record those attributes of a fetch Response object\n     * (see <https://developer.mozilla.org/en-US/docs/Web/API/Response>)\n     * that we think will be useful (and that we want to bother with right\n     * now -- maybe more in the future).\n     *\n     * Note that you may pass a Response instance itself to this constructor.\n     */\n    constructor({ ok, status, statusText, type, url, headers, contentType }) {\n        const message = `Fetch ${url} status: ${status} ${statusText}`;\n        super(message);\n        this.name = 'FetchError';\n        this.ok = ok;\n        this.status = status;\n        this.statusText = statusText;\n        this.type = type;\n        this.url = url;\n        this.contentType = contentType;\n        if (headers && headers.get) {\n            try {\n                this.contentType = headers.get('Content-Type');\n            } catch (e) {\n            }\n        }\n    }\n\n    serialize() {\n        return JSON.stringify({\n            _error_class_name: this.name,\n            ok: this.ok,\n            status: this.status,\n            statusText: this.statusText,\n            type: this.type,\n            url: this.url,\n            contentType: this.contentType,\n        });\n    }\n\n}\n\n/*\n * This error class is intended to represent cases in which a `fetch` promise\n * resolved, but returned a Response object whose `ok` property was `false`.\n *\n * On both Chrome and Firefox, this will be the case when we successfully\n * received a response, but it had an HTTP status outside the 200-299 range.\n */\nclass FetchResolvedNotOkError extends FetchError {\n\n    constructor({ ok, status, statusText, type, url }) {\n        super({ ok, status, statusText, type, url });\n        this.name = 'FetchResolvedNotOkError';\n    }\n\n}\n\n/*\n * This error class is intended to represent cases in which a `fetch` promise rejected.\n *\n * For example, on both Chrome and Firefox, this will be the case when we attempt to make a\n * cross-origin fetch, but CORS fails due to absence of Access-Control-Allow-Origin header.\n */\nclass FetchRejectedError extends FetchError {\n\n    constructor({ ok, status, statusText, type, url }) {\n        super({ ok, status, statusText, type, url });\n        this.name = 'FetchRejectedError';\n        this.message = 'Fetch rejected. ' + this.message;\n    }\n\n}\n\n/*\n * Represents cases in which a `fetch` resolved with `ok` but with an unexpected\n * Content-Type header.\n */\nclass FetchWrongContentTypeError extends FetchError {\n\n    constructor({ ok, status, statusText, type, url, headers, contentType }) {\n        super({ ok, status, statusText, type, url, headers, contentType });\n        this.name = 'FetchWrongContentTypeError';\n        this.message = `Fetch ${url} received unexpected Content-Type: ${contentType}`;\n    }\n\n}\n\n// ---------------------------------------------------------------------------\n// Reconstitution\n\nconst KNOWN_ERROR_CLASSES = new Map()\n    .set(\"FetchResolvedNotOkError\", FetchResolvedNotOkError)\n    .set(\"FetchRejectedError\", FetchRejectedError)\n    .set(\"NoGroupError\", NoGroupError)\n    .set(\"ExtensionUnavailableError\", ExtensionUnavailableError)\n    .set(\"LackingHostPermissionError\", LackingHostPermissionError)\n    .set(\"FetchWrongContentTypeError\", FetchWrongContentTypeError)\n    .set(\"UnknownPeerError\", UnknownPeerError)\n;\n\n/* Attempt to reconstitute a special error class instance from a generic Error.\n * We look at the message of the given Error. If it appears to be the serialization\n * of one of our special error classes, then we rebuild an instance based on this.\n * Otherwise we just return the given Error.\n *\n * param error: an Error instance\n * return: the reconstituted error, or the given one.\n */\nfunction reconstituteError(error) {\n    let d = null;\n    try {\n        d = JSON.parse(error.message);\n    } catch {}\n    if (d && KNOWN_ERROR_CLASSES.has(d._error_class_name)) {\n        const ClassConstructor = KNOWN_ERROR_CLASSES.get(d._error_class_name);\n        return new ClassConstructor(d);\n    }\n    return error;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvZXJyb3JzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZnNjLWlzZS8uL25vZGVfbW9kdWxlcy9icm93c2VyLXBlZXJzL3NyYy9lcnJvcnMuanM/YzQxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgYnJvd3Nlci1wZWVycyB2MC4xLjAgfCBDb3B5cmlnaHQgKGMpIDIwMjAtMjAyMiBTdGV2ZSBLaWVmZmVyIHwgTUlUIGxpY2Vuc2UgKi9cbi8qIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQgKi9cblxuLypcbiAqIEhlcmUgd2UgZGVmaW5lIHNwZWNpYWwgZXJyb3IgY2xhc3NlcyB0aGF0IGFyZSBkZXNpZ25lZCB0byBiZSBzZXJpYWxpemFibGUuXG4gKiBUaGlzIGlzIHNvIHRoYXQgdGhleSBjYW4gYmUgY29tbXVuaWNhdGVkIHZpYSB2YXJpb3VzIG1lc3NhZ2luZyBzeXN0ZW1zLFxuICogYW5kIHRoZW4gcmVjb25zdHJ1Y3RlZCBvbiB0aGUgb3RoZXIgc2lkZS5cbiAqXG4gKiBBbGwgZXJyb3IgY2xhc3NlcyBkZWZpbmVkIGhlcmUgTVVTVDpcbiAqXG4gKiAgICogaGF2ZSBhIGNvbnN0cnVjdG9yIHRoYXQgYWNjZXB0cyBhbiBvYmplY3RcbiAqXG4gKiAgICogZGVmaW5lIGB0aGlzLm5hbWVgIGVxdWFsIHRvIHRoZWlyIG93biBjbGFzcyBuYW1lIChhcyBzdHJpbmchKVxuICpcbiAqICAgKiBiZSByZWdpc3RlcmVkIGluIGBLTk9XTl9FUlJPUl9DTEFTU0VTYCAoc2VlIGJlbG93KSB1bmRlciB0aGVpciBjbGFzcyBuYW1lXG4gKlxuICogICAqIGhhdmUgYSBgc2VyaWFsaXplKClgIG1ldGhvZCB0aGF0IHJldHVybnMgdGhlIEpTT04uc3RyaW5naWZ5IG9mIGFuXG4gKiAgICAgb2JqZWN0IHRoYXQ6XG4gKiAgICAgICAtIGNhbiBiZSBwYXNzZWQgdG8gdGhlIGNsYXNzJ3MgY29uc3RydWN0b3IsIGFuZFxuICogICAgICAgLSBpbmNsdWRlcyBgX2Vycm9yX2NsYXNzX25hbWU6IHRoaXMubmFtZWBcbiAqXG4gKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTcGVjaWFsIGVycm9yIGNsYXNzZXNcblxuLypcbiAqIFRoaXMgZXJyb3IgY2xhc3MgcmVwcmVzZW50cyBjYXNlcyBpbiB3aGljaCB3ZSBhcmUgdHJ5aW5nIHRvIGRvIHNvbWV0aGluZ1xuICogdGhhdCBpbnZvbHZlcyBiZWxvbmdpbmcgdG8gYSBncm91cCwgYnV0IHdlIGRvIG5vdCAoeWV0KSBiZWxvbmcgdG8gb25lLlxuICovXG5leHBvcnQgY2xhc3MgTm9Hcm91cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0pIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTm9Hcm91cEVycm9yXCI7XG4gICAgfVxuXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgX2Vycm9yX2NsYXNzX25hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG5cbi8qXG4gKiBUaGlzIGVycm9yIGNsYXNzIGlzIGludGVuZGVkIHRvIHJlcHJlc2VudCBjYXNlcyBpbiB3aGljaCB0aGUgZXh0ZW5zaW9uIGhhc1xuICogYmVjb21lIHVuYXZhaWxhYmxlLiBVc3VhbGx5IChhY3R1YWxseSB0aGUgb25seSBjYXNlIEknbSBjdXJyZW50bHkgYXdhcmUgb2YpXG4gKiB0aGlzIGlzIGJlY2F1c2UgdGhlIGV4dGVuc2lvbiB3YXMgdW5pbnN0YWxsZWQgYWZ0ZXIgdGhhdCBwYWdlIHdhcyBsb2FkZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHRlbnNpb25VbmF2YWlsYWJsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0pIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRXh0ZW5zaW9uVW5hdmFpbGFibGVFcnJvclwiO1xuICAgIH1cblxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIF9lcnJvcl9jbGFzc19uYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG4vKiBSZXByZXNlbnRzIGNhc2VzIGluIHdoaWNoIGEgUGVlciBpcyBhdHRlbXB0aW5nIHRvIGxvb2sgdXAgYW5vdGhlclxuICogUGVlciwgYnV0IGNhbm5vdCBmaW5kIGl0LlxuICovXG5leHBvcnQgY2xhc3MgVW5rbm93blBlZXJFcnJvciBleHRlbmRzIEVycm9yIHtcblxuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlVua25vd25QZWVyRXJyb3JcIjtcbiAgICB9XG5cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBfZXJyb3JfY2xhc3NfbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuLypcbiAqIFRoaXMgcmVwcmVzZW50cyBjYXNlcyBpbiB3aGljaCB0aGUgZXh0ZW5zaW9uIGlzIGxhY2tpbmcgaG9zdCBwZXJtaXNzaW9uXG4gKiBmb3IgYSBnaXZlbiBVUkwuXG4gKi9cbmV4cG9ydCBjbGFzcyBMYWNraW5nSG9zdFBlcm1pc3Npb25FcnJvciBleHRlbmRzIEVycm9yIHtcblxuICAgIGNvbnN0cnVjdG9yKHsgdXJsIH0pIHtcbiAgICAgICAgc3VwZXIoYEV4dGVuc2lvbiBsYWNrcyBob3N0IHBlcm1pc3Npb24gZm9yICR7dXJsfS5gKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJMYWNraW5nSG9zdFBlcm1pc3Npb25FcnJvclwiO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICB9XG5cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBfZXJyb3JfY2xhc3NfbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKlxuICogU3VwZXJjbGFzcyBvZiBtb3JlIHNwZWNpZmljIGZldGNoIGVycm9yIHR5cGVzIGRlZmluZWQgYmVsb3cuXG4gKiBGb3Igbm93LCBub3QgZXhwb3J0ZWQsIHNpbmNlIEkgdGhpbmsgdXNlcnMgb25seSBuZWVkIHRoZSBtb3JlIHNwZWNpZmljIHR5cGVzLlxuICovXG5jbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgLyogV2UgcmVjb3JkIHRob3NlIGF0dHJpYnV0ZXMgb2YgYSBmZXRjaCBSZXNwb25zZSBvYmplY3RcbiAgICAgKiAoc2VlIDxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVzcG9uc2U+KVxuICAgICAqIHRoYXQgd2UgdGhpbmsgd2lsbCBiZSB1c2VmdWwgKGFuZCB0aGF0IHdlIHdhbnQgdG8gYm90aGVyIHdpdGggcmlnaHRcbiAgICAgKiBub3cgLS0gbWF5YmUgbW9yZSBpbiB0aGUgZnV0dXJlKS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB5b3UgbWF5IHBhc3MgYSBSZXNwb25zZSBpbnN0YW5jZSBpdHNlbGYgdG8gdGhpcyBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG9rLCBzdGF0dXMsIHN0YXR1c1RleHQsIHR5cGUsIHVybCwgaGVhZGVycywgY29udGVudFR5cGUgfSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZldGNoICR7dXJsfSBzdGF0dXM6ICR7c3RhdHVzfSAke3N0YXR1c1RleHR9YDtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdGZXRjaEVycm9yJztcbiAgICAgICAgdGhpcy5vayA9IG9rO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZTtcbiAgICAgICAgaWYgKGhlYWRlcnMgJiYgaGVhZGVycy5nZXQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIF9lcnJvcl9jbGFzc19uYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBvazogdGhpcy5vayxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IHRoaXMuY29udGVudFR5cGUsXG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG4vKlxuICogVGhpcyBlcnJvciBjbGFzcyBpcyBpbnRlbmRlZCB0byByZXByZXNlbnQgY2FzZXMgaW4gd2hpY2ggYSBgZmV0Y2hgIHByb21pc2VcbiAqIHJlc29sdmVkLCBidXQgcmV0dXJuZWQgYSBSZXNwb25zZSBvYmplY3Qgd2hvc2UgYG9rYCBwcm9wZXJ0eSB3YXMgYGZhbHNlYC5cbiAqXG4gKiBPbiBib3RoIENocm9tZSBhbmQgRmlyZWZveCwgdGhpcyB3aWxsIGJlIHRoZSBjYXNlIHdoZW4gd2Ugc3VjY2Vzc2Z1bGx5XG4gKiByZWNlaXZlZCBhIHJlc3BvbnNlLCBidXQgaXQgaGFkIGFuIEhUVFAgc3RhdHVzIG91dHNpZGUgdGhlIDIwMC0yOTkgcmFuZ2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaFJlc29sdmVkTm90T2tFcnJvciBleHRlbmRzIEZldGNoRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IoeyBvaywgc3RhdHVzLCBzdGF0dXNUZXh0LCB0eXBlLCB1cmwgfSkge1xuICAgICAgICBzdXBlcih7IG9rLCBzdGF0dXMsIHN0YXR1c1RleHQsIHR5cGUsIHVybCB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ZldGNoUmVzb2x2ZWROb3RPa0Vycm9yJztcbiAgICB9XG5cbn1cblxuLypcbiAqIFRoaXMgZXJyb3IgY2xhc3MgaXMgaW50ZW5kZWQgdG8gcmVwcmVzZW50IGNhc2VzIGluIHdoaWNoIGEgYGZldGNoYCBwcm9taXNlIHJlamVjdGVkLlxuICpcbiAqIEZvciBleGFtcGxlLCBvbiBib3RoIENocm9tZSBhbmQgRmlyZWZveCwgdGhpcyB3aWxsIGJlIHRoZSBjYXNlIHdoZW4gd2UgYXR0ZW1wdCB0byBtYWtlIGFcbiAqIGNyb3NzLW9yaWdpbiBmZXRjaCwgYnV0IENPUlMgZmFpbHMgZHVlIHRvIGFic2VuY2Ugb2YgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luIGhlYWRlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoUmVqZWN0ZWRFcnJvciBleHRlbmRzIEZldGNoRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IoeyBvaywgc3RhdHVzLCBzdGF0dXNUZXh0LCB0eXBlLCB1cmwgfSkge1xuICAgICAgICBzdXBlcih7IG9rLCBzdGF0dXMsIHN0YXR1c1RleHQsIHR5cGUsIHVybCB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ZldGNoUmVqZWN0ZWRFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9ICdGZXRjaCByZWplY3RlZC4gJyArIHRoaXMubWVzc2FnZTtcbiAgICB9XG5cbn1cblxuLypcbiAqIFJlcHJlc2VudHMgY2FzZXMgaW4gd2hpY2ggYSBgZmV0Y2hgIHJlc29sdmVkIHdpdGggYG9rYCBidXQgd2l0aCBhbiB1bmV4cGVjdGVkXG4gKiBDb250ZW50LVR5cGUgaGVhZGVyLlxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hXcm9uZ0NvbnRlbnRUeXBlRXJyb3IgZXh0ZW5kcyBGZXRjaEVycm9yIHtcblxuICAgIGNvbnN0cnVjdG9yKHsgb2ssIHN0YXR1cywgc3RhdHVzVGV4dCwgdHlwZSwgdXJsLCBoZWFkZXJzLCBjb250ZW50VHlwZSB9KSB7XG4gICAgICAgIHN1cGVyKHsgb2ssIHN0YXR1cywgc3RhdHVzVGV4dCwgdHlwZSwgdXJsLCBoZWFkZXJzLCBjb250ZW50VHlwZSB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ZldGNoV3JvbmdDb250ZW50VHlwZUVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYEZldGNoICR7dXJsfSByZWNlaXZlZCB1bmV4cGVjdGVkIENvbnRlbnQtVHlwZTogJHtjb250ZW50VHlwZX1gO1xuICAgIH1cblxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlY29uc3RpdHV0aW9uXG5cbmNvbnN0IEtOT1dOX0VSUk9SX0NMQVNTRVMgPSBuZXcgTWFwKClcbiAgICAuc2V0KFwiRmV0Y2hSZXNvbHZlZE5vdE9rRXJyb3JcIiwgRmV0Y2hSZXNvbHZlZE5vdE9rRXJyb3IpXG4gICAgLnNldChcIkZldGNoUmVqZWN0ZWRFcnJvclwiLCBGZXRjaFJlamVjdGVkRXJyb3IpXG4gICAgLnNldChcIk5vR3JvdXBFcnJvclwiLCBOb0dyb3VwRXJyb3IpXG4gICAgLnNldChcIkV4dGVuc2lvblVuYXZhaWxhYmxlRXJyb3JcIiwgRXh0ZW5zaW9uVW5hdmFpbGFibGVFcnJvcilcbiAgICAuc2V0KFwiTGFja2luZ0hvc3RQZXJtaXNzaW9uRXJyb3JcIiwgTGFja2luZ0hvc3RQZXJtaXNzaW9uRXJyb3IpXG4gICAgLnNldChcIkZldGNoV3JvbmdDb250ZW50VHlwZUVycm9yXCIsIEZldGNoV3JvbmdDb250ZW50VHlwZUVycm9yKVxuICAgIC5zZXQoXCJVbmtub3duUGVlckVycm9yXCIsIFVua25vd25QZWVyRXJyb3IpXG47XG5cbi8qIEF0dGVtcHQgdG8gcmVjb25zdGl0dXRlIGEgc3BlY2lhbCBlcnJvciBjbGFzcyBpbnN0YW5jZSBmcm9tIGEgZ2VuZXJpYyBFcnJvci5cbiAqIFdlIGxvb2sgYXQgdGhlIG1lc3NhZ2Ugb2YgdGhlIGdpdmVuIEVycm9yLiBJZiBpdCBhcHBlYXJzIHRvIGJlIHRoZSBzZXJpYWxpemF0aW9uXG4gKiBvZiBvbmUgb2Ygb3VyIHNwZWNpYWwgZXJyb3IgY2xhc3NlcywgdGhlbiB3ZSByZWJ1aWxkIGFuIGluc3RhbmNlIGJhc2VkIG9uIHRoaXMuXG4gKiBPdGhlcndpc2Ugd2UganVzdCByZXR1cm4gdGhlIGdpdmVuIEVycm9yLlxuICpcbiAqIHBhcmFtIGVycm9yOiBhbiBFcnJvciBpbnN0YW5jZVxuICogcmV0dXJuOiB0aGUgcmVjb25zdGl0dXRlZCBlcnJvciwgb3IgdGhlIGdpdmVuIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY29uc3RpdHV0ZUVycm9yKGVycm9yKSB7XG4gICAgbGV0IGQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGQgPSBKU09OLnBhcnNlKGVycm9yLm1lc3NhZ2UpO1xuICAgIH0gY2F0Y2gge31cbiAgICBpZiAoZCAmJiBLTk9XTl9FUlJPUl9DTEFTU0VTLmhhcyhkLl9lcnJvcl9jbGFzc19uYW1lKSkge1xuICAgICAgICBjb25zdCBDbGFzc0NvbnN0cnVjdG9yID0gS05PV05fRVJST1JfQ0xBU1NFUy5nZXQoZC5fZXJyb3JfY2xhc3NfbmFtZSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2xhc3NDb25zdHJ1Y3RvcihkKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/browser-peers/src/errors.js\n");

/***/ }),

/***/ "./node_modules/browser-peers/src/peer.js":
/*!************************************************!*\
  !*** ./node_modules/browser-peers/src/peer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Peer\": () => (/* binding */ Peer)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ \"./node_modules/browser-peers/src/errors.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./node_modules/browser-peers/src/util.js\");\n/*! browser-peers v0.1.0 | Copyright (c) 2020-2022 Steve Kieffer | MIT license */\n/* SPDX-License-Identifier: MIT */\n\n\n\n\n/* This is the abstract base class for all of our peer classes.\n * It implements everything to do with making and handling requests and responses.\n *\n * Subclasses are responsible for establishing connections between peers,\n * and for implementing the abstract `postMessageAsPeer` method defined by this\n * base class.\n *\n */\nclass Peer extends _util__WEBPACK_IMPORTED_MODULE_1__.Listenable {\n\n    /*\n     * @param name {string} a unique name for this peer, to tell it apart\n     *   from all others.\n     */\n    constructor(name) {\n        super({});\n\n        // For development and testing in settings like browser extensions under\n        // Manifest V3 (where background scripts are repeatedly terminated and\n        // restarted) it can be helpful to print debugging output in which we see\n        // the time at which a given peer was constructed.\n        this.constructionTime = (new Date()).toLocaleTimeString();\n\n        this.name = name;\n        this.handlers = new Map();\n        this.nextSeqNum = 0;\n        this.requestsBySeqNum = new Map();\n\n        this.reconstituteErrors = false;\n\n        this.readyResolve = null;\n        const self = this;\n        this.readyPromise = new Promise(resolve => {\n            self.readyResolve = resolve;\n        });\n\n        this.builtInHandlers = new Map()\n            .set('ready', this.ready.bind(this))\n        ;\n        for (let [name, handler] of this.builtInHandlers) {\n            this._addHandler(name, handler);\n        }\n    }\n\n    fromAddress() {\n        return this.name;\n    }\n\n    copyMessage(msg) {\n        return JSON.parse(JSON.stringify(msg));\n    }\n\n    // ------------------------------------------------------------------------\n    // Message handling\n\n    /* Subclasses should pass incoming request/response wrapper messages to this method.\n     *\n     * wrapper format: {\n     *   type {string} 'request' or 'response'\n     * }\n     *\n     * Furthermore, the wrapper must conform to the required format of `this.handleRequest`\n     * or `this.handleResponse`, according to the value of `wrapper.type`.\n     *\n     */\n    handleMessage(wrapper) {\n        if (wrapper.type === 'request') {\n            this.handleRequest(wrapper);\n        } else {\n            this.handleResponse(wrapper);\n        }\n    }\n\n    /*\n     * wrapper format: {\n     *   from {string} the name of the peer that sent the message,\n     *   seqNum {int} sequence number that will be used to associate response with request,\n     *   handlerDescrip {string} should be a valid descriptor string pointing to a handler\n     *     that has been registered with this peer,\n     *   args {any} will be passed to the handler\n     * }\n     */\n    handleRequest(wrapper) {\n        const peerName = wrapper.from;\n        const seqNum = wrapper.seqNum;\n        const handlerDescrip = wrapper.handlerDescrip;\n        const args = wrapper.args;\n        let handler;\n        try {\n            handler = this.lookupHandler(handlerDescrip);\n        } catch (e) {\n            this.returnRejection(peerName, seqNum, e);\n            return;\n        }\n        // Call the handler inside `Promise.resolve` so we can work with it asynchronously,\n        // even if the handler returns synchronously.\n        // We pass the whole wrapper as a second argument (which the handler may choose\n        // to ignore), in case the handler needs the \"meta\" information (such as the peer name).\n        Promise.resolve(handler(args, wrapper)).then(result => {\n            this.returnResponse(peerName, seqNum, result);\n        }).catch(reason => {\n            reason = this.checkHandlingError(reason, wrapper);\n            this.returnRejection(peerName, seqNum, reason);\n        });\n    }\n\n    /*\n     * @param peerName {string}\n     * @param seqNum {int}\n     * @param result {any}\n     */\n    returnResponse(peerName, seqNum, result) {\n        const wrapper = {\n            type: 'response',\n            from: this.fromAddress(),\n            seqNum: seqNum,\n            result: result,\n        };\n        this.postMessageAsPeer(peerName, wrapper);\n    }\n\n    /*\n     * @param peerName {string}\n     * @param seqNum {int}\n     * @param reason: {Error}\n     */\n    returnRejection(peerName, seqNum, reason) {\n        const wrapper = {\n            type: 'response',\n            from: this.fromAddress(),\n            seqNum: seqNum,\n            rejection_reason: reason.message,\n        };\n        this.postMessageAsPeer(peerName, wrapper);\n    }\n\n    consumeRequestData(seqNum) {\n        const data = this.requestsBySeqNum.get(seqNum);\n        if (data) window.clearTimeout(data.timeoutHandle);  // fails gracefully if timeout already cleared or handle is null\n        this.requestsBySeqNum.delete(seqNum);\n        return data;\n    }\n\n    /*\n     * wrapper format: {\n     *   REQUIRED:\n     *      from {string} the name of the peer that sent the message,\n     *      seqNum {int} sequence number that will be used to associate response with request,\n     *   EITHER/OR:\n     *      result {any} if the call was successful, this is the result to be returned.\n     *      rejection_reason {string} if the call failed, this is an indication of the reason.\n     * }\n     */\n    handleResponse(wrapper) {\n        const data = this.consumeRequestData(wrapper.seqNum);\n        if (!data) {\n            // Should only happen if request data already consumed due to timeout.\n            // In that case, caller already has their answer. So just do nothing.\n            return;\n        }\n        if (wrapper.rejection_reason) {\n            let e = new Error(wrapper.rejection_reason);\n            if (this.reconstituteErrors) {\n                e = (0,_errors__WEBPACK_IMPORTED_MODULE_0__.reconstituteError)(e);\n            }\n            data.reject(e);\n        } else {\n            data.resolve(wrapper.result);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Readiness\n    //\n    //   To be clear: this means readiness to handle requests, not to accept connections.\n    //   A peer instance is immediately ready to accept connections after construction.\n\n    /* Call this when you've finished adding handlers, in order to declare that this\n     * peer is ready to handle requests.\n     */\n    setReady() {\n        this.readyResolve();\n    }\n\n    /* This is our built-in handler for the 'ready' handler description.\n     *\n     * It returns a promise that other peers can use to wait until this peer is ready\n     * to accept connections.\n     */\n    ready() {\n        return this.readyPromise;\n    }\n\n    /* Convenience method to check the readiness of a connected peer.\n     */\n    checkReady(peerName) {\n        return this.makeRequest(peerName, 'ready', {}, false);\n    }\n\n    // ------------------------------------------------------------------------\n    // Request handlers\n\n    /* Add a handler function or handler object.\n     *\n     * Handler functions will be passed two arguments: `args` and `meta`. The first is an\n     * object passed by the client and presumably containing all the arguments required by\n     * the handler; the second is an object containing meta information about the request,\n     * such as the name of the client (which is under `meta.from`).\n     *\n     * Handlers may return a value synchronously, or may return a Promise. Either is acceptable.\n     *\n     * You may not register a handler under a reserved name, i.e. the names of any of our\n     * built-in handlers. These are defined in the constructor.\n     *\n     * @return: this instance, to support chaining.\n     */\n    addHandler(name, handler) {\n        if (this.builtInHandlers.has(name)) {\n            throw new Error(`Cannot register handler under reserved name: ${name}`);\n        }\n        this._addHandler(name, handler);\n        return this;\n    }\n\n    _addHandler(name, handler) {\n        this.handlers.set(name, handler);\n    }\n\n    /* Add a \"built-in handler,\" which really means a handler such that an error\n     * will be thrown if anyone tries to add a handler by the same name using the\n     * usual `addHandler` method.\n     *\n     * If the language supported it, we would make this a protected method, i.e.\n     * usable only by subclasses. So don't use it unless you should!\n     */\n    _addBuiltInHandler(name, handler) {\n        this.builtInHandlers.set(name, handler);\n        this._addHandler(name, handler);\n    }\n\n    /* Look up a handler, by its description.\n     *\n     * A handler description should be a string naming something that has been added as a\n     * handler for this server, or an attribute thereof, recursively.\n     *\n     * For example, if `myFunc` is a function, then after\n     *      server.addHandler('f', myFunc)\n     * 'f' is a valid description.\n     *\n     * If `myInstance` is an instance of a class that has a `doSomething` method, then\n     * after\n     *      server.addHandler('foo', myInstance)\n     * 'foo.doSomething' is a valid description.\n     *\n     * @param descrip {string} the description of the handler.\n     * @return: the handler. If the description was dotted, then the returned handler function\n     *   has the previous object in the chain bound as `this`.\n     * @throws: Error if the description does not resolve to anything, or if it does but that\n     *   thing is not a function.\n     */\n    lookupHandler(descrip) {\n        const parts = descrip.split('.');\n        let first = true;\n        let handler;\n        let prev;\n        for (let part of parts) {\n            if (first) {\n                first = false;\n                handler = this.handlers.get(part);\n            } else if (handler) {\n                prev = handler;\n                handler = handler[part];\n            } else {\n                break;\n            }\n        }\n        if (!handler) {\n            throw new Error(`Unknown handler: ${descrip}`);\n        }\n        if (typeof handler !== \"function\") {\n            throw new Error(`Handler \"${descrip}\" is not a function`);\n        }\n        if (prev) {\n            handler = handler.bind(prev);\n        }\n        return handler;\n    }\n\n    /* If you are on the same side as a peer, you can use this method to call\n     * one of its handlers directly, instead of within a request/response pair.\n     */\n    callHandler(handlerDescrip, args) {\n        const handler = this.lookupHandler(handlerDescrip);\n        return handler(args);\n    }\n\n    // ------------------------------------------------------------------------\n    // Making requests\n\n    takeNextSeqNum() {\n        const n = this.nextSeqNum;\n        this.nextSeqNum = n + 1;\n        return n;\n    }\n\n    /* Send a request to a single peer.\n     *\n     * @param peerName {string} The name of the peer to which the request should be sent.\n     * @param handlerDescrip {string} A description indicating the desired handler for the\n     *   request on the other side.\n     * @param args {obj} the arguments object to be passed to the handler on the other side.\n     *\n     * @param options: {\n     *   doReadyCheck {bool} optional, default false. Set true if you want to precede\n     *     the request with a ready check.\n     *   timeout {int} optional, default 0. Set positive if you want the request to timeout\n     *     after this many milliseconds. If 0 (or negative), will wait indefinitely.\n     *     In case of timeout, the returned promise rejects.\n     * }\n     *\n     * @return {Promise} promise that resolves with the response to the request, or rejects\n     *   with an error.\n     *\n     * See also: `broadcastRequest`.\n     */\n    makeRequest(peerName, handlerDescrip, args, options) {\n        const {\n            doReadyCheck = false,\n            timeout = 0,\n        } = options || {};\n        const seqNum = this.takeNextSeqNum();\n        const wrapper = {\n            type: 'request',\n            from: this.fromAddress(),\n            seqNum: seqNum,\n            handlerDescrip: handlerDescrip,\n            args: args,\n        };\n        const check = doReadyCheck ? this.checkReady(peerName) : Promise.resolve();\n        return check.then(() => {\n            return new Promise((resolve, reject) => {\n                const timeoutHandle = timeout < 1 ? null : window.setTimeout(() => {\n                    const data = this.consumeRequestData(seqNum);\n                    if (!data) return; // Request was already handled.\n                    reject(new Error('Peer request timed out.'));\n                }, timeout);\n                this.requestsBySeqNum.set(seqNum, {\n                    resolve: resolve,\n                    reject: reject,\n                    timeoutHandle: timeoutHandle,\n                });\n                this.postMessageAsPeer(peerName, wrapper);\n            });\n        });\n    }\n\n    /* Broadcast a request to all connected peers (or a subset, by filtering).\n     *\n     * This just performs multiple requests. Particular subclasses may have more\n     * efficient ways of broadcasting that they may prefer to use instead.\n     *\n     * @param handlerDescrip {string} A description indicating the desired handler for the\n     *   request on the other side.\n     * @param args {obj} the arguments object to be passed to the handler on the other side.\n     *\n     * @param options: {\n     *   excludeSelf {bool} If true, do not send the request to self. This is relevant for\n     *     some peer types that keep their own name in their set of peers; for those that\n     *     do not, it can be ignored.\n     *   filter {function} optional function mapping peer names to booleans. Allows to\n     *     broadcast to a subset of all connected peers, namely those mapping to `true`.\n     *     If `excludeSelf` is true, that exclusion happens first, and the given filter\n     *     is applied to what remains.\n     *   skipReadyChecks {bool} optional, default false. If false we will precede each\n     *     request with a readiness check. Set true to skip.\n     * }\n     *\n     * @return {Array[Promise]} array of the promises returned by our `makeRequest` method,\n     *   one for each peer to which a request was sent.\n     *\n     * See also: `makeRequest`.\n     *\n     * Note: While in the `makeRequest` method the ready check is skipped by default, here the\n     *   behavior is the opposite, and the ready checks are performed by default. It is felt that,\n     *   rather than being confusing, this caters to normal usage patterns. It will be normal to\n     *   be broadcasting to a collection of peers for which we are _not_ carefully maintaining state;\n     *   whereas when requesting from a single peer, we are more likely to have already performed an\n     *   initial (one-time) ready check ourselves.\n     */\n    broadcastRequest(handlerDescrip, args, options) {\n        const {\n            excludeSelf = false,\n            filter = (() => true),\n            skipReadyChecks = false\n        } = options || {};\n        const peerNames = this.getAllPeerNames().filter(name => (!excludeSelf) || name !== this.name).filter(filter);\n        const responsePromises = [];\n        for (let peerName of peerNames) {\n            responsePromises.push(this.makeRequest(peerName, handlerDescrip, args, {\n                doReadyCheck: !skipReadyChecks,\n            }));\n        }\n        return responsePromises;\n    }\n\n    // ------------------------------------------------------------------------\n    // Abstract methods subclasses MAY override\n\n    /* Subclasses should override this method if they want to use this\n     * base class's `broadcastRequest` method.\n     *\n     * @return {Array[string]} an Array of the names of all connected peers.\n     */\n    getAllPeerNames() {\n        return [];\n    }\n\n    /* This gives a chance to examine and modify a handler error, and possibly\n     * have side effects, before the error is returned.\n     *\n     * @param reason: Error thrown by request handler.\n     * @param wrapper: the wrapper message that was being handled.\n     * @return: Error instance. May be the same as the given reason, or different.\n     */\n    checkHandlingError(reason, wrapper) {\n        return reason;\n    }\n\n    // ------------------------------------------------------------------------\n    // Abstract methods subclasses MUST override\n\n    /* This is where subclasses must use their transport-specific method of getting\n     * a serializable message from one peer to another.\n     *\n     * Specifically, the message to be communicated here is one of the \"wrapper\"\n     * messages we use to represent requests and responses. The intention therefore\n     * is that it be delivered to the `handleMessage` method of the peer (which should\n     * _not_ be overridden, but should be inherited from this base class).\n     *\n     * @param peerName {string} the name of a connected peer\n     * @param wrapper {obj} the wrapper message to be posted to that peer. Format: {\n     *   type {string} equal to either 'request' or 'response', appropriately.\n     * }\n     */\n    postMessageAsPeer(peerName, wrapper) {\n        //\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvcGVlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGZzYy1pc2UvLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvcGVlci5qcz84NjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBicm93c2VyLXBlZXJzIHYwLjEuMCB8IENvcHlyaWdodCAoYykgMjAyMC0yMDIyIFN0ZXZlIEtpZWZmZXIgfCBNSVQgbGljZW5zZSAqL1xuLyogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVCAqL1xuXG5pbXBvcnQgeyByZWNvbnN0aXR1dGVFcnJvciB9IGZyb20gXCIuL2Vycm9yc1wiO1xuaW1wb3J0IHsgTGlzdGVuYWJsZSB9IGZyb20gXCIuL3V0aWxcIjtcblxuLyogVGhpcyBpcyB0aGUgYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIG9mIG91ciBwZWVyIGNsYXNzZXMuXG4gKiBJdCBpbXBsZW1lbnRzIGV2ZXJ5dGhpbmcgdG8gZG8gd2l0aCBtYWtpbmcgYW5kIGhhbmRsaW5nIHJlcXVlc3RzIGFuZCByZXNwb25zZXMuXG4gKlxuICogU3ViY2xhc3NlcyBhcmUgcmVzcG9uc2libGUgZm9yIGVzdGFibGlzaGluZyBjb25uZWN0aW9ucyBiZXR3ZWVuIHBlZXJzLFxuICogYW5kIGZvciBpbXBsZW1lbnRpbmcgdGhlIGFic3RyYWN0IGBwb3N0TWVzc2FnZUFzUGVlcmAgbWV0aG9kIGRlZmluZWQgYnkgdGhpc1xuICogYmFzZSBjbGFzcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBQZWVyIGV4dGVuZHMgTGlzdGVuYWJsZSB7XG5cbiAgICAvKlxuICAgICAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9IGEgdW5pcXVlIG5hbWUgZm9yIHRoaXMgcGVlciwgdG8gdGVsbCBpdCBhcGFydFxuICAgICAqICAgZnJvbSBhbGwgb3RoZXJzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoe30pO1xuXG4gICAgICAgIC8vIEZvciBkZXZlbG9wbWVudCBhbmQgdGVzdGluZyBpbiBzZXR0aW5ncyBsaWtlIGJyb3dzZXIgZXh0ZW5zaW9ucyB1bmRlclxuICAgICAgICAvLyBNYW5pZmVzdCBWMyAod2hlcmUgYmFja2dyb3VuZCBzY3JpcHRzIGFyZSByZXBlYXRlZGx5IHRlcm1pbmF0ZWQgYW5kXG4gICAgICAgIC8vIHJlc3RhcnRlZCkgaXQgY2FuIGJlIGhlbHBmdWwgdG8gcHJpbnQgZGVidWdnaW5nIG91dHB1dCBpbiB3aGljaCB3ZSBzZWVcbiAgICAgICAgLy8gdGhlIHRpbWUgYXQgd2hpY2ggYSBnaXZlbiBwZWVyIHdhcyBjb25zdHJ1Y3RlZC5cbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rpb25UaW1lID0gKG5ldyBEYXRlKCkpLnRvTG9jYWxlVGltZVN0cmluZygpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmV4dFNlcU51bSA9IDA7XG4gICAgICAgIHRoaXMucmVxdWVzdHNCeVNlcU51bSA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLnJlY29uc3RpdHV0ZUVycm9ycyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucmVhZHlSZXNvbHZlID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBzZWxmLnJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYnVpbHRJbkhhbmRsZXJzID0gbmV3IE1hcCgpXG4gICAgICAgICAgICAuc2V0KCdyZWFkeScsIHRoaXMucmVhZHkuYmluZCh0aGlzKSlcbiAgICAgICAgO1xuICAgICAgICBmb3IgKGxldCBbbmFtZSwgaGFuZGxlcl0gb2YgdGhpcy5idWlsdEluSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEhhbmRsZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmcm9tQWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG5cbiAgICBjb3B5TWVzc2FnZShtc2cpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobXNnKSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTWVzc2FnZSBoYW5kbGluZ1xuXG4gICAgLyogU3ViY2xhc3NlcyBzaG91bGQgcGFzcyBpbmNvbWluZyByZXF1ZXN0L3Jlc3BvbnNlIHdyYXBwZXIgbWVzc2FnZXMgdG8gdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiB3cmFwcGVyIGZvcm1hdDoge1xuICAgICAqICAgdHlwZSB7c3RyaW5nfSAncmVxdWVzdCcgb3IgJ3Jlc3BvbnNlJ1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZ1cnRoZXJtb3JlLCB0aGUgd3JhcHBlciBtdXN0IGNvbmZvcm0gdG8gdGhlIHJlcXVpcmVkIGZvcm1hdCBvZiBgdGhpcy5oYW5kbGVSZXF1ZXN0YFxuICAgICAqIG9yIGB0aGlzLmhhbmRsZVJlc3BvbnNlYCwgYWNjb3JkaW5nIHRvIHRoZSB2YWx1ZSBvZiBgd3JhcHBlci50eXBlYC5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhbmRsZU1lc3NhZ2Uod3JhcHBlcikge1xuICAgICAgICBpZiAod3JhcHBlci50eXBlID09PSAncmVxdWVzdCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVxdWVzdCh3cmFwcGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzcG9uc2Uod3JhcHBlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIHdyYXBwZXIgZm9ybWF0OiB7XG4gICAgICogICBmcm9tIHtzdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBwZWVyIHRoYXQgc2VudCB0aGUgbWVzc2FnZSxcbiAgICAgKiAgIHNlcU51bSB7aW50fSBzZXF1ZW5jZSBudW1iZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYXNzb2NpYXRlIHJlc3BvbnNlIHdpdGggcmVxdWVzdCxcbiAgICAgKiAgIGhhbmRsZXJEZXNjcmlwIHtzdHJpbmd9IHNob3VsZCBiZSBhIHZhbGlkIGRlc2NyaXB0b3Igc3RyaW5nIHBvaW50aW5nIHRvIGEgaGFuZGxlclxuICAgICAqICAgICB0aGF0IGhhcyBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIHBlZXIsXG4gICAgICogICBhcmdzIHthbnl9IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBoYW5kbGVyXG4gICAgICogfVxuICAgICAqL1xuICAgIGhhbmRsZVJlcXVlc3Qod3JhcHBlcikge1xuICAgICAgICBjb25zdCBwZWVyTmFtZSA9IHdyYXBwZXIuZnJvbTtcbiAgICAgICAgY29uc3Qgc2VxTnVtID0gd3JhcHBlci5zZXFOdW07XG4gICAgICAgIGNvbnN0IGhhbmRsZXJEZXNjcmlwID0gd3JhcHBlci5oYW5kbGVyRGVzY3JpcDtcbiAgICAgICAgY29uc3QgYXJncyA9IHdyYXBwZXIuYXJncztcbiAgICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5sb29rdXBIYW5kbGVyKGhhbmRsZXJEZXNjcmlwKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5SZWplY3Rpb24ocGVlck5hbWUsIHNlcU51bSwgZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCB0aGUgaGFuZGxlciBpbnNpZGUgYFByb21pc2UucmVzb2x2ZWAgc28gd2UgY2FuIHdvcmsgd2l0aCBpdCBhc3luY2hyb25vdXNseSxcbiAgICAgICAgLy8gZXZlbiBpZiB0aGUgaGFuZGxlciByZXR1cm5zIHN5bmNocm9ub3VzbHkuXG4gICAgICAgIC8vIFdlIHBhc3MgdGhlIHdob2xlIHdyYXBwZXIgYXMgYSBzZWNvbmQgYXJndW1lbnQgKHdoaWNoIHRoZSBoYW5kbGVyIG1heSBjaG9vc2VcbiAgICAgICAgLy8gdG8gaWdub3JlKSwgaW4gY2FzZSB0aGUgaGFuZGxlciBuZWVkcyB0aGUgXCJtZXRhXCIgaW5mb3JtYXRpb24gKHN1Y2ggYXMgdGhlIHBlZXIgbmFtZSkuXG4gICAgICAgIFByb21pc2UucmVzb2x2ZShoYW5kbGVyKGFyZ3MsIHdyYXBwZXIpKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICB0aGlzLnJldHVyblJlc3BvbnNlKHBlZXJOYW1lLCBzZXFOdW0sIHJlc3VsdCk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICByZWFzb24gPSB0aGlzLmNoZWNrSGFuZGxpbmdFcnJvcihyZWFzb24sIHdyYXBwZXIpO1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5SZWplY3Rpb24ocGVlck5hbWUsIHNlcU51bSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBAcGFyYW0gcGVlck5hbWUge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gc2VxTnVtIHtpbnR9XG4gICAgICogQHBhcmFtIHJlc3VsdCB7YW55fVxuICAgICAqL1xuICAgIHJldHVyblJlc3BvbnNlKHBlZXJOYW1lLCBzZXFOdW0sIHJlc3VsdCkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0ge1xuICAgICAgICAgICAgdHlwZTogJ3Jlc3BvbnNlJyxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbUFkZHJlc3MoKSxcbiAgICAgICAgICAgIHNlcU51bTogc2VxTnVtLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2VBc1BlZXIocGVlck5hbWUsIHdyYXBwZXIpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQHBhcmFtIHBlZXJOYW1lIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHNlcU51bSB7aW50fVxuICAgICAqIEBwYXJhbSByZWFzb246IHtFcnJvcn1cbiAgICAgKi9cbiAgICByZXR1cm5SZWplY3Rpb24ocGVlck5hbWUsIHNlcU51bSwgcmVhc29uKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB7XG4gICAgICAgICAgICB0eXBlOiAncmVzcG9uc2UnLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tQWRkcmVzcygpLFxuICAgICAgICAgICAgc2VxTnVtOiBzZXFOdW0sXG4gICAgICAgICAgICByZWplY3Rpb25fcmVhc29uOiByZWFzb24ubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wb3N0TWVzc2FnZUFzUGVlcihwZWVyTmFtZSwgd3JhcHBlcik7XG4gICAgfVxuXG4gICAgY29uc3VtZVJlcXVlc3REYXRhKHNlcU51bSkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5yZXF1ZXN0c0J5U2VxTnVtLmdldChzZXFOdW0pO1xuICAgICAgICBpZiAoZGF0YSkgd2luZG93LmNsZWFyVGltZW91dChkYXRhLnRpbWVvdXRIYW5kbGUpOyAgLy8gZmFpbHMgZ3JhY2VmdWxseSBpZiB0aW1lb3V0IGFscmVhZHkgY2xlYXJlZCBvciBoYW5kbGUgaXMgbnVsbFxuICAgICAgICB0aGlzLnJlcXVlc3RzQnlTZXFOdW0uZGVsZXRlKHNlcU51bSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogd3JhcHBlciBmb3JtYXQ6IHtcbiAgICAgKiAgIFJFUVVJUkVEOlxuICAgICAqICAgICAgZnJvbSB7c3RyaW5nfSB0aGUgbmFtZSBvZiB0aGUgcGVlciB0aGF0IHNlbnQgdGhlIG1lc3NhZ2UsXG4gICAgICogICAgICBzZXFOdW0ge2ludH0gc2VxdWVuY2UgbnVtYmVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFzc29jaWF0ZSByZXNwb25zZSB3aXRoIHJlcXVlc3QsXG4gICAgICogICBFSVRIRVIvT1I6XG4gICAgICogICAgICByZXN1bHQge2FueX0gaWYgdGhlIGNhbGwgd2FzIHN1Y2Nlc3NmdWwsIHRoaXMgaXMgdGhlIHJlc3VsdCB0byBiZSByZXR1cm5lZC5cbiAgICAgKiAgICAgIHJlamVjdGlvbl9yZWFzb24ge3N0cmluZ30gaWYgdGhlIGNhbGwgZmFpbGVkLCB0aGlzIGlzIGFuIGluZGljYXRpb24gb2YgdGhlIHJlYXNvbi5cbiAgICAgKiB9XG4gICAgICovXG4gICAgaGFuZGxlUmVzcG9uc2Uod3JhcHBlcikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5jb25zdW1lUmVxdWVzdERhdGEod3JhcHBlci5zZXFOdW0pO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIC8vIFNob3VsZCBvbmx5IGhhcHBlbiBpZiByZXF1ZXN0IGRhdGEgYWxyZWFkeSBjb25zdW1lZCBkdWUgdG8gdGltZW91dC5cbiAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgY2FsbGVyIGFscmVhZHkgaGFzIHRoZWlyIGFuc3dlci4gU28ganVzdCBkbyBub3RoaW5nLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwcGVyLnJlamVjdGlvbl9yZWFzb24pIHtcbiAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKHdyYXBwZXIucmVqZWN0aW9uX3JlYXNvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWNvbnN0aXR1dGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBlID0gcmVjb25zdGl0dXRlRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLnJlamVjdChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEucmVzb2x2ZSh3cmFwcGVyLnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSZWFkaW5lc3NcbiAgICAvL1xuICAgIC8vICAgVG8gYmUgY2xlYXI6IHRoaXMgbWVhbnMgcmVhZGluZXNzIHRvIGhhbmRsZSByZXF1ZXN0cywgbm90IHRvIGFjY2VwdCBjb25uZWN0aW9ucy5cbiAgICAvLyAgIEEgcGVlciBpbnN0YW5jZSBpcyBpbW1lZGlhdGVseSByZWFkeSB0byBhY2NlcHQgY29ubmVjdGlvbnMgYWZ0ZXIgY29uc3RydWN0aW9uLlxuXG4gICAgLyogQ2FsbCB0aGlzIHdoZW4geW91J3ZlIGZpbmlzaGVkIGFkZGluZyBoYW5kbGVycywgaW4gb3JkZXIgdG8gZGVjbGFyZSB0aGF0IHRoaXNcbiAgICAgKiBwZWVyIGlzIHJlYWR5IHRvIGhhbmRsZSByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBzZXRSZWFkeSgpIHtcbiAgICAgICAgdGhpcy5yZWFkeVJlc29sdmUoKTtcbiAgICB9XG5cbiAgICAvKiBUaGlzIGlzIG91ciBidWlsdC1pbiBoYW5kbGVyIGZvciB0aGUgJ3JlYWR5JyBoYW5kbGVyIGRlc2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogSXQgcmV0dXJucyBhIHByb21pc2UgdGhhdCBvdGhlciBwZWVycyBjYW4gdXNlIHRvIHdhaXQgdW50aWwgdGhpcyBwZWVyIGlzIHJlYWR5XG4gICAgICogdG8gYWNjZXB0IGNvbm5lY3Rpb25zLlxuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeVByb21pc2U7XG4gICAgfVxuXG4gICAgLyogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGNoZWNrIHRoZSByZWFkaW5lc3Mgb2YgYSBjb25uZWN0ZWQgcGVlci5cbiAgICAgKi9cbiAgICBjaGVja1JlYWR5KHBlZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KHBlZXJOYW1lLCAncmVhZHknLCB7fSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJlcXVlc3QgaGFuZGxlcnNcblxuICAgIC8qIEFkZCBhIGhhbmRsZXIgZnVuY3Rpb24gb3IgaGFuZGxlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBIYW5kbGVyIGZ1bmN0aW9ucyB3aWxsIGJlIHBhc3NlZCB0d28gYXJndW1lbnRzOiBgYXJnc2AgYW5kIGBtZXRhYC4gVGhlIGZpcnN0IGlzIGFuXG4gICAgICogb2JqZWN0IHBhc3NlZCBieSB0aGUgY2xpZW50IGFuZCBwcmVzdW1hYmx5IGNvbnRhaW5pbmcgYWxsIHRoZSBhcmd1bWVudHMgcmVxdWlyZWQgYnlcbiAgICAgKiB0aGUgaGFuZGxlcjsgdGhlIHNlY29uZCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXF1ZXN0LFxuICAgICAqIHN1Y2ggYXMgdGhlIG5hbWUgb2YgdGhlIGNsaWVudCAod2hpY2ggaXMgdW5kZXIgYG1ldGEuZnJvbWApLlxuICAgICAqXG4gICAgICogSGFuZGxlcnMgbWF5IHJldHVybiBhIHZhbHVlIHN5bmNocm9ub3VzbHksIG9yIG1heSByZXR1cm4gYSBQcm9taXNlLiBFaXRoZXIgaXMgYWNjZXB0YWJsZS5cbiAgICAgKlxuICAgICAqIFlvdSBtYXkgbm90IHJlZ2lzdGVyIGEgaGFuZGxlciB1bmRlciBhIHJlc2VydmVkIG5hbWUsIGkuZS4gdGhlIG5hbWVzIG9mIGFueSBvZiBvdXJcbiAgICAgKiBidWlsdC1pbiBoYW5kbGVycy4gVGhlc2UgYXJlIGRlZmluZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybjogdGhpcyBpbnN0YW5jZSwgdG8gc3VwcG9ydCBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBhZGRIYW5kbGVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVpbHRJbkhhbmRsZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVnaXN0ZXIgaGFuZGxlciB1bmRlciByZXNlcnZlZCBuYW1lOiAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWRkSGFuZGxlcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX2FkZEhhbmRsZXIobmFtZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnNldChuYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKiBBZGQgYSBcImJ1aWx0LWluIGhhbmRsZXIsXCIgd2hpY2ggcmVhbGx5IG1lYW5zIGEgaGFuZGxlciBzdWNoIHRoYXQgYW4gZXJyb3JcbiAgICAgKiB3aWxsIGJlIHRocm93biBpZiBhbnlvbmUgdHJpZXMgdG8gYWRkIGEgaGFuZGxlciBieSB0aGUgc2FtZSBuYW1lIHVzaW5nIHRoZVxuICAgICAqIHVzdWFsIGBhZGRIYW5kbGVyYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbGFuZ3VhZ2Ugc3VwcG9ydGVkIGl0LCB3ZSB3b3VsZCBtYWtlIHRoaXMgYSBwcm90ZWN0ZWQgbWV0aG9kLCBpLmUuXG4gICAgICogdXNhYmxlIG9ubHkgYnkgc3ViY2xhc3Nlcy4gU28gZG9uJ3QgdXNlIGl0IHVubGVzcyB5b3Ugc2hvdWxkIVxuICAgICAqL1xuICAgIF9hZGRCdWlsdEluSGFuZGxlcihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuYnVpbHRJbkhhbmRsZXJzLnNldChuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fYWRkSGFuZGxlcihuYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKiBMb29rIHVwIGEgaGFuZGxlciwgYnkgaXRzIGRlc2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQSBoYW5kbGVyIGRlc2NyaXB0aW9uIHNob3VsZCBiZSBhIHN0cmluZyBuYW1pbmcgc29tZXRoaW5nIHRoYXQgaGFzIGJlZW4gYWRkZWQgYXMgYVxuICAgICAqIGhhbmRsZXIgZm9yIHRoaXMgc2VydmVyLCBvciBhbiBhdHRyaWJ1dGUgdGhlcmVvZiwgcmVjdXJzaXZlbHkuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgYG15RnVuY2AgaXMgYSBmdW5jdGlvbiwgdGhlbiBhZnRlclxuICAgICAqICAgICAgc2VydmVyLmFkZEhhbmRsZXIoJ2YnLCBteUZ1bmMpXG4gICAgICogJ2YnIGlzIGEgdmFsaWQgZGVzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBJZiBgbXlJbnN0YW5jZWAgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyB0aGF0IGhhcyBhIGBkb1NvbWV0aGluZ2AgbWV0aG9kLCB0aGVuXG4gICAgICogYWZ0ZXJcbiAgICAgKiAgICAgIHNlcnZlci5hZGRIYW5kbGVyKCdmb28nLCBteUluc3RhbmNlKVxuICAgICAqICdmb28uZG9Tb21ldGhpbmcnIGlzIGEgdmFsaWQgZGVzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVzY3JpcCB7c3RyaW5nfSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGhhbmRsZXIuXG4gICAgICogQHJldHVybjogdGhlIGhhbmRsZXIuIElmIHRoZSBkZXNjcmlwdGlvbiB3YXMgZG90dGVkLCB0aGVuIHRoZSByZXR1cm5lZCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogICBoYXMgdGhlIHByZXZpb3VzIG9iamVjdCBpbiB0aGUgY2hhaW4gYm91bmQgYXMgYHRoaXNgLlxuICAgICAqIEB0aHJvd3M6IEVycm9yIGlmIHRoZSBkZXNjcmlwdGlvbiBkb2VzIG5vdCByZXNvbHZlIHRvIGFueXRoaW5nLCBvciBpZiBpdCBkb2VzIGJ1dCB0aGF0XG4gICAgICogICB0aGluZyBpcyBub3QgYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBsb29rdXBIYW5kbGVyKGRlc2NyaXApIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBkZXNjcmlwLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgIGxldCBoYW5kbGVyO1xuICAgICAgICBsZXQgcHJldjtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5oYW5kbGVycy5nZXQocGFydCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gaGFuZGxlcjtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gaGFuZGxlcltwYXJ0XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaGFuZGxlcjogJHtkZXNjcmlwfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhhbmRsZXIgXCIke2Rlc2NyaXB9XCIgaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuYmluZChwcmV2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG5cbiAgICAvKiBJZiB5b3UgYXJlIG9uIHRoZSBzYW1lIHNpZGUgYXMgYSBwZWVyLCB5b3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBjYWxsXG4gICAgICogb25lIG9mIGl0cyBoYW5kbGVycyBkaXJlY3RseSwgaW5zdGVhZCBvZiB3aXRoaW4gYSByZXF1ZXN0L3Jlc3BvbnNlIHBhaXIuXG4gICAgICovXG4gICAgY2FsbEhhbmRsZXIoaGFuZGxlckRlc2NyaXAsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMubG9va3VwSGFuZGxlcihoYW5kbGVyRGVzY3JpcCk7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1ha2luZyByZXF1ZXN0c1xuXG4gICAgdGFrZU5leHRTZXFOdW0oKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLm5leHRTZXFOdW07XG4gICAgICAgIHRoaXMubmV4dFNlcU51bSA9IG4gKyAxO1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKiBTZW5kIGEgcmVxdWVzdCB0byBhIHNpbmdsZSBwZWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBlZXJOYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBwZWVyIHRvIHdoaWNoIHRoZSByZXF1ZXN0IHNob3VsZCBiZSBzZW50LlxuICAgICAqIEBwYXJhbSBoYW5kbGVyRGVzY3JpcCB7c3RyaW5nfSBBIGRlc2NyaXB0aW9uIGluZGljYXRpbmcgdGhlIGRlc2lyZWQgaGFuZGxlciBmb3IgdGhlXG4gICAgICogICByZXF1ZXN0IG9uIHRoZSBvdGhlciBzaWRlLlxuICAgICAqIEBwYXJhbSBhcmdzIHtvYmp9IHRoZSBhcmd1bWVudHMgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byB0aGUgaGFuZGxlciBvbiB0aGUgb3RoZXIgc2lkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zOiB7XG4gICAgICogICBkb1JlYWR5Q2hlY2sge2Jvb2x9IG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLiBTZXQgdHJ1ZSBpZiB5b3Ugd2FudCB0byBwcmVjZWRlXG4gICAgICogICAgIHRoZSByZXF1ZXN0IHdpdGggYSByZWFkeSBjaGVjay5cbiAgICAgKiAgIHRpbWVvdXQge2ludH0gb3B0aW9uYWwsIGRlZmF1bHQgMC4gU2V0IHBvc2l0aXZlIGlmIHlvdSB3YW50IHRoZSByZXF1ZXN0IHRvIHRpbWVvdXRcbiAgICAgKiAgICAgYWZ0ZXIgdGhpcyBtYW55IG1pbGxpc2Vjb25kcy4gSWYgMCAob3IgbmVnYXRpdmUpLCB3aWxsIHdhaXQgaW5kZWZpbml0ZWx5LlxuICAgICAqICAgICBJbiBjYXNlIG9mIHRpbWVvdXQsIHRoZSByZXR1cm5lZCBwcm9taXNlIHJlamVjdHMuXG4gICAgICogfVxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0LCBvciByZWplY3RzXG4gICAgICogICB3aXRoIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogU2VlIGFsc286IGBicm9hZGNhc3RSZXF1ZXN0YC5cbiAgICAgKi9cbiAgICBtYWtlUmVxdWVzdChwZWVyTmFtZSwgaGFuZGxlckRlc2NyaXAsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZG9SZWFkeUNoZWNrID0gZmFsc2UsXG4gICAgICAgICAgICB0aW1lb3V0ID0gMCxcbiAgICAgICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IHNlcU51bSA9IHRoaXMudGFrZU5leHRTZXFOdW0oKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdyZXF1ZXN0JyxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbUFkZHJlc3MoKSxcbiAgICAgICAgICAgIHNlcU51bTogc2VxTnVtLFxuICAgICAgICAgICAgaGFuZGxlckRlc2NyaXA6IGhhbmRsZXJEZXNjcmlwLFxuICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hlY2sgPSBkb1JlYWR5Q2hlY2sgPyB0aGlzLmNoZWNrUmVhZHkocGVlck5hbWUpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiBjaGVjay50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHRpbWVvdXQgPCAxID8gbnVsbCA6IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuY29uc3VtZVJlcXVlc3REYXRhKHNlcU51bSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkgcmV0dXJuOyAvLyBSZXF1ZXN0IHdhcyBhbHJlYWR5IGhhbmRsZWQuXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1BlZXIgcmVxdWVzdCB0aW1lZCBvdXQuJykpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHNCeVNlcU51bS5zZXQoc2VxTnVtLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SGFuZGxlOiB0aW1lb3V0SGFuZGxlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2VBc1BlZXIocGVlck5hbWUsIHdyYXBwZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIEJyb2FkY2FzdCBhIHJlcXVlc3QgdG8gYWxsIGNvbm5lY3RlZCBwZWVycyAob3IgYSBzdWJzZXQsIGJ5IGZpbHRlcmluZykuXG4gICAgICpcbiAgICAgKiBUaGlzIGp1c3QgcGVyZm9ybXMgbXVsdGlwbGUgcmVxdWVzdHMuIFBhcnRpY3VsYXIgc3ViY2xhc3NlcyBtYXkgaGF2ZSBtb3JlXG4gICAgICogZWZmaWNpZW50IHdheXMgb2YgYnJvYWRjYXN0aW5nIHRoYXQgdGhleSBtYXkgcHJlZmVyIHRvIHVzZSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZXJEZXNjcmlwIHtzdHJpbmd9IEEgZGVzY3JpcHRpb24gaW5kaWNhdGluZyB0aGUgZGVzaXJlZCBoYW5kbGVyIGZvciB0aGVcbiAgICAgKiAgIHJlcXVlc3Qgb24gdGhlIG90aGVyIHNpZGUuXG4gICAgICogQHBhcmFtIGFyZ3Mge29ian0gdGhlIGFyZ3VtZW50cyBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIHRoZSBoYW5kbGVyIG9uIHRoZSBvdGhlciBzaWRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnM6IHtcbiAgICAgKiAgIGV4Y2x1ZGVTZWxmIHtib29sfSBJZiB0cnVlLCBkbyBub3Qgc2VuZCB0aGUgcmVxdWVzdCB0byBzZWxmLiBUaGlzIGlzIHJlbGV2YW50IGZvclxuICAgICAqICAgICBzb21lIHBlZXIgdHlwZXMgdGhhdCBrZWVwIHRoZWlyIG93biBuYW1lIGluIHRoZWlyIHNldCBvZiBwZWVyczsgZm9yIHRob3NlIHRoYXRcbiAgICAgKiAgICAgZG8gbm90LCBpdCBjYW4gYmUgaWdub3JlZC5cbiAgICAgKiAgIGZpbHRlciB7ZnVuY3Rpb259IG9wdGlvbmFsIGZ1bmN0aW9uIG1hcHBpbmcgcGVlciBuYW1lcyB0byBib29sZWFucy4gQWxsb3dzIHRvXG4gICAgICogICAgIGJyb2FkY2FzdCB0byBhIHN1YnNldCBvZiBhbGwgY29ubmVjdGVkIHBlZXJzLCBuYW1lbHkgdGhvc2UgbWFwcGluZyB0byBgdHJ1ZWAuXG4gICAgICogICAgIElmIGBleGNsdWRlU2VsZmAgaXMgdHJ1ZSwgdGhhdCBleGNsdXNpb24gaGFwcGVucyBmaXJzdCwgYW5kIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICAgKiAgICAgaXMgYXBwbGllZCB0byB3aGF0IHJlbWFpbnMuXG4gICAgICogICBza2lwUmVhZHlDaGVja3Mge2Jvb2x9IG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLiBJZiBmYWxzZSB3ZSB3aWxsIHByZWNlZGUgZWFjaFxuICAgICAqICAgICByZXF1ZXN0IHdpdGggYSByZWFkaW5lc3MgY2hlY2suIFNldCB0cnVlIHRvIHNraXAuXG4gICAgICogfVxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXlbUHJvbWlzZV19IGFycmF5IG9mIHRoZSBwcm9taXNlcyByZXR1cm5lZCBieSBvdXIgYG1ha2VSZXF1ZXN0YCBtZXRob2QsXG4gICAgICogICBvbmUgZm9yIGVhY2ggcGVlciB0byB3aGljaCBhIHJlcXVlc3Qgd2FzIHNlbnQuXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbzogYG1ha2VSZXF1ZXN0YC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFdoaWxlIGluIHRoZSBgbWFrZVJlcXVlc3RgIG1ldGhvZCB0aGUgcmVhZHkgY2hlY2sgaXMgc2tpcHBlZCBieSBkZWZhdWx0LCBoZXJlIHRoZVxuICAgICAqICAgYmVoYXZpb3IgaXMgdGhlIG9wcG9zaXRlLCBhbmQgdGhlIHJlYWR5IGNoZWNrcyBhcmUgcGVyZm9ybWVkIGJ5IGRlZmF1bHQuIEl0IGlzIGZlbHQgdGhhdCxcbiAgICAgKiAgIHJhdGhlciB0aGFuIGJlaW5nIGNvbmZ1c2luZywgdGhpcyBjYXRlcnMgdG8gbm9ybWFsIHVzYWdlIHBhdHRlcm5zLiBJdCB3aWxsIGJlIG5vcm1hbCB0b1xuICAgICAqICAgYmUgYnJvYWRjYXN0aW5nIHRvIGEgY29sbGVjdGlvbiBvZiBwZWVycyBmb3Igd2hpY2ggd2UgYXJlIF9ub3RfIGNhcmVmdWxseSBtYWludGFpbmluZyBzdGF0ZTtcbiAgICAgKiAgIHdoZXJlYXMgd2hlbiByZXF1ZXN0aW5nIGZyb20gYSBzaW5nbGUgcGVlciwgd2UgYXJlIG1vcmUgbGlrZWx5IHRvIGhhdmUgYWxyZWFkeSBwZXJmb3JtZWQgYW5cbiAgICAgKiAgIGluaXRpYWwgKG9uZS10aW1lKSByZWFkeSBjaGVjayBvdXJzZWx2ZXMuXG4gICAgICovXG4gICAgYnJvYWRjYXN0UmVxdWVzdChoYW5kbGVyRGVzY3JpcCwgYXJncywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBleGNsdWRlU2VsZiA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsdGVyID0gKCgpID0+IHRydWUpLFxuICAgICAgICAgICAgc2tpcFJlYWR5Q2hlY2tzID0gZmFsc2VcbiAgICAgICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IHBlZXJOYW1lcyA9IHRoaXMuZ2V0QWxsUGVlck5hbWVzKCkuZmlsdGVyKG5hbWUgPT4gKCFleGNsdWRlU2VsZikgfHwgbmFtZSAhPT0gdGhpcy5uYW1lKS5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwZWVyTmFtZSBvZiBwZWVyTmFtZXMpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMucHVzaCh0aGlzLm1ha2VSZXF1ZXN0KHBlZXJOYW1lLCBoYW5kbGVyRGVzY3JpcCwgYXJncywge1xuICAgICAgICAgICAgICAgIGRvUmVhZHlDaGVjazogIXNraXBSZWFkeUNoZWNrcyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlcztcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBBYnN0cmFjdCBtZXRob2RzIHN1YmNsYXNzZXMgTUFZIG92ZXJyaWRlXG5cbiAgICAvKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IHdhbnQgdG8gdXNlIHRoaXNcbiAgICAgKiBiYXNlIGNsYXNzJ3MgYGJyb2FkY2FzdFJlcXVlc3RgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5W3N0cmluZ119IGFuIEFycmF5IG9mIHRoZSBuYW1lcyBvZiBhbGwgY29ubmVjdGVkIHBlZXJzLlxuICAgICAqL1xuICAgIGdldEFsbFBlZXJOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qIFRoaXMgZ2l2ZXMgYSBjaGFuY2UgdG8gZXhhbWluZSBhbmQgbW9kaWZ5IGEgaGFuZGxlciBlcnJvciwgYW5kIHBvc3NpYmx5XG4gICAgICogaGF2ZSBzaWRlIGVmZmVjdHMsIGJlZm9yZSB0aGUgZXJyb3IgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVhc29uOiBFcnJvciB0aHJvd24gYnkgcmVxdWVzdCBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSB3cmFwcGVyOiB0aGUgd3JhcHBlciBtZXNzYWdlIHRoYXQgd2FzIGJlaW5nIGhhbmRsZWQuXG4gICAgICogQHJldHVybjogRXJyb3IgaW5zdGFuY2UuIE1heSBiZSB0aGUgc2FtZSBhcyB0aGUgZ2l2ZW4gcmVhc29uLCBvciBkaWZmZXJlbnQuXG4gICAgICovXG4gICAgY2hlY2tIYW5kbGluZ0Vycm9yKHJlYXNvbiwgd3JhcHBlcikge1xuICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFic3RyYWN0IG1ldGhvZHMgc3ViY2xhc3NlcyBNVVNUIG92ZXJyaWRlXG5cbiAgICAvKiBUaGlzIGlzIHdoZXJlIHN1YmNsYXNzZXMgbXVzdCB1c2UgdGhlaXIgdHJhbnNwb3J0LXNwZWNpZmljIG1ldGhvZCBvZiBnZXR0aW5nXG4gICAgICogYSBzZXJpYWxpemFibGUgbWVzc2FnZSBmcm9tIG9uZSBwZWVyIHRvIGFub3RoZXIuXG4gICAgICpcbiAgICAgKiBTcGVjaWZpY2FsbHksIHRoZSBtZXNzYWdlIHRvIGJlIGNvbW11bmljYXRlZCBoZXJlIGlzIG9uZSBvZiB0aGUgXCJ3cmFwcGVyXCJcbiAgICAgKiBtZXNzYWdlcyB3ZSB1c2UgdG8gcmVwcmVzZW50IHJlcXVlc3RzIGFuZCByZXNwb25zZXMuIFRoZSBpbnRlbnRpb24gdGhlcmVmb3JlXG4gICAgICogaXMgdGhhdCBpdCBiZSBkZWxpdmVyZWQgdG8gdGhlIGBoYW5kbGVNZXNzYWdlYCBtZXRob2Qgb2YgdGhlIHBlZXIgKHdoaWNoIHNob3VsZFxuICAgICAqIF9ub3RfIGJlIG92ZXJyaWRkZW4sIGJ1dCBzaG91bGQgYmUgaW5oZXJpdGVkIGZyb20gdGhpcyBiYXNlIGNsYXNzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwZWVyTmFtZSB7c3RyaW5nfSB0aGUgbmFtZSBvZiBhIGNvbm5lY3RlZCBwZWVyXG4gICAgICogQHBhcmFtIHdyYXBwZXIge29ian0gdGhlIHdyYXBwZXIgbWVzc2FnZSB0byBiZSBwb3N0ZWQgdG8gdGhhdCBwZWVyLiBGb3JtYXQ6IHtcbiAgICAgKiAgIHR5cGUge3N0cmluZ30gZXF1YWwgdG8gZWl0aGVyICdyZXF1ZXN0JyBvciAncmVzcG9uc2UnLCBhcHByb3ByaWF0ZWx5LlxuICAgICAqIH1cbiAgICAgKi9cbiAgICBwb3N0TWVzc2FnZUFzUGVlcihwZWVyTmFtZSwgd3JhcHBlcikge1xuICAgICAgICAvL1xuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/browser-peers/src/peer.js\n");

/***/ }),

/***/ "./node_modules/browser-peers/src/util.js":
/*!************************************************!*\
  !*** ./node_modules/browser-peers/src/util.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"xhr\": () => (/* binding */ xhr),\n/* harmony export */   \"enrichXhrParams\": () => (/* binding */ enrichXhrParams),\n/* harmony export */   \"Listenable\": () => (/* binding */ Listenable)\n/* harmony export */ });\n/*! browser-peers v0.1.0 | Copyright (c) 2020-2022 Steve Kieffer | MIT license */\n/* SPDX-License-Identifier: MIT */\n\n/* Simple XMLHttpRequest utility\n *\n * param url: the url to be accessed\n * optional params object:\n *      method: \"GET\", \"POST\" etc. Defaults to \"GET\"\n *      query: pass an object defining key-value pairs that you want added\n *          as a query string on the end of the URL\n *      form: pass an object defining key-value pairs that you want to be\n *          sent in form-encoded format in the body of the request\n *      handleAs: 'text', 'json', or 'blob'. Defaults to 'text'\n *\n * return: promise that resolves with the response from the request\n */\nfunction xhr(url, params) {\n    if (params.query) {\n        url += \"?\"+(new URLSearchParams(params.query)).toString();\n    }\n    const init = {\n        method: params.method || \"GET\"\n    };\n    if (params.form) {\n        init.body = new URLSearchParams(params.form);\n    }\n    const handleAs = params.handleAs || 'text';\n    return fetch(url, init).then(resp => {\n        if (!resp.ok) {\n            throw new Error(`HTTP error! status: ${resp.status}`);\n        }\n        if (handleAs === 'json') {\n            return resp.json();\n        } else if (handleAs === 'blob') {\n            return resp.blob();\n        } else {\n            return resp.text();\n        }\n    });\n}\n\n/* Add extra key-value arguments to an XHR.\n *\n * @param givenParams: a `params` arg which would have been passed to the\n *   `xhr` function defined in this module.\n * @param extraPairs: an object defining extra key-value args that you want to\n *   add to the request.\n * @return: a _new_ params object. The given one is not modified.\n *   The extra pairs are placed in `params.query` if `query` was defined in the\n *   givenParams, else in `params.form` if that was defined. If neither was defined,\n *   then we define `params.query` and put the extra pairs in there.\n */\nfunction enrichXhrParams(givenParams, extraPairs) {\n    const params = {};\n    Object.assign(params, givenParams || {});\n    if (params.query) {\n        Object.assign(params.query, extraPairs);\n    } else if (params.form) {\n        Object.assign(params.form, extraPairs);\n    } else {\n        params.query = {};\n        Object.assign(params.query, extraPairs);\n    }\n    return params;\n}\n\nclass Listenable {\n\n    constructor(listeners) {\n        this.listeners = listeners;\n    }\n\n    on(eventType, callback) {\n        const cbs = this.listeners[eventType] || [];\n        cbs.push(callback);\n        this.listeners[eventType] = cbs;\n    }\n\n    off(eventType, callback) {\n        const cbs = this.listeners[eventType] || [];\n        const i0 = cbs.indexOf(callback);\n        if (i0 >= 0) {\n            cbs.splice(i0, 1);\n            this.listeners[eventType] = cbs;\n        }\n    }\n\n    dispatch(event) {\n        /* Subtle point: In general, we are always careful not to modify an\n         * iterable while we are in the process of iterating over it. Here, we don't\n         * know whether a callback might `off` itself as a part of its process,\n         * thereby modifying our array of listeners while we are iterating over it!\n         * Therefore, to be safe, we have to iterate over a _copy_ of our array of\n         * registered listeners. */\n        const cbs = (this.listeners[event.type] || []).slice();\n        for (let cb of cbs) {\n            cb(event);\n        }\n    }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvdXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGZzYy1pc2UvLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvdXRpbC5qcz8xYWI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBicm93c2VyLXBlZXJzIHYwLjEuMCB8IENvcHlyaWdodCAoYykgMjAyMC0yMDIyIFN0ZXZlIEtpZWZmZXIgfCBNSVQgbGljZW5zZSAqL1xuLyogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVCAqL1xuXG4vKiBTaW1wbGUgWE1MSHR0cFJlcXVlc3QgdXRpbGl0eVxuICpcbiAqIHBhcmFtIHVybDogdGhlIHVybCB0byBiZSBhY2Nlc3NlZFxuICogb3B0aW9uYWwgcGFyYW1zIG9iamVjdDpcbiAqICAgICAgbWV0aG9kOiBcIkdFVFwiLCBcIlBPU1RcIiBldGMuIERlZmF1bHRzIHRvIFwiR0VUXCJcbiAqICAgICAgcXVlcnk6IHBhc3MgYW4gb2JqZWN0IGRlZmluaW5nIGtleS12YWx1ZSBwYWlycyB0aGF0IHlvdSB3YW50IGFkZGVkXG4gKiAgICAgICAgICBhcyBhIHF1ZXJ5IHN0cmluZyBvbiB0aGUgZW5kIG9mIHRoZSBVUkxcbiAqICAgICAgZm9ybTogcGFzcyBhbiBvYmplY3QgZGVmaW5pbmcga2V5LXZhbHVlIHBhaXJzIHRoYXQgeW91IHdhbnQgdG8gYmVcbiAqICAgICAgICAgIHNlbnQgaW4gZm9ybS1lbmNvZGVkIGZvcm1hdCBpbiB0aGUgYm9keSBvZiB0aGUgcmVxdWVzdFxuICogICAgICBoYW5kbGVBczogJ3RleHQnLCAnanNvbicsIG9yICdibG9iJy4gRGVmYXVsdHMgdG8gJ3RleHQnXG4gKlxuICogcmV0dXJuOiBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgcmVxdWVzdFxuICovXG5leHBvcnQgZnVuY3Rpb24geGhyKHVybCwgcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5xdWVyeSkge1xuICAgICAgICB1cmwgKz0gXCI/XCIrKG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zLnF1ZXJ5KSkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdCA9IHtcbiAgICAgICAgbWV0aG9kOiBwYXJhbXMubWV0aG9kIHx8IFwiR0VUXCJcbiAgICB9O1xuICAgIGlmIChwYXJhbXMuZm9ybSkge1xuICAgICAgICBpbml0LmJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcy5mb3JtKTtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlQXMgPSBwYXJhbXMuaGFuZGxlQXMgfHwgJ3RleHQnO1xuICAgIHJldHVybiBmZXRjaCh1cmwsIGluaXQpLnRoZW4ocmVzcCA9PiB7XG4gICAgICAgIGlmICghcmVzcC5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcC5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZUFzID09PSAnanNvbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwLmpzb24oKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVBcyA9PT0gJ2Jsb2InKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcC5ibG9iKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcC50ZXh0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyogQWRkIGV4dHJhIGtleS12YWx1ZSBhcmd1bWVudHMgdG8gYW4gWEhSLlxuICpcbiAqIEBwYXJhbSBnaXZlblBhcmFtczogYSBgcGFyYW1zYCBhcmcgd2hpY2ggd291bGQgaGF2ZSBiZWVuIHBhc3NlZCB0byB0aGVcbiAqICAgYHhocmAgZnVuY3Rpb24gZGVmaW5lZCBpbiB0aGlzIG1vZHVsZS5cbiAqIEBwYXJhbSBleHRyYVBhaXJzOiBhbiBvYmplY3QgZGVmaW5pbmcgZXh0cmEga2V5LXZhbHVlIGFyZ3MgdGhhdCB5b3Ugd2FudCB0b1xuICogICBhZGQgdG8gdGhlIHJlcXVlc3QuXG4gKiBAcmV0dXJuOiBhIF9uZXdfIHBhcmFtcyBvYmplY3QuIFRoZSBnaXZlbiBvbmUgaXMgbm90IG1vZGlmaWVkLlxuICogICBUaGUgZXh0cmEgcGFpcnMgYXJlIHBsYWNlZCBpbiBgcGFyYW1zLnF1ZXJ5YCBpZiBgcXVlcnlgIHdhcyBkZWZpbmVkIGluIHRoZVxuICogICBnaXZlblBhcmFtcywgZWxzZSBpbiBgcGFyYW1zLmZvcm1gIGlmIHRoYXQgd2FzIGRlZmluZWQuIElmIG5laXRoZXIgd2FzIGRlZmluZWQsXG4gKiAgIHRoZW4gd2UgZGVmaW5lIGBwYXJhbXMucXVlcnlgIGFuZCBwdXQgdGhlIGV4dHJhIHBhaXJzIGluIHRoZXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5yaWNoWGhyUGFyYW1zKGdpdmVuUGFyYW1zLCBleHRyYVBhaXJzKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGdpdmVuUGFyYW1zIHx8IHt9KTtcbiAgICBpZiAocGFyYW1zLnF1ZXJ5KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLnF1ZXJ5LCBleHRyYVBhaXJzKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5mb3JtKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLmZvcm0sIGV4dHJhUGFpcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5xdWVyeSA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHBhcmFtcy5xdWVyeSwgZXh0cmFQYWlycyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG5cbmV4cG9ydCBjbGFzcyBMaXN0ZW5hYmxlIHtcblxuICAgIGNvbnN0cnVjdG9yKGxpc3RlbmVycykge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB9XG5cbiAgICBvbihldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNicyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV0gfHwgW107XG4gICAgICAgIGNicy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGNicztcbiAgICB9XG5cbiAgICBvZmYoZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudFR5cGVdIHx8IFtdO1xuICAgICAgICBjb25zdCBpMCA9IGNicy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGkwID49IDApIHtcbiAgICAgICAgICAgIGNicy5zcGxpY2UoaTAsIDEpO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGNicztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc3BhdGNoKGV2ZW50KSB7XG4gICAgICAgIC8qIFN1YnRsZSBwb2ludDogSW4gZ2VuZXJhbCwgd2UgYXJlIGFsd2F5cyBjYXJlZnVsIG5vdCB0byBtb2RpZnkgYW5cbiAgICAgICAgICogaXRlcmFibGUgd2hpbGUgd2UgYXJlIGluIHRoZSBwcm9jZXNzIG9mIGl0ZXJhdGluZyBvdmVyIGl0LiBIZXJlLCB3ZSBkb24ndFxuICAgICAgICAgKiBrbm93IHdoZXRoZXIgYSBjYWxsYmFjayBtaWdodCBgb2ZmYCBpdHNlbGYgYXMgYSBwYXJ0IG9mIGl0cyBwcm9jZXNzLFxuICAgICAgICAgKiB0aGVyZWJ5IG1vZGlmeWluZyBvdXIgYXJyYXkgb2YgbGlzdGVuZXJzIHdoaWxlIHdlIGFyZSBpdGVyYXRpbmcgb3ZlciBpdCFcbiAgICAgICAgICogVGhlcmVmb3JlLCB0byBiZSBzYWZlLCB3ZSBoYXZlIHRvIGl0ZXJhdGUgb3ZlciBhIF9jb3B5XyBvZiBvdXIgYXJyYXkgb2ZcbiAgICAgICAgICogcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuICovXG4gICAgICAgIGNvbnN0IGNicyA9ICh0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgZm9yIChsZXQgY2Igb2YgY2JzKSB7XG4gICAgICAgICAgICBjYihldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/browser-peers/src/util.js\n");

/***/ }),

/***/ "./src/mathworker.js":
/*!***************************!*\
  !*** ./src/mathworker.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var browser_peers_src_dedworkerpeer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! browser-peers/src/dedworkerpeer */ \"./node_modules/browser-peers/src/dedworkerpeer.js\");\n/* ------------------------------------------------------------------------- *\n *  Proofscape Integrated Study Environment (PISE)                           *\n *                                                                           *\n *  Copyright (c) 2018-2022 Proofscape contributors                          *\n *                                                                           *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");          *\n *  you may not use this file except in compliance with the License.         *\n *  You may obtain a copy of the License at                                  *\n *                                                                           *\n *      http://www.apache.org/licenses/LICENSE-2.0                           *\n *                                                                           *\n *  Unless required by applicable law or agreed to in writing, software      *\n *  distributed under the License is distributed on an \"AS IS\" BASIS,        *\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n *  See the License for the specific language governing permissions and      *\n *  limitations under the License.                                           *\n * ------------------------------------------------------------------------- */\n\n\n\n\n\nconst pyodidePackages = [\n    \"micropip\",\n    \"Jinja2\",\n    \"mpmath\",\n];\n\n\nconst pyodideImports = [\n    'import pfsc_examp',\n];\n\n\nfunction echo(args, meta) {\n    console.log('echo', args, meta);\n    return 'echoed';\n}\n\n\nfunction ping(args) {\n    return 'pong';\n}\n\n\nfunction startup(args) {\n    self.pfscExampConfig = args.pfscExampConfig;\n    let indexURL = args.pyodideIndexURL;\n    if (!indexURL.endsWith('/')) {\n        indexURL += '/';\n    }\n    const pyodideJsURL = indexURL + 'pyodide.js';\n    importScripts(pyodideJsURL);\n\n    let code = 'import micropip\\n';\n\n    const noDeps = args.micropipNoDeps ? ', deps=False' : '';\n    code += `await micropip.install(${JSON.stringify(args.micropipInstallTargets)}${noDeps})\\n`;\n\n    for (let imp of pyodideImports) {\n        code += `${imp}\\n`;\n    }\n\n    console.debug(code);\n\n    self.pyoReady = new Promise(resolve => {\n        loadPyodide({indexURL: indexURL}).then(pyodide => {\n            self.pyodide = pyodide;\n            pyodide.loadPackage(pyodidePackages).then(() => {\n                pyodide.runPythonAsync(code).then(() => {\n                    resolve({\n                        status: 0,\n                        message: 'loaded Pyodide and all packages',\n                    });\n                });\n            });\n        });\n    });\n    return self.pyoReady;\n}\n\n\n/* Make a new PyProxy for a widget.\n *\n * args: {\n *   info: the info object that defines the widget,\n *   paneId: the id of the pane where this representative is to be active.\n * }\n *\n * return: promise that resolves with new total number of proxies for this widget\n */\nasync function makePyProxy(args) {\n    await self.pyoReady;\n    const info = args.info;\n    const paneId = args.paneId;\n    const uid = info['uid'];\n    const w = self.pfscisehub.notesManager.ensureWidget(uid);\n    const makeObject = self.pyodide.globals.get('pfsc_examp').make_examp_generator_obj_from_js;\n    const obj = makeObject(info, paneId);\n    makeObject.destroy();  // destroy proxy of factory func to avoid memory leak\n    w.addPyProxy(paneId, obj);\n    return w.getNumProxies();\n}\n\n\n/* Destroy a single PyProxy for a widget. If this was the widget's\n * last proxy, also delete the widget from the NotesManager.\n *\n * args: {\n *   uid: the uid of the widget that wants to destroy a PyProxy\n *   paneId: the id of the pane whose proxy should be destroyed\n * }\n *\n * return: the new total number of proxies for this widget\n */\nfunction destroyPyProxy(args) {\n    const nm = self.pfscisehub.notesManager;\n    const uid = args.uid;\n    const paneId = args.paneId;\n    const w = nm.getWidget(uid);\n    if (w) {\n        w.destroyProxy(paneId);\n        const n = w.getNumProxies();\n        if (n === 0) {\n            nm.deleteWidget(uid);\n        }\n        return n;\n    } else {\n        return 0;\n    }\n}\n\n/* Rebuild an examp widget.\n *\n * args: {\n *   uid: the widget uid,\n *   paneId: the id of the pane where we want to rebuild\n *   value: optional, new raw value to pass to this widget's `build` method\n *   writeHtml: bool, optional, default false: if true, ask the widget to\n *     generate its (new) HTML\n * }\n *\n * return: promise that resolves with the response from the `rebuild_examp_generator_from_js()`\n *   function in the pfsc-examp python package. This is a formatted object, which contains\n *   an error level, error message, and result value if successful.\n */\nasync function rebuild(args) {\n    await self.pyoReady;\n    const {\n        uid,\n        paneId,\n        value = null,\n        writeHtml = false,\n    } = args;\n    const nm = self.pfscisehub.notesManager;\n    const w = nm.getWidget(uid);\n    const obj = w.getPyProxyCopy(paneId);\n    const rebuildFunc = self.pyodide.globals.get('pfsc_examp').rebuild_examp_generator_from_js;\n    const response = rebuildFunc.callKwargs(obj, {value: value, write_html: writeHtml});\n    // Destroy PyProxy of `rebuild` to avoid memory leak.\n    // `response` object does not need to be destroyed, since it was converted with `to_js()`\n    // on the python side.\n    rebuildFunc.destroy();\n    // `response` is a Map. Convert to an Object.\n    const respObj = Object.fromEntries(response);\n    return respObj;\n}\n\n\nclass NotesManager {\n\n    constructor() {\n        this.widgets = new Map();\n    }\n\n    getWidget(uid) {\n        return this.widgets.get(uid);\n    }\n\n    ensureWidget(uid) {\n        if (this.widgets.has(uid)) {\n            return this.widgets.get(uid);\n        } else {\n            const w = new Widget(uid);\n            this.widgets.set(uid, w);\n            return w;\n        }\n    }\n\n    deleteWidget(uid) {\n        this.widgets.delete(uid);\n    }\n\n}\n\n\nclass Widget {\n\n    constructor(uid) {\n        this.uid = uid;\n        this.pyProxiesByPaneId = new Map();\n    }\n\n    addPyProxy(paneId, proxy) {\n        this.pyProxiesByPaneId.set(paneId, proxy);\n    }\n\n    /* This method is intended for use by Python code running in Pyodide.\n     * The reason for returning a *copy* of the PyProxy object we have stored\n     * is that this prevents the PyProxy from being destroyed as a result of\n     * being passed back to the Py side.\n     * See:\n     *   https://pyodide.org/en/stable/usage/type-conversions.html#calling-javascript-functions-from-python\n     */\n    getPyProxyCopy(paneId) {\n        const proxy = this.pyProxiesByPaneId.get(paneId);\n        return proxy.copy();\n    }\n\n    getNumProxies() {\n        return this.pyProxiesByPaneId.size;\n    }\n\n    destroyProxy(paneId) {\n        const p = this.pyProxiesByPaneId.get(paneId);\n        if (p) {\n            p.destroy();\n            this.pyProxiesByPaneId.delete(paneId);\n        }\n    }\n\n}\n\n\n/* We build a dummy environment so that the same code that was designed to\n * work with Pyodide running in the main page can also work here.\n */\nself.pfscisehub = {\n    notesManager: new NotesManager(),\n};\n\n\nconst peer = new browser_peers_src_dedworkerpeer__WEBPACK_IMPORTED_MODULE_0__.DedicatedWorkerPeer(self);\npeer.addHandler('echo', echo);\npeer.addHandler('ping', ping);\npeer.addHandler('startup', startup);\npeer.addHandler('makePyProxy', makePyProxy);\npeer.addHandler('destroyPyProxy', destroyPyProxy);\npeer.addHandler('rebuild', rebuild);\npeer.setReady();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWF0aHdvcmtlci5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGZzYy1pc2UvLi9zcmMvbWF0aHdvcmtlci5qcz84NTRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogIFByb29mc2NhcGUgSW50ZWdyYXRlZCBTdHVkeSBFbnZpcm9ubWVudCAoUElTRSkgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTgtMjAyMiBQcm9vZnNjYXBlIGNvbnRyaWJ1dG9ycyAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgICAgICAgICAgKlxuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gICAgICAgICAqXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlICAgICAgKlxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgICAgICAgICpcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gKlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgICAgICAqXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXG5pbXBvcnQgeyBEZWRpY2F0ZWRXb3JrZXJQZWVyIH0gZnJvbSBcImJyb3dzZXItcGVlcnMvc3JjL2RlZHdvcmtlcnBlZXJcIjtcblxuXG5jb25zdCBweW9kaWRlUGFja2FnZXMgPSBbXG4gICAgXCJtaWNyb3BpcFwiLFxuICAgIFwiSmluamEyXCIsXG4gICAgXCJtcG1hdGhcIixcbl07XG5cblxuY29uc3QgcHlvZGlkZUltcG9ydHMgPSBbXG4gICAgJ2ltcG9ydCBwZnNjX2V4YW1wJyxcbl07XG5cblxuZnVuY3Rpb24gZWNobyhhcmdzLCBtZXRhKSB7XG4gICAgY29uc29sZS5sb2coJ2VjaG8nLCBhcmdzLCBtZXRhKTtcbiAgICByZXR1cm4gJ2VjaG9lZCc7XG59XG5cblxuZnVuY3Rpb24gcGluZyhhcmdzKSB7XG4gICAgcmV0dXJuICdwb25nJztcbn1cblxuXG5mdW5jdGlvbiBzdGFydHVwKGFyZ3MpIHtcbiAgICBzZWxmLnBmc2NFeGFtcENvbmZpZyA9IGFyZ3MucGZzY0V4YW1wQ29uZmlnO1xuICAgIGxldCBpbmRleFVSTCA9IGFyZ3MucHlvZGlkZUluZGV4VVJMO1xuICAgIGlmICghaW5kZXhVUkwuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICBpbmRleFVSTCArPSAnLyc7XG4gICAgfVxuICAgIGNvbnN0IHB5b2RpZGVKc1VSTCA9IGluZGV4VVJMICsgJ3B5b2RpZGUuanMnO1xuICAgIGltcG9ydFNjcmlwdHMocHlvZGlkZUpzVVJMKTtcblxuICAgIGxldCBjb2RlID0gJ2ltcG9ydCBtaWNyb3BpcFxcbic7XG5cbiAgICBjb25zdCBub0RlcHMgPSBhcmdzLm1pY3JvcGlwTm9EZXBzID8gJywgZGVwcz1GYWxzZScgOiAnJztcbiAgICBjb2RlICs9IGBhd2FpdCBtaWNyb3BpcC5pbnN0YWxsKCR7SlNPTi5zdHJpbmdpZnkoYXJncy5taWNyb3BpcEluc3RhbGxUYXJnZXRzKX0ke25vRGVwc30pXFxuYDtcblxuICAgIGZvciAobGV0IGltcCBvZiBweW9kaWRlSW1wb3J0cykge1xuICAgICAgICBjb2RlICs9IGAke2ltcH1cXG5gO1xuICAgIH1cblxuICAgIGNvbnNvbGUuZGVidWcoY29kZSk7XG5cbiAgICBzZWxmLnB5b1JlYWR5ID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGxvYWRQeW9kaWRlKHtpbmRleFVSTDogaW5kZXhVUkx9KS50aGVuKHB5b2RpZGUgPT4ge1xuICAgICAgICAgICAgc2VsZi5weW9kaWRlID0gcHlvZGlkZTtcbiAgICAgICAgICAgIHB5b2RpZGUubG9hZFBhY2thZ2UocHlvZGlkZVBhY2thZ2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBweW9kaWRlLnJ1blB5dGhvbkFzeW5jKGNvZGUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdsb2FkZWQgUHlvZGlkZSBhbmQgYWxsIHBhY2thZ2VzJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGYucHlvUmVhZHk7XG59XG5cblxuLyogTWFrZSBhIG5ldyBQeVByb3h5IGZvciBhIHdpZGdldC5cbiAqXG4gKiBhcmdzOiB7XG4gKiAgIGluZm86IHRoZSBpbmZvIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIHdpZGdldCxcbiAqICAgcGFuZUlkOiB0aGUgaWQgb2YgdGhlIHBhbmUgd2hlcmUgdGhpcyByZXByZXNlbnRhdGl2ZSBpcyB0byBiZSBhY3RpdmUuXG4gKiB9XG4gKlxuICogcmV0dXJuOiBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBuZXcgdG90YWwgbnVtYmVyIG9mIHByb3hpZXMgZm9yIHRoaXMgd2lkZ2V0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1ha2VQeVByb3h5KGFyZ3MpIHtcbiAgICBhd2FpdCBzZWxmLnB5b1JlYWR5O1xuICAgIGNvbnN0IGluZm8gPSBhcmdzLmluZm87XG4gICAgY29uc3QgcGFuZUlkID0gYXJncy5wYW5lSWQ7XG4gICAgY29uc3QgdWlkID0gaW5mb1sndWlkJ107XG4gICAgY29uc3QgdyA9IHNlbGYucGZzY2lzZWh1Yi5ub3Rlc01hbmFnZXIuZW5zdXJlV2lkZ2V0KHVpZCk7XG4gICAgY29uc3QgbWFrZU9iamVjdCA9IHNlbGYucHlvZGlkZS5nbG9iYWxzLmdldCgncGZzY19leGFtcCcpLm1ha2VfZXhhbXBfZ2VuZXJhdG9yX29ial9mcm9tX2pzO1xuICAgIGNvbnN0IG9iaiA9IG1ha2VPYmplY3QoaW5mbywgcGFuZUlkKTtcbiAgICBtYWtlT2JqZWN0LmRlc3Ryb3koKTsgIC8vIGRlc3Ryb3kgcHJveHkgb2YgZmFjdG9yeSBmdW5jIHRvIGF2b2lkIG1lbW9yeSBsZWFrXG4gICAgdy5hZGRQeVByb3h5KHBhbmVJZCwgb2JqKTtcbiAgICByZXR1cm4gdy5nZXROdW1Qcm94aWVzKCk7XG59XG5cblxuLyogRGVzdHJveSBhIHNpbmdsZSBQeVByb3h5IGZvciBhIHdpZGdldC4gSWYgdGhpcyB3YXMgdGhlIHdpZGdldCdzXG4gKiBsYXN0IHByb3h5LCBhbHNvIGRlbGV0ZSB0aGUgd2lkZ2V0IGZyb20gdGhlIE5vdGVzTWFuYWdlci5cbiAqXG4gKiBhcmdzOiB7XG4gKiAgIHVpZDogdGhlIHVpZCBvZiB0aGUgd2lkZ2V0IHRoYXQgd2FudHMgdG8gZGVzdHJveSBhIFB5UHJveHlcbiAqICAgcGFuZUlkOiB0aGUgaWQgb2YgdGhlIHBhbmUgd2hvc2UgcHJveHkgc2hvdWxkIGJlIGRlc3Ryb3llZFxuICogfVxuICpcbiAqIHJldHVybjogdGhlIG5ldyB0b3RhbCBudW1iZXIgb2YgcHJveGllcyBmb3IgdGhpcyB3aWRnZXRcbiAqL1xuZnVuY3Rpb24gZGVzdHJveVB5UHJveHkoYXJncykge1xuICAgIGNvbnN0IG5tID0gc2VsZi5wZnNjaXNlaHViLm5vdGVzTWFuYWdlcjtcbiAgICBjb25zdCB1aWQgPSBhcmdzLnVpZDtcbiAgICBjb25zdCBwYW5lSWQgPSBhcmdzLnBhbmVJZDtcbiAgICBjb25zdCB3ID0gbm0uZ2V0V2lkZ2V0KHVpZCk7XG4gICAgaWYgKHcpIHtcbiAgICAgICAgdy5kZXN0cm95UHJveHkocGFuZUlkKTtcbiAgICAgICAgY29uc3QgbiA9IHcuZ2V0TnVtUHJveGllcygpO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgbm0uZGVsZXRlV2lkZ2V0KHVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuXG4vKiBSZWJ1aWxkIGFuIGV4YW1wIHdpZGdldC5cbiAqXG4gKiBhcmdzOiB7XG4gKiAgIHVpZDogdGhlIHdpZGdldCB1aWQsXG4gKiAgIHBhbmVJZDogdGhlIGlkIG9mIHRoZSBwYW5lIHdoZXJlIHdlIHdhbnQgdG8gcmVidWlsZFxuICogICB2YWx1ZTogb3B0aW9uYWwsIG5ldyByYXcgdmFsdWUgdG8gcGFzcyB0byB0aGlzIHdpZGdldCdzIGBidWlsZGAgbWV0aG9kXG4gKiAgIHdyaXRlSHRtbDogYm9vbCwgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2U6IGlmIHRydWUsIGFzayB0aGUgd2lkZ2V0IHRvXG4gKiAgICAgZ2VuZXJhdGUgaXRzIChuZXcpIEhUTUxcbiAqIH1cbiAqXG4gKiByZXR1cm46IHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBmcm9tIHRoZSBgcmVidWlsZF9leGFtcF9nZW5lcmF0b3JfZnJvbV9qcygpYFxuICogICBmdW5jdGlvbiBpbiB0aGUgcGZzYy1leGFtcCBweXRob24gcGFja2FnZS4gVGhpcyBpcyBhIGZvcm1hdHRlZCBvYmplY3QsIHdoaWNoIGNvbnRhaW5zXG4gKiAgIGFuIGVycm9yIGxldmVsLCBlcnJvciBtZXNzYWdlLCBhbmQgcmVzdWx0IHZhbHVlIGlmIHN1Y2Nlc3NmdWwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYnVpbGQoYXJncykge1xuICAgIGF3YWl0IHNlbGYucHlvUmVhZHk7XG4gICAgY29uc3Qge1xuICAgICAgICB1aWQsXG4gICAgICAgIHBhbmVJZCxcbiAgICAgICAgdmFsdWUgPSBudWxsLFxuICAgICAgICB3cml0ZUh0bWwgPSBmYWxzZSxcbiAgICB9ID0gYXJncztcbiAgICBjb25zdCBubSA9IHNlbGYucGZzY2lzZWh1Yi5ub3Rlc01hbmFnZXI7XG4gICAgY29uc3QgdyA9IG5tLmdldFdpZGdldCh1aWQpO1xuICAgIGNvbnN0IG9iaiA9IHcuZ2V0UHlQcm94eUNvcHkocGFuZUlkKTtcbiAgICBjb25zdCByZWJ1aWxkRnVuYyA9IHNlbGYucHlvZGlkZS5nbG9iYWxzLmdldCgncGZzY19leGFtcCcpLnJlYnVpbGRfZXhhbXBfZ2VuZXJhdG9yX2Zyb21fanM7XG4gICAgY29uc3QgcmVzcG9uc2UgPSByZWJ1aWxkRnVuYy5jYWxsS3dhcmdzKG9iaiwge3ZhbHVlOiB2YWx1ZSwgd3JpdGVfaHRtbDogd3JpdGVIdG1sfSk7XG4gICAgLy8gRGVzdHJveSBQeVByb3h5IG9mIGByZWJ1aWxkYCB0byBhdm9pZCBtZW1vcnkgbGVhay5cbiAgICAvLyBgcmVzcG9uc2VgIG9iamVjdCBkb2VzIG5vdCBuZWVkIHRvIGJlIGRlc3Ryb3llZCwgc2luY2UgaXQgd2FzIGNvbnZlcnRlZCB3aXRoIGB0b19qcygpYFxuICAgIC8vIG9uIHRoZSBweXRob24gc2lkZS5cbiAgICByZWJ1aWxkRnVuYy5kZXN0cm95KCk7XG4gICAgLy8gYHJlc3BvbnNlYCBpcyBhIE1hcC4gQ29udmVydCB0byBhbiBPYmplY3QuXG4gICAgY29uc3QgcmVzcE9iaiA9IE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BPYmo7XG59XG5cblxuY2xhc3MgTm90ZXNNYW5hZ2VyIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLndpZGdldHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgZ2V0V2lkZ2V0KHVpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXRzLmdldCh1aWQpO1xuICAgIH1cblxuICAgIGVuc3VyZVdpZGdldCh1aWQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkZ2V0cy5oYXModWlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0cy5nZXQodWlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBuZXcgV2lkZ2V0KHVpZCk7XG4gICAgICAgICAgICB0aGlzLndpZGdldHMuc2V0KHVpZCwgdyk7XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZVdpZGdldCh1aWQpIHtcbiAgICAgICAgdGhpcy53aWRnZXRzLmRlbGV0ZSh1aWQpO1xuICAgIH1cblxufVxuXG5cbmNsYXNzIFdpZGdldCB7XG5cbiAgICBjb25zdHJ1Y3Rvcih1aWQpIHtcbiAgICAgICAgdGhpcy51aWQgPSB1aWQ7XG4gICAgICAgIHRoaXMucHlQcm94aWVzQnlQYW5lSWQgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgYWRkUHlQcm94eShwYW5lSWQsIHByb3h5KSB7XG4gICAgICAgIHRoaXMucHlQcm94aWVzQnlQYW5lSWQuc2V0KHBhbmVJZCwgcHJveHkpO1xuICAgIH1cblxuICAgIC8qIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciB1c2UgYnkgUHl0aG9uIGNvZGUgcnVubmluZyBpbiBQeW9kaWRlLlxuICAgICAqIFRoZSByZWFzb24gZm9yIHJldHVybmluZyBhICpjb3B5KiBvZiB0aGUgUHlQcm94eSBvYmplY3Qgd2UgaGF2ZSBzdG9yZWRcbiAgICAgKiBpcyB0aGF0IHRoaXMgcHJldmVudHMgdGhlIFB5UHJveHkgZnJvbSBiZWluZyBkZXN0cm95ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICAgKiBiZWluZyBwYXNzZWQgYmFjayB0byB0aGUgUHkgc2lkZS5cbiAgICAgKiBTZWU6XG4gICAgICogICBodHRwczovL3B5b2RpZGUub3JnL2VuL3N0YWJsZS91c2FnZS90eXBlLWNvbnZlcnNpb25zLmh0bWwjY2FsbGluZy1qYXZhc2NyaXB0LWZ1bmN0aW9ucy1mcm9tLXB5dGhvblxuICAgICAqL1xuICAgIGdldFB5UHJveHlDb3B5KHBhbmVJZCkge1xuICAgICAgICBjb25zdCBwcm94eSA9IHRoaXMucHlQcm94aWVzQnlQYW5lSWQuZ2V0KHBhbmVJZCk7XG4gICAgICAgIHJldHVybiBwcm94eS5jb3B5KCk7XG4gICAgfVxuXG4gICAgZ2V0TnVtUHJveGllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHlQcm94aWVzQnlQYW5lSWQuc2l6ZTtcbiAgICB9XG5cbiAgICBkZXN0cm95UHJveHkocGFuZUlkKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnB5UHJveGllc0J5UGFuZUlkLmdldChwYW5lSWQpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgcC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnB5UHJveGllc0J5UGFuZUlkLmRlbGV0ZShwYW5lSWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cblxuLyogV2UgYnVpbGQgYSBkdW1teSBlbnZpcm9ubWVudCBzbyB0aGF0IHRoZSBzYW1lIGNvZGUgdGhhdCB3YXMgZGVzaWduZWQgdG9cbiAqIHdvcmsgd2l0aCBQeW9kaWRlIHJ1bm5pbmcgaW4gdGhlIG1haW4gcGFnZSBjYW4gYWxzbyB3b3JrIGhlcmUuXG4gKi9cbnNlbGYucGZzY2lzZWh1YiA9IHtcbiAgICBub3Rlc01hbmFnZXI6IG5ldyBOb3Rlc01hbmFnZXIoKSxcbn07XG5cblxuY29uc3QgcGVlciA9IG5ldyBEZWRpY2F0ZWRXb3JrZXJQZWVyKHNlbGYpO1xucGVlci5hZGRIYW5kbGVyKCdlY2hvJywgZWNobyk7XG5wZWVyLmFkZEhhbmRsZXIoJ3BpbmcnLCBwaW5nKTtcbnBlZXIuYWRkSGFuZGxlcignc3RhcnR1cCcsIHN0YXJ0dXApO1xucGVlci5hZGRIYW5kbGVyKCdtYWtlUHlQcm94eScsIG1ha2VQeVByb3h5KTtcbnBlZXIuYWRkSGFuZGxlcignZGVzdHJveVB5UHJveHknLCBkZXN0cm95UHlQcm94eSk7XG5wZWVyLmFkZEhhbmRsZXIoJ3JlYnVpbGQnLCByZWJ1aWxkKTtcbnBlZXIuc2V0UmVhZHkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/mathworker.js\n");

/***/ }),

/***/ "../../../../../../private/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-99518WoBdoDEK43Ej/dojo/dojo.js":
/*!********************************************************************************************************************!*\
  !*** ../../../../../../private/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-99518WoBdoDEK43Ej/dojo/dojo.js ***!
  \********************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = function(userConfig, defaultConfig, global, window) { this.loaderVersion = \"1.16.4\"; (function(\n\tuserConfig,\n\tdefaultConfig\n){\n\t// summary:\n\t//\t\tThis is the \"source loader\" and is the entry point for Dojo during development. You may also load Dojo with\n\t//\t\tany AMD-compliant loader via the package main module dojo/main.\n\t// description:\n\t//\t\tThis is the \"source loader\" for Dojo. It provides an AMD-compliant loader that can be configured\n\t//\t\tto operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded\n\t//\t\tIAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package\n\t//\t\tvia the package main module dojo/main and this loader is not required; see dojo/package.json for details.\n\t//\n\t//\t\tIn order to keep compatibility with the v1.x line, this loader includes additional machinery that enables\n\t//\t\tthe dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed\n\t//\t\tvia the has.js API and statically removed via the build system.\n\t//\n\t//\t\tThis loader includes sniffing machinery to determine the environment; the following environments are supported:\n\t//\n\t//\t\t- browser\n\t//\t\t- node.js\n\t//\t\t- rhino\n\t//\n\t//\t\tThis is the so-called \"source loader\". As such, it includes many optional features that may be discarded by\n\t//\t\tbuilding a customized version with the build system.\n\n\t// Design and Implementation Notes\n\t//\n\t// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.\n\t//\n\t// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)\n\t// loader that can be configured to operate in either synchronous or asynchronous modes.\n\t//\n\t// Since this machinery implements a loader, it does not have the luxury of using a load system and/or\n\t// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:\n\t//\n\t//\t 1. Small library for use implementing the loader.\n\t//\t 2. Define the has.js API; this is used throughout the loader to bracket features.\n\t//\t 3. Define the node.js and rhino sniffs and sniff.\n\t//\t 4. Define the loader's data.\n\t//\t 5. Define the configuration machinery.\n\t//\t 6. Define the script element sniffing machinery and sniff for configuration data.\n\t//\t 7. Configure the loader IAW the provided user, default, and sniffing data.\n\t//\t 8. Define the global require function.\n\t//\t 9. Define the module resolution machinery.\n\t//\t10. Define the module and plugin module definition machinery\n\t//\t11. Define the script injection machinery.\n\t//\t12. Define the window load detection.\n\t//\t13. Define the logging API.\n\t//\t14. Define the tracing API.\n\t//\t16. Define the AMD define function.\n\t//\t17. Define the dojo v1.x provide/require machinery--so called \"legacy\" modes.\n\t//\t18. Publish global variables.\n\t//\n\t// Language and Acronyms and Idioms\n\t//\n\t// moduleId: a CJS module identifier, (used for public APIs)\n\t// mid: moduleId (used internally)\n\t// packageId: a package identifier (used for public APIs)\n\t// pid: packageId (used internally); the implied system or default package has pid===\"\"\n\t// pack: package is used internally to reference a package object (since javascript has reserved words including \"package\")\n\t// prid: plugin resource identifier\n\t// The integer constant 1 is used in place of true and 0 in place of false.\n\t//\n\t// The \"foreign-loader\" has condition is defined if another loader is being used (e.g. webpack) and this code is only\n\t// needed for resolving module identifiers based on the config.  In this case, only the functions require.toUrl and \n\t// require.toAbsMid are supported.  The require and define functions are not supported.\n\n\t// define global\n\tvar globalObject = (function(){\n\t\tif (typeof global !== 'undefined' && typeof global !== 'function') {\n\t\t\t// global spec defines a reference to the global object called 'global'\n\t\t\t// https://github.com/tc39/proposal-global\n\t\t\t// `global` is also defined in NodeJS\n\t\t\treturn global;\n\t\t}\n\t\telse if (typeof window !== 'undefined') {\n\t\t\t// window is defined in browsers\n\t\t\treturn window;\n\t\t}\n\t\telse if (typeof self !== 'undefined') {\n\t\t\t// self is defined in WebWorkers\n\t\t\treturn self;\n\t\t}\n\t\treturn this;\n\t})();\n\n\t// define a minimal library to help build the loader\n\tvar noop = function(){\n\t\t},\n\n\t\tisEmpty = function(it){\n\t\t\tfor(var p in it){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t},\n\n\t\ttoString = {}.toString,\n\n\t\tisFunction = function(it){\n\t\t\treturn toString.call(it) == \"[object Function]\";\n\t\t},\n\n\t\tisString = function(it){\n\t\t\treturn toString.call(it) == \"[object String]\";\n\t\t},\n\n\t\tisArray = function(it){\n\t\t\treturn toString.call(it) == \"[object Array]\";\n\t\t},\n\n\t\tforEach = function(vector, callback){\n\t\t\tif(vector){\n\t\t\t\tfor(var i = 0; i < vector.length;){\n\t\t\t\t\tcallback(vector[i++]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmix = function(dest, src){\n\t\t\tfor(var p in src){\n\t\t\t\tdest[p] = src[p];\n\t\t\t}\n\t\t\treturn dest;\n\t\t},\n\n\t\tmakeError = function(error, info){\n\t\t\treturn mix(new Error(error), {src:\"dojoLoader\", info:info});\n\t\t},\n\n\t\tuidSeed = 1,\n\n\t\tuid = function(){\n\t\t\t// Returns a unique identifier (within the lifetime of the document) of the form /_d+/.\n\t\t\treturn \"_\" + uidSeed++;\n\t\t},\n\n\t\t// FIXME: how to doc window.require() api\n\n\t\t// this will be the global require function; define it immediately so we can start hanging things off of it\n\t\treq = function(\n\t\t\tconfig,\t\t  //(object, optional) hash of configuration properties\n\t\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback\n\t\t\tcallback\t  //(function, optional) lambda expression to apply to module values implied by dependencies\n\t\t){\n\t\t\treturn contextRequire(config, dependencies, callback, 0, req);\n\t\t},\n\n\t\t// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout\n\t\tglobal = globalObject,\n\n\t\tdoc = global.document,\n\n\t\telement = doc && doc.createElement(\"DiV\"),\n\n\t\thas = req.has = function(name){\n\t\t\treturn isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];\n\t\t},\n\n\t\thasCache = has.cache = defaultConfig.hasCache;\n\n\tif (isFunction(userConfig)) {\n\t\tuserConfig = userConfig(globalObject);\n\t}\n\n\thas.add = function(name, test, now, force){\n\t\t(hasCache[name]===undefined || force) && (hasCache[name] = test);\n\t\treturn now && has(name);\n\t};\n\n\t 0 && 0;\n\tif( false ){}\n\n\t 0 && 0;\n\tif( false ){ var baseUrl, arg, rhinoArgs, i; }\n\n\t 0 && 0;\n\tif( false ){}\n\n\t// userConfig has tests override defaultConfig has tests; do this after the environment detection because\n\t// the environment detection usually sets some has feature values in the hasCache.\n\tfor(var p in userConfig.has){\n\t\thas.add(p, userConfig.has[p], 0, 1);\n\t}\n\n\t//\n\t// define the loader data\n\t//\n\n\t// the loader will use these like symbols if the loader has the traceApi; otherwise\n\t// define magic numbers so that modules can be provided as part of defaultConfig\n\tvar requested = 1,\n\t\tarrived = 2,\n\t\tnonmodule = 3,\n\t\texecuting = 4,\n\t\texecuted = 5;\n\n\tif( false ){}\n\n\tvar legacyMode = 0,\n\t\tsync = \"sync\",\n\t\txd = \"xd\",\n\t\tsyncExecStack = [],\n\t\tdojoRequirePlugin = 0,\n\t\tcheckDojoRequirePlugin = noop,\n\t\ttransformToAmd = noop,\n\t\tgetXhr;\n\tif( false ){ var XMLHTTP_PROGIDS, progid, i, locationProtocol, locationHost; }else{\n\t\treq.async = 1;\n\t}\n\n\t//\n\t// loader eval\n\t//\n\tvar eval_ =    true  ?\n\t\t// noop eval if there are csp restrictions\n\t\tfunction(){} :\n\t\t// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution\n\t\t0;\n\n\treq.eval =\n\t\tfunction(text, hint){\n\t\t\treturn eval_(text + \"\\r\\n//# sourceURL=\" + hint);\n\t\t};\n\n\t//\n\t// loader micro events API\n\t//\n\tvar listenerQueues = {},\n\t\terror = \"error\",\n\t\tsignal = req.signal = function(type, args){\n\t\t\tvar queue = listenerQueues[type];\n\t\t\t// notice we run a copy of the queue; this allows listeners to add/remove\n\t\t\t// other listeners without affecting this particular signal\n\t\t\tforEach(queue && queue.slice(0), function(listener){\n\t\t\t\tlistener.apply(null, isArray(args) ? args : [args]);\n\t\t\t});\n\t\t},\n\t\ton = req.on = function(type, listener){\n\t\t\t// notice a queue is not created until a client actually connects\n\t\t\tvar queue = listenerQueues[type] || (listenerQueues[type] = []);\n\t\t\tqueue.push(listener);\n\t\t\treturn {\n\t\t\t\tremove:function(){\n\t\t\t\t\tfor(var i = 0; i<queue.length; i++){\n\t\t\t\t\t\tif(queue[i]===listener){\n\t\t\t\t\t\t\tqueue.splice(i, 1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded\n\t// lexical variables hold key loader data structures to help with minification; these may be completely,\n\t// one-time initialized by defaultConfig for optimized/built versions\n\tvar\n\t\taliases\n\t\t\t// a vector of pairs of [regexs or string, replacement] => (alias, actual)\n\t\t\t= [],\n\n\t\tpaths\n\t\t\t// CommonJS paths\n\t\t\t= {},\n\n\t\tpathsMapProg\n\t\t\t// list of (from-path, to-path, regex, length) derived from paths;\n\t\t\t// a \"program\" to apply paths; see computeMapProg\n\t\t\t= [],\n\n\t\tpacks\n\t\t\t// a map from packageId to package configuration object; see fixupPackageInfo\n\t\t\t= {},\n\n\t\tmap = req.map\n\t\t\t// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map\n\t\t\t= {},\n\n\t\tmapProgs\n\t\t\t// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value\n\t\t\t= [],\n\n\t\tmodules\n\t\t\t// A hash:(mid) --> (module-object) the module namespace\n\t\t\t//\n\t\t\t// pid: the package identifier to which the module belongs (e.g., \"dojo\"); \"\" indicates the system or default package\n\t\t\t// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., \"dojo/io/script\")\n\t\t\t// url: the URL from which the module was retrieved\n\t\t\t// pack: the package object of the package to which the module belongs\n\t\t\t// executed: 0 => not executed; executing => in the process of traversing deps and running factory; executed => factory has been executed\n\t\t\t// deps: the dependency vector for this module (vector of modules objects)\n\t\t\t// def: the factory for this module\n\t\t\t// result: the result of the running the factory for this module\n\t\t\t// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define\n\t\t\t// load: plugin load function; applicable only for plugins\n\t\t\t//\n\t\t\t// Modules go through several phases in creation:\n\t\t\t//\n\t\t\t// 1. Requested: some other module's definition or a require application contained the requested module in\n\t\t\t//\t  its dependency vector or executing code explicitly demands a module via req.require.\n\t\t\t//\n\t\t\t// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL\n\t\t\t//\n\t\t\t// 3. Loaded: the resource injected in [2] has been evaluated.\n\t\t\t//\n\t\t\t// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some\n\t\t\t//\t  resources may just contain a bundle of code and never formally define a module via define\n\t\t\t//\n\t\t\t// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.\n\t\t\t= {},\n\n\t\tcacheBust\n\t\t\t// query string to append to module URLs to bust browser cache\n\t\t\t= \"\",\n\n\t\tcache\n\t\t\t// hash:(mid | url)-->(function | string)\n\t\t\t//\n\t\t\t// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --> function or\n\t\t\t// url --> string. The url key is distinguished from the mid key by always containing the prefix \"url:\". url keys as provided\n\t\t\t// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided\n\t\t\t// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.\n\t\t\t//\n\t\t\t// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given\n\t\t\t// by any mappings *iff* the config.cache was received as part of a module resource request.\n\t\t\t//\n\t\t\t// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules\n\t\t\t// to retrieve cached items that may have arrived consequent to another namespace.\n\t\t\t//\n\t\t\t = {},\n\n\t\turlKeyPrefix\n\t\t\t// the prefix to prepend to a URL key in the cache.\n\t\t\t= \"url:\",\n\n\t\tpendingCacheInsert\n\t\t\t// hash:(mid)-->(function)\n\t\t\t//\n\t\t\t// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are\n\t\t\t// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another\n\t\t\t// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending\n\t\t\t// cache for the local configuration, possibly relocating modules.\n\t\t\t = {},\n\n\t\tdojoSniffConfig\n\t\t\t// map of configuration variables\n\t\t\t// give the data-dojo-config as sniffed from the document (if any)\n\t\t\t= {},\n\n\t\tinsertPointSibling\n\t\t\t// the nodes used to locate where scripts are injected into the document\n\t\t\t= 0;\n\n\tif( true ){\n\t\tif (false ) { var consumePendingCacheInsert; }\n\t\tvar escapeString = function(s){\n\t\t\t\treturn s.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, function(c){ return \"\\\\\" + c; });\n\t\t\t},\n\n\t\t\tcomputeMapProg = function(map, dest){\n\t\t\t\t// This routine takes a map as represented by a JavaScript object and initializes dest, a vector of\n\t\t\t\t// quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-\n\t\t\t\t// of-map-key. The regex looks for the map-key followed by either \"/\" or end-of-string at the beginning\n\t\t\t\t// of a the search source. Notice the map-value is irrelevant to the algorithm\n\t\t\t\tdest.splice(0, dest.length);\n\t\t\t\tfor(var p in map){\n\t\t\t\t\tdest.push([\n\t\t\t\t\t\tp,\n\t\t\t\t\t\tmap[p],\n\t\t\t\t\t\tnew RegExp(\"^\" + escapeString(p) + \"(\\/|$)\"),\n\t\t\t\t\t\tp.length]);\n\t\t\t\t}\n\t\t\t\tdest.sort(function(lhs, rhs){ return rhs[3] - lhs[3]; });\n\t\t\t\treturn dest;\n\t\t\t},\n\n\t\t\tcomputeAliases = function(config, dest){\n\t\t\t\tforEach(config, function(pair){\n\t\t\t\t\t// take a fixed-up copy...\n\t\t\t\t\tdest.push([isString(pair[0]) ? new RegExp(\"^\" + escapeString(pair[0]) + \"$\") : pair[0], pair[1]]);\n\t\t\t\t});\n\t\t\t},\n\n\n\t\t\tfixupPackageInfo = function(packageInfo){\n\t\t\t\t// calculate the precise (name, location, main, mappings) for a package\n\t\t\t\tvar name = packageInfo.name;\n\t\t\t\tif(!name){\n\t\t\t\t\t// packageInfo must be a string that gives the name\n\t\t\t\t\tname = packageInfo;\n\t\t\t\t\tpackageInfo = {name:name};\n\t\t\t\t}\n\t\t\t\tpackageInfo = mix({main:\"main\"}, packageInfo);\n\t\t\t\tpackageInfo.location = packageInfo.location ? packageInfo.location : name;\n\n\t\t\t\t// packageMap is deprecated in favor of AMD map\n\t\t\t\tif(packageInfo.packageMap){\n\t\t\t\t\tmap[name] = packageInfo.packageMap;\n\t\t\t\t}\n\n\t\t\t\tif(!packageInfo.main.indexOf(\"./\")){\n\t\t\t\t\tpackageInfo.main = packageInfo.main.substring(2);\n\t\t\t\t}\n\n\t\t\t\t// now that we've got a fully-resolved package object, push it into the configuration\n\t\t\t\tpacks[name] = packageInfo;\n\t\t\t},\n\n\t\t\tdelayedModuleConfig\n\t\t\t\t// module config cannot be consumed until the loader is completely initialized; therefore, all\n\t\t\t\t// module config detected during booting is memorized and applied at the end of loader initialization\n\t\t\t\t// TODO: this is a bit of a kludge; all config should be moved to end of loader initialization, but\n\t\t\t\t// we'll delay this chore and do it with a final loader 1.x cleanup after the 2.x loader prototyping is complete\n\t\t\t\t= [],\n\n\n\t\t\tconfig = function(config, booting, referenceModule){\n\t\t\t\tfor(var p in config){\n\t\t\t\t\tif(p==\"waitSeconds\"){\n\t\t\t\t\t\treq.waitms = (config[p] || 0) * 1000;\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"cacheBust\"){\n\t\t\t\t\t\tcacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + \"\") : \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"baseUrl\" || p==\"combo\"){\n\t\t\t\t\t\treq[p] = config[p];\n\t\t\t\t\t}\n\t\t\t\t\tif( false){ var mode; }\n\t\t\t\t\tif(config[p]!==hasCache){\n\t\t\t\t\t\t// accumulate raw config info for client apps which can use this to pass their own config\n\t\t\t\t\t\treq.rawConfig[p] = config[p];\n\t\t\t\t\t\tp!=\"has\" && has.add(\"config-\"+p, config[p], 0, booting);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// make sure baseUrl exists\n\t\t\t\tif(!req.baseUrl){\n\t\t\t\t\treq.baseUrl = \"./\";\n\t\t\t\t}\n\t\t\t\t// make sure baseUrl ends with a slash\n\t\t\t\tif(!/\\/$/.test(req.baseUrl)){\n\t\t\t\t\treq.baseUrl += \"/\";\n\t\t\t\t}\n\n\t\t\t\t// now do the special work for has, packages, packagePaths, paths, aliases, and cache\n\n\t\t\t\tfor(p in config.has){\n\t\t\t\t\thas.add(p, config.has[p], 0, booting);\n\t\t\t\t}\n\n\t\t\t\t// for each package found in any packages config item, augment the packs map owned by the loader\n\t\t\t\tforEach(config.packages, fixupPackageInfo);\n\n\t\t\t\t// for each packagePath found in any packagePaths config item, augment the packageConfig\n\t\t\t\t// packagePaths is deprecated; remove in 2.0\n\t\t\t\tfor(var baseUrl in config.packagePaths){\n\t\t\t\t\tforEach(config.packagePaths[baseUrl], function(packageInfo){\n\t\t\t\t\t\tvar location = baseUrl + \"/\" + packageInfo;\n\t\t\t\t\t\tif(isString(packageInfo)){\n\t\t\t\t\t\t\tpackageInfo = {name:packageInfo};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpackageInfo.location = location;\n\t\t\t\t\t\tfixupPackageInfo(packageInfo);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// notice that computeMapProg treats the dest as a reference; therefore, if/when that variable\n\t\t\t\t// is published (see dojo-publish-privates), the published variable will always hold a valid value.\n\n\t\t\t\t// this must come after all package processing since package processing may mutate map\n\t\t\t\tcomputeMapProg(mix(map, config.map), mapProgs);\n\t\t\t\tforEach(mapProgs, function(item){\n\t\t\t\t\titem[1] = computeMapProg(item[1], []);\n\t\t\t\t\tif(item[0]==\"*\"){\n\t\t\t\t\t\tmapProgs.star = item;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// push in any paths and recompute the internal pathmap\n\t\t\t\tcomputeMapProg(mix(paths, config.paths), pathsMapProg);\n\n\t\t\t\t// aliases\n\t\t\t\tcomputeAliases(config.aliases, aliases);\n\n\t\t\t\tif (false ) { var module; }\n\t\t\t\tsignal(\"config\", [config, req.rawConfig]);\n\t\t\t};\n\n\t\t//\n\t\t// execute the various sniffs; userConfig can override and value\n\t\t//\n\n\t\tif( false ){ var scripts, i, script, dojoDir, src, match; }\n\n\t\tif( false ){ var doh; }\n\n\t\t// configure the loader; let the user override defaults\n\t\treq.rawConfig = {};\n\t\tconfig(defaultConfig, 1);\n\n\t\t// do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides\n\t\tif( false ){}\n\n\t\tconfig(userConfig, 1);\n\t\tconfig(dojoSniffConfig, 1);\n\n\t}else{}\n\n\n\tif (false ) { var injectDependencies, contextRequire, createRequire, execQ, defQ, waiting, setRequested, setArrived, execComplete, comboPending, combosPending, comboPendingTimer; }\n\n\tvar runMapProg = function(targetMid, map){\n\t\t\t// search for targetMid in map; return the map item if found; falsy otherwise\n\t\t\tif(map){\n\t\t\tfor(var i = 0; i < map.length; i++){\n\t\t\t\tif(map[i][2].test(targetMid)){\n\t\t\t\t\treturn map[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\tcompactPath = function(path){\n\t\t\tvar result = [],\n\t\t\t\tsegment, lastSegment;\n\t\t\tpath = path.replace(/\\\\/g, '/').split('/');\n\t\t\twhile(path.length){\n\t\t\t\tsegment = path.shift();\n\t\t\t\tif(segment==\"..\" && result.length && lastSegment!=\"..\"){\n\t\t\t\t\tresult.pop();\n\t\t\t\t\tlastSegment = result[result.length - 1];\n\t\t\t\t}else if(segment!=\".\"){\n\t\t\t\t\tresult.push(lastSegment= segment);\n\t\t\t\t} // else ignore \".\"\n\t\t\t}\n\t\t\treturn result.join(\"/\");\n\t\t},\n\n\t\tmakeModuleInfo = function(pid, mid, pack, url){\n\t\t\tif( false ){ var xd; }else{\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};\n\t\t\t}\n\t\t},\n\n\t\tgetModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate, fromPendingCache){\n\t\t\t// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)\n\t\t\t// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader\n\t\t\tvar pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;\n\t\t\trequestedMid = mid;\n\t\t\tisRelative = /^\\./.test(mid);\n\t\t\tif(/(^\\/)|(\\:)|(\\.js$)/.test(mid) || (isRelative && !referenceModule)){\n\t\t\t\t// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page\n\t\t\t\t// whatever it is, it's not a module but just a URL of some sort\n\t\t\t\t// note: pid===0 indicates the routine is returning an unmodified mid\n\n\t\t\t\treturn makeModuleInfo(0, mid, 0, mid);\n\t\t\t}else{\n\t\t\t\t// relative module ids are relative to the referenceModule; get rid of any dots\n\t\t\t\tmid = compactPath(isRelative ? (referenceModule.mid + \"/../\" + mid) : mid);\n\t\t\t\tif(/^\\./.test(mid)){\n\t\t\t\t\tthrow makeError(\"irrationalPath\", mid);\n\t\t\t\t}\n\t\t\t\t// at this point, mid is an absolute mid\n\n\t\t\t\t// map the mid\n\t\t\t\tif(!fromPendingCache && !isRelative && mapProgs.star){\n\t\t\t\t\tmapItem = runMapProg(mid, mapProgs.star[1]);\n\t\t\t\t}\n\t\t\t\tif(!mapItem && referenceModule){\n\t\t\t\t\tmapItem = runMapProg(referenceModule.mid, mapProgs);\n\t\t\t\t\tmapItem = mapItem && runMapProg(mid, mapItem[1]);\n\t\t\t\t}\n\n\t\t\t\tif(mapItem){\n\t\t\t\t\tmid = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t\t\t}\n\n\t\t\t\tmatch = mid.match(/^([^\\/]+)(\\/(.+))?$/);\n\t\t\t\tpid = match ? match[1] : \"\";\n\t\t\t\tif((pack = packs[pid])){\n\t\t\t\t\tmid = pid + \"/\" + (midInPackage = (match[3] || pack.main));\n\t\t\t\t}else{\n\t\t\t\t\tpid = \"\";\n\t\t\t\t}\n\n\t\t\t\t// search aliases\n\t\t\t\tvar candidateLength = 0,\n\t\t\t\t\tcandidate = 0;\n\t\t\t\tforEach(aliases, function(pair){\n\t\t\t\t\tvar match = mid.match(pair[0]);\n\t\t\t\t\tif(match && match.length>candidateLength){\n\t\t\t\t\t\tcandidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(candidate){\n\t\t\t\t\treturn getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);\n\t\t\t\t}\n\n\t\t\t\tresult = modules[mid];\n\t\t\t\tif(result){\n\t\t\t\t\treturn alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the\n\t\t\t// fully resolved (i.e., all relative indicators and package mapping resolved) module id\n\n\t\t\t// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid\n\t\t\tmapItem = runMapProg(mid, pathsMapProg);\n\t\t\tif(mapItem){\n\t\t\t\turl = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t}else if(pid){\n\t\t\t\turl = (pack.location.slice(-1) === '/' ? pack.location.slice(0, -1) : pack.location) + \"/\" + midInPackage;\n\t\t\t}else if( false ){}else{\n\t\t\t\turl = mid;\n\t\t\t}\n\t\t\t// if result is not absolute, add baseUrl\n\t\t\tif(!(/(^\\/)|(\\:)/.test(url))){\n\t\t\t\turl = baseUrl + url;\n\t\t\t}\n\t\t\turl += \".js\";\n\t\t\treturn makeModuleInfo(pid, mid, pack, compactPath(url));\n\t\t},\n\n\t\tgetModuleInfo = function(mid, referenceModule, fromPendingCache){\n\t\t\treturn getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, mapProgs, pathsMapProg, aliases, undefined, fromPendingCache);\n\t\t};\n\n\tif (false ) { var resolvePluginResourceId, dynamicPluginUidGenerator, getModule; }\n\n\tvar toAbsMid = req.toAbsMid = function(mid, referenceModule){\n\t\t\treturn getModuleInfo(mid, referenceModule).mid;\n\t\t},\n\n\t\ttoUrl = req.toUrl = function(name, referenceModule){\n\t\t\tvar moduleInfo = getModuleInfo(name+\"/x\", referenceModule),\n\t\t\t\turl= moduleInfo.url;\n\t\t\treturn fixupUrl(moduleInfo.pid===0 ?\n\t\t\t\t// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases\n\t\t\t\tname :\n\t\t\t\t// \"/x.js\" since getModuleInfo automatically appends \".js\" and we appended \"/x\" to make name look like a module id\n\t\t\t\turl.substring(0, url.length-5)\n\t\t\t);\n\t\t};\n\n\tif (false ) { var nonModuleProps, makeCjs, cjsRequireModule, cjsExportsModule, cjsModuleModule, runFactory, abortExec, defOrder, promoteModuleToPlugin, resolvePluginLoadQ, finishExec, circleTrace, execModule, checkCompleteGuard, guardCheckComplete, checkComplete; }\n\n\tvar fixupUrl= typeof userConfig.fixupUrl == \"function\" ? userConfig.fixupUrl : function(url){\n\t\t\turl += \"\"; // make sure url is a Javascript string (some paths may be a Java string)\n\t\t\treturn url + (cacheBust ? ((/\\?/.test(url) ? \"&\" : \"?\") + cacheBust) : \"\");\n\t\t};\n\n\n\n\tif( false ){}\n\n\tif( false ){ var injectPlugin, cached, injectingModule, injectingCachedModule, evalModuleText, injectModule, defineModule, runDefQ; }\n\n\tvar timerId = 0,\n\t\tclearTimer = noop,\n\t\tstartTimer = noop;\n\tif( false ){}\n\n\tif ( false ) {}\n\n\tif( false){ var scripts, i, script, domOn, windowOnLoadListener; }\n\n\tif( false ){}else{\n\t\treq.log = noop;\n\t}\n\n\tif( false ){ var trace; }else{\n\t\treq.trace = noop;\n\t}\n\tif (false ) { var def; } else {\n\t\tvar def = noop;\n\t}\n\t// allow config to override default implementation of named functions; this is useful for\n\t// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.\n\t// also useful for testing and monkey patching loader\n\tmix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);\n\n\t// now that req is fully initialized and won't change, we can hook it up to the error signal\n\ton(error, function(arg){\n\t\ttry{\n\t\t\tconsole.error(arg);\n\t\t\tif(arg instanceof Error){\n\t\t\t\tfor(var p in arg){\n\t\t\t\t\tconsole.log(p + \":\", arg[p]);\n\t\t\t\t}\n\t\t\t\tconsole.log(\".\");\n\t\t\t}\n\t\t}catch(e){}\n\t});\n\n\t// always publish these\n\tmix(req, {\n\t\tuid:uid,\n\t\tcache:cache,\n\t\tpacks:packs\n\t});\n\n\n\tif( false ){}\n\n\t// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are\n\t// *required* to define (as opposed to require, which is optional)\n\tif(global.define){\n\t\tif( false ){}\n\t\treturn;\n\t}else{\n\t\tglobal.define = def;\n\t\tglobal.require = req;\n\t\tif( false ){}\n\t}\n\n\tif( false){ var plugins, pluginName; }\n\n\tif( false ){ var bootDeps, bootCallback; }\n\tif(false ){}\n})\n.call(this, userConfig, defaultConfig);};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vLi4vLi4vcHJpdmF0ZS92YXIvZm9sZGVycy83Mi93NjN3YjZwNTMwemRycTQ1NWM1enhrcG0wMDAwZ24vVC90bXAtOTk1MThXb0Jkb0RFSzQzRWovZG9qby9kb2pvLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFNQTtBQUNBO0FBR0E7QUFZQTtBQUNBO0FBQ0E7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQWdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQTBTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaUJBO0FBQ0E7QUFVQTtBQUNBO0FBdUVBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQXlDQTtBQUNBO0FBQ0E7QUEwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFNQTtBQUlBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZnNjLWlzZS8uLi8uLi8uLi8uLi8uLi8uLi9wcml2YXRlL3Zhci9mb2xkZXJzLzcyL3c2M3diNnA1MzB6ZHJxNDU1YzV6eGtwbTAwMDBnbi9UL3RtcC05OTUxOFdvQmRvREVLNDNFai9kb2pvL2Rvam8uanM/YjA1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZXJDb25maWcsIGRlZmF1bHRDb25maWcsIGdsb2JhbCwgd2luZG93KSB7IHRoaXMubG9hZGVyVmVyc2lvbiA9IFwiMS4xNi40XCI7IChmdW5jdGlvbihcblx0dXNlckNvbmZpZyxcblx0ZGVmYXVsdENvbmZpZ1xuKXtcblx0Ly8gc3VtbWFyeTpcblx0Ly9cdFx0VGhpcyBpcyB0aGUgXCJzb3VyY2UgbG9hZGVyXCIgYW5kIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgRG9qbyBkdXJpbmcgZGV2ZWxvcG1lbnQuIFlvdSBtYXkgYWxzbyBsb2FkIERvam8gd2l0aFxuXHQvL1x0XHRhbnkgQU1ELWNvbXBsaWFudCBsb2FkZXIgdmlhIHRoZSBwYWNrYWdlIG1haW4gbW9kdWxlIGRvam8vbWFpbi5cblx0Ly8gZGVzY3JpcHRpb246XG5cdC8vXHRcdFRoaXMgaXMgdGhlIFwic291cmNlIGxvYWRlclwiIGZvciBEb2pvLiBJdCBwcm92aWRlcyBhbiBBTUQtY29tcGxpYW50IGxvYWRlciB0aGF0IGNhbiBiZSBjb25maWd1cmVkXG5cdC8vXHRcdHRvIG9wZXJhdGUgaW4gZWl0aGVyIHN5bmNocm9ub3VzIG9yIGFzeW5jaHJvbm91cyBtb2Rlcy4gQWZ0ZXIgdGhlIGxvYWRlciBpcyBkZWZpbmVkLCBkb2pvIGlzIGxvYWRlZFxuXHQvL1x0XHRJQVcgdGhlIHBhY2thZ2UgbWFpbiBtb2R1bGUgZG9qby9tYWluLiBJbiB0aGUgZXZlbnQgeW91IHdpc2ggdG8gdXNlIGEgZm9yZWlnbiBsb2FkZXIsIHlvdSBtYXkgbG9hZCBkb2pvIGFzIGEgcGFja2FnZVxuXHQvL1x0XHR2aWEgdGhlIHBhY2thZ2UgbWFpbiBtb2R1bGUgZG9qby9tYWluIGFuZCB0aGlzIGxvYWRlciBpcyBub3QgcmVxdWlyZWQ7IHNlZSBkb2pvL3BhY2thZ2UuanNvbiBmb3IgZGV0YWlscy5cblx0Ly9cblx0Ly9cdFx0SW4gb3JkZXIgdG8ga2VlcCBjb21wYXRpYmlsaXR5IHdpdGggdGhlIHYxLnggbGluZSwgdGhpcyBsb2FkZXIgaW5jbHVkZXMgYWRkaXRpb25hbCBtYWNoaW5lcnkgdGhhdCBlbmFibGVzXG5cdC8vXHRcdHRoZSBkb2pvLnByb3ZpZGUsIGRvam8ucmVxdWlyZSBldCBhbCBBUEkuIFRoaXMgbWFjaGluZXJ5IGlzIGxvYWRlZCBieSBkZWZhdWx0LCBidXQgbWF5IGJlIGR5bmFtaWNhbGx5IHJlbW92ZWRcblx0Ly9cdFx0dmlhIHRoZSBoYXMuanMgQVBJIGFuZCBzdGF0aWNhbGx5IHJlbW92ZWQgdmlhIHRoZSBidWlsZCBzeXN0ZW0uXG5cdC8vXG5cdC8vXHRcdFRoaXMgbG9hZGVyIGluY2x1ZGVzIHNuaWZmaW5nIG1hY2hpbmVyeSB0byBkZXRlcm1pbmUgdGhlIGVudmlyb25tZW50OyB0aGUgZm9sbG93aW5nIGVudmlyb25tZW50cyBhcmUgc3VwcG9ydGVkOlxuXHQvL1xuXHQvL1x0XHQtIGJyb3dzZXJcblx0Ly9cdFx0LSBub2RlLmpzXG5cdC8vXHRcdC0gcmhpbm9cblx0Ly9cblx0Ly9cdFx0VGhpcyBpcyB0aGUgc28tY2FsbGVkIFwic291cmNlIGxvYWRlclwiLiBBcyBzdWNoLCBpdCBpbmNsdWRlcyBtYW55IG9wdGlvbmFsIGZlYXR1cmVzIHRoYXQgbWF5IGJlIGRpc2NhcmRlZCBieVxuXHQvL1x0XHRidWlsZGluZyBhIGN1c3RvbWl6ZWQgdmVyc2lvbiB3aXRoIHRoZSBidWlsZCBzeXN0ZW0uXG5cblx0Ly8gRGVzaWduIGFuZCBJbXBsZW1lbnRhdGlvbiBOb3Rlc1xuXHQvL1xuXHQvLyBUaGlzIGlzIGEgZG9qby1zcGVjaWZpYyBhZGFwdGlvbiBvZiBiZExvYWQsIGRvbmF0ZWQgdG8gdGhlIGRvam8gZm91bmRhdGlvbiBieSBBbHRvdmlzbyBMTEMuXG5cdC8vXG5cdC8vIFRoaXMgZnVuY3Rpb24gZGVmaW5lcyBhbiBBTUQtY29tcGxpYW50IChodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Nb2R1bGVzL0FzeW5jaHJvbm91c0RlZmluaXRpb24pXG5cdC8vIGxvYWRlciB0aGF0IGNhbiBiZSBjb25maWd1cmVkIHRvIG9wZXJhdGUgaW4gZWl0aGVyIHN5bmNocm9ub3VzIG9yIGFzeW5jaHJvbm91cyBtb2Rlcy5cblx0Ly9cblx0Ly8gU2luY2UgdGhpcyBtYWNoaW5lcnkgaW1wbGVtZW50cyBhIGxvYWRlciwgaXQgZG9lcyBub3QgaGF2ZSB0aGUgbHV4dXJ5IG9mIHVzaW5nIGEgbG9hZCBzeXN0ZW0gYW5kL29yXG5cdC8vIGxldmVyYWdpbmcgYSB1dGlsaXR5IGxpYnJhcnkuIFRoaXMgcmVzdWx0cyBpbiBhbiB1bnBsZWFzYW50bHkgbG9uZyBmaWxlOyBoZXJlIGlzIGEgcm9hZCBtYXAgb2YgdGhlIGNvbnRlbnRzOlxuXHQvL1xuXHQvL1x0IDEuIFNtYWxsIGxpYnJhcnkgZm9yIHVzZSBpbXBsZW1lbnRpbmcgdGhlIGxvYWRlci5cblx0Ly9cdCAyLiBEZWZpbmUgdGhlIGhhcy5qcyBBUEk7IHRoaXMgaXMgdXNlZCB0aHJvdWdob3V0IHRoZSBsb2FkZXIgdG8gYnJhY2tldCBmZWF0dXJlcy5cblx0Ly9cdCAzLiBEZWZpbmUgdGhlIG5vZGUuanMgYW5kIHJoaW5vIHNuaWZmcyBhbmQgc25pZmYuXG5cdC8vXHQgNC4gRGVmaW5lIHRoZSBsb2FkZXIncyBkYXRhLlxuXHQvL1x0IDUuIERlZmluZSB0aGUgY29uZmlndXJhdGlvbiBtYWNoaW5lcnkuXG5cdC8vXHQgNi4gRGVmaW5lIHRoZSBzY3JpcHQgZWxlbWVudCBzbmlmZmluZyBtYWNoaW5lcnkgYW5kIHNuaWZmIGZvciBjb25maWd1cmF0aW9uIGRhdGEuXG5cdC8vXHQgNy4gQ29uZmlndXJlIHRoZSBsb2FkZXIgSUFXIHRoZSBwcm92aWRlZCB1c2VyLCBkZWZhdWx0LCBhbmQgc25pZmZpbmcgZGF0YS5cblx0Ly9cdCA4LiBEZWZpbmUgdGhlIGdsb2JhbCByZXF1aXJlIGZ1bmN0aW9uLlxuXHQvL1x0IDkuIERlZmluZSB0aGUgbW9kdWxlIHJlc29sdXRpb24gbWFjaGluZXJ5LlxuXHQvL1x0MTAuIERlZmluZSB0aGUgbW9kdWxlIGFuZCBwbHVnaW4gbW9kdWxlIGRlZmluaXRpb24gbWFjaGluZXJ5XG5cdC8vXHQxMS4gRGVmaW5lIHRoZSBzY3JpcHQgaW5qZWN0aW9uIG1hY2hpbmVyeS5cblx0Ly9cdDEyLiBEZWZpbmUgdGhlIHdpbmRvdyBsb2FkIGRldGVjdGlvbi5cblx0Ly9cdDEzLiBEZWZpbmUgdGhlIGxvZ2dpbmcgQVBJLlxuXHQvL1x0MTQuIERlZmluZSB0aGUgdHJhY2luZyBBUEkuXG5cdC8vXHQxNi4gRGVmaW5lIHRoZSBBTUQgZGVmaW5lIGZ1bmN0aW9uLlxuXHQvL1x0MTcuIERlZmluZSB0aGUgZG9qbyB2MS54IHByb3ZpZGUvcmVxdWlyZSBtYWNoaW5lcnktLXNvIGNhbGxlZCBcImxlZ2FjeVwiIG1vZGVzLlxuXHQvL1x0MTguIFB1Ymxpc2ggZ2xvYmFsIHZhcmlhYmxlcy5cblx0Ly9cblx0Ly8gTGFuZ3VhZ2UgYW5kIEFjcm9ueW1zIGFuZCBJZGlvbXNcblx0Ly9cblx0Ly8gbW9kdWxlSWQ6IGEgQ0pTIG1vZHVsZSBpZGVudGlmaWVyLCAodXNlZCBmb3IgcHVibGljIEFQSXMpXG5cdC8vIG1pZDogbW9kdWxlSWQgKHVzZWQgaW50ZXJuYWxseSlcblx0Ly8gcGFja2FnZUlkOiBhIHBhY2thZ2UgaWRlbnRpZmllciAodXNlZCBmb3IgcHVibGljIEFQSXMpXG5cdC8vIHBpZDogcGFja2FnZUlkICh1c2VkIGludGVybmFsbHkpOyB0aGUgaW1wbGllZCBzeXN0ZW0gb3IgZGVmYXVsdCBwYWNrYWdlIGhhcyBwaWQ9PT1cIlwiXG5cdC8vIHBhY2s6IHBhY2thZ2UgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIHJlZmVyZW5jZSBhIHBhY2thZ2Ugb2JqZWN0IChzaW5jZSBqYXZhc2NyaXB0IGhhcyByZXNlcnZlZCB3b3JkcyBpbmNsdWRpbmcgXCJwYWNrYWdlXCIpXG5cdC8vIHByaWQ6IHBsdWdpbiByZXNvdXJjZSBpZGVudGlmaWVyXG5cdC8vIFRoZSBpbnRlZ2VyIGNvbnN0YW50IDEgaXMgdXNlZCBpbiBwbGFjZSBvZiB0cnVlIGFuZCAwIGluIHBsYWNlIG9mIGZhbHNlLlxuXHQvL1xuXHQvLyBUaGUgXCJmb3JlaWduLWxvYWRlclwiIGhhcyBjb25kaXRpb24gaXMgZGVmaW5lZCBpZiBhbm90aGVyIGxvYWRlciBpcyBiZWluZyB1c2VkIChlLmcuIHdlYnBhY2spIGFuZCB0aGlzIGNvZGUgaXMgb25seVxuXHQvLyBuZWVkZWQgZm9yIHJlc29sdmluZyBtb2R1bGUgaWRlbnRpZmllcnMgYmFzZWQgb24gdGhlIGNvbmZpZy4gIEluIHRoaXMgY2FzZSwgb25seSB0aGUgZnVuY3Rpb25zIHJlcXVpcmUudG9VcmwgYW5kIFxuXHQvLyByZXF1aXJlLnRvQWJzTWlkIGFyZSBzdXBwb3J0ZWQuICBUaGUgcmVxdWlyZSBhbmQgZGVmaW5lIGZ1bmN0aW9ucyBhcmUgbm90IHN1cHBvcnRlZC5cblxuXHQvLyBkZWZpbmUgZ2xvYmFsXG5cdHZhciBnbG9iYWxPYmplY3QgPSAoZnVuY3Rpb24oKXtcblx0XHRpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gZ2xvYmFsIHNwZWMgZGVmaW5lcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBjYWxsZWQgJ2dsb2JhbCdcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxuXHRcdFx0Ly8gYGdsb2JhbGAgaXMgYWxzbyBkZWZpbmVkIGluIE5vZGVKU1xuXHRcdFx0cmV0dXJuIGdsb2JhbDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdC8vIHdpbmRvdyBpcyBkZWZpbmVkIGluIGJyb3dzZXJzXG5cdFx0XHRyZXR1cm4gd2luZG93O1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdC8vIHNlbGYgaXMgZGVmaW5lZCBpbiBXZWJXb3JrZXJzXG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0pKCk7XG5cblx0Ly8gZGVmaW5lIGEgbWluaW1hbCBsaWJyYXJ5IHRvIGhlbHAgYnVpbGQgdGhlIGxvYWRlclxuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCl7XG5cdFx0fSxcblxuXHRcdGlzRW1wdHkgPSBmdW5jdGlvbihpdCl7XG5cdFx0XHRmb3IodmFyIHAgaW4gaXQpe1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiAxO1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZyA9IHt9LnRvU3RyaW5nLFxuXG5cdFx0aXNGdW5jdGlvbiA9IGZ1bmN0aW9uKGl0KXtcblx0XHRcdHJldHVybiB0b1N0cmluZy5jYWxsKGl0KSA9PSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG5cdFx0fSxcblxuXHRcdGlzU3RyaW5nID0gZnVuY3Rpb24oaXQpe1xuXHRcdFx0cmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpID09IFwiW29iamVjdCBTdHJpbmddXCI7XG5cdFx0fSxcblxuXHRcdGlzQXJyYXkgPSBmdW5jdGlvbihpdCl7XG5cdFx0XHRyZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkgPT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuXHRcdH0sXG5cblx0XHRmb3JFYWNoID0gZnVuY3Rpb24odmVjdG9yLCBjYWxsYmFjayl7XG5cdFx0XHRpZih2ZWN0b3Ipe1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdmVjdG9yLmxlbmd0aDspe1xuXHRcdFx0XHRcdGNhbGxiYWNrKHZlY3RvcltpKytdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRtaXggPSBmdW5jdGlvbihkZXN0LCBzcmMpe1xuXHRcdFx0Zm9yKHZhciBwIGluIHNyYyl7XG5cdFx0XHRcdGRlc3RbcF0gPSBzcmNbcF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGVzdDtcblx0XHR9LFxuXG5cdFx0bWFrZUVycm9yID0gZnVuY3Rpb24oZXJyb3IsIGluZm8pe1xuXHRcdFx0cmV0dXJuIG1peChuZXcgRXJyb3IoZXJyb3IpLCB7c3JjOlwiZG9qb0xvYWRlclwiLCBpbmZvOmluZm99KTtcblx0XHR9LFxuXG5cdFx0dWlkU2VlZCA9IDEsXG5cblx0XHR1aWQgPSBmdW5jdGlvbigpe1xuXHRcdFx0Ly8gUmV0dXJucyBhIHVuaXF1ZSBpZGVudGlmaWVyICh3aXRoaW4gdGhlIGxpZmV0aW1lIG9mIHRoZSBkb2N1bWVudCkgb2YgdGhlIGZvcm0gL19kKy8uXG5cdFx0XHRyZXR1cm4gXCJfXCIgKyB1aWRTZWVkKys7XG5cdFx0fSxcblxuXHRcdC8vIEZJWE1FOiBob3cgdG8gZG9jIHdpbmRvdy5yZXF1aXJlKCkgYXBpXG5cblx0XHQvLyB0aGlzIHdpbGwgYmUgdGhlIGdsb2JhbCByZXF1aXJlIGZ1bmN0aW9uOyBkZWZpbmUgaXQgaW1tZWRpYXRlbHkgc28gd2UgY2FuIHN0YXJ0IGhhbmdpbmcgdGhpbmdzIG9mZiBvZiBpdFxuXHRcdHJlcSA9IGZ1bmN0aW9uKFxuXHRcdFx0Y29uZmlnLFx0XHQgIC8vKG9iamVjdCwgb3B0aW9uYWwpIGhhc2ggb2YgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzXG5cdFx0XHRkZXBlbmRlbmNpZXMsIC8vKGFycmF5IG9mIGNvbW1vbmpzLm1vZHVsZUlkLCBvcHRpb25hbCkgbGlzdCBvZiBtb2R1bGVzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXBwbHlpbmcgY2FsbGJhY2tcblx0XHRcdGNhbGxiYWNrXHQgIC8vKGZ1bmN0aW9uLCBvcHRpb25hbCkgbGFtYmRhIGV4cHJlc3Npb24gdG8gYXBwbHkgdG8gbW9kdWxlIHZhbHVlcyBpbXBsaWVkIGJ5IGRlcGVuZGVuY2llc1xuXHRcdCl7XG5cdFx0XHRyZXR1cm4gY29udGV4dFJlcXVpcmUoY29uZmlnLCBkZXBlbmRlbmNpZXMsIGNhbGxiYWNrLCAwLCByZXEpO1xuXHRcdH0sXG5cblx0XHQvLyB0aGUgbG9hZGVyIHVzZXMgdGhlIGhhcy5qcyBBUEkgdG8gY29udHJvbCBmZWF0dXJlIGluY2x1c2lvbi9leGNsdXNpb247IGRlZmluZSB0aGVuIHVzZSB0aHJvdWdob3V0XG5cdFx0Z2xvYmFsID0gZ2xvYmFsT2JqZWN0LFxuXG5cdFx0ZG9jID0gZ2xvYmFsLmRvY3VtZW50LFxuXG5cdFx0ZWxlbWVudCA9IGRvYyAmJiBkb2MuY3JlYXRlRWxlbWVudChcIkRpVlwiKSxcblxuXHRcdGhhcyA9IHJlcS5oYXMgPSBmdW5jdGlvbihuYW1lKXtcblx0XHRcdHJldHVybiBpc0Z1bmN0aW9uKGhhc0NhY2hlW25hbWVdKSA/IChoYXNDYWNoZVtuYW1lXSA9IGhhc0NhY2hlW25hbWVdKGdsb2JhbCwgZG9jLCBlbGVtZW50KSkgOiBoYXNDYWNoZVtuYW1lXTtcblx0XHR9LFxuXG5cdFx0aGFzQ2FjaGUgPSBoYXMuY2FjaGUgPSBkZWZhdWx0Q29uZmlnLmhhc0NhY2hlO1xuXG5cdGlmIChpc0Z1bmN0aW9uKHVzZXJDb25maWcpKSB7XG5cdFx0dXNlckNvbmZpZyA9IHVzZXJDb25maWcoZ2xvYmFsT2JqZWN0KTtcblx0fVxuXG5cdGhhcy5hZGQgPSBmdW5jdGlvbihuYW1lLCB0ZXN0LCBub3csIGZvcmNlKXtcblx0XHQoaGFzQ2FjaGVbbmFtZV09PT11bmRlZmluZWQgfHwgZm9yY2UpICYmIChoYXNDYWNoZVtuYW1lXSA9IHRlc3QpO1xuXHRcdHJldHVybiBub3cgJiYgaGFzKG5hbWUpO1xuXHR9O1xuXG5cdCAwICYmIGhhcy5hZGQoXCJob3N0LW5vZGVcIiwgdXNlckNvbmZpZy5oYXMgJiYgXCJob3N0LW5vZGVcIiBpbiB1c2VyQ29uZmlnLmhhcyA/XG5cdFx0dXNlckNvbmZpZy5oYXNbXCJob3N0LW5vZGVcIl0gOlxuXHRcdCh0eXBlb2YgcHJvY2VzcyA9PSBcIm9iamVjdFwiICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICYmIHByb2Nlc3MudmVyc2lvbnMudjgpKTtcblx0aWYoIDAgKXtcblx0XHQvLyBmaXh1cCB0aGUgZGVmYXVsdCBjb25maWcgZm9yIG5vZGUuanMgZW52aXJvbm1lbnRcblx0XHRyZXF1aXJlKFwiLi9fYmFzZS9jb25maWdOb2RlLmpzXCIpLmNvbmZpZyhkZWZhdWx0Q29uZmlnKTtcblx0XHQvLyByZW1lbWJlciBub2RlJ3MgcmVxdWlyZSAod2l0aCByZXNwZWN0IHRvIGJhc2VVcmw9PWRvam8ncyByb290KVxuXHRcdGRlZmF1bHRDb25maWcubG9hZGVyUGF0Y2gubm9kZVJlcXVpcmUgPSByZXF1aXJlO1xuXHR9XG5cblx0IDAgJiYgaGFzLmFkZChcImhvc3Qtcmhpbm9cIiwgdXNlckNvbmZpZy5oYXMgJiYgXCJob3N0LXJoaW5vXCIgaW4gdXNlckNvbmZpZy5oYXMgP1xuXHRcdHVzZXJDb25maWcuaGFzW1wiaG9zdC1yaGlub1wiXSA6XG5cdFx0KHR5cGVvZiBsb2FkID09IFwiZnVuY3Rpb25cIiAmJiAodHlwZW9mIFBhY2thZ2VzID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgUGFja2FnZXMgPT0gXCJvYmplY3RcIikpKTtcblx0aWYoIDAgKXtcblx0XHQvLyBvd2luZyB0byByaGlubydzIGxhbWUgZmVhdHVyZSB0aGF0IGhpZGVzIHRoZSBzb3VyY2Ugb2YgdGhlIHNjcmlwdCwgZ2l2ZSB0aGUgdXNlciBhIHdheSB0byBzcGVjaWZ5IHRoZSBiYXNlVXJsLi4uXG5cdFx0Zm9yKHZhciBiYXNlVXJsID0gdXNlckNvbmZpZy5iYXNlVXJsIHx8IFwiLlwiLCBhcmcsIHJoaW5vQXJncyA9IHRoaXMuYXJndW1lbnRzLCBpID0gMDsgaSA8IHJoaW5vQXJncy5sZW5ndGg7KXtcblx0XHRcdGFyZyA9IChyaGlub0FyZ3NbaSsrXSArIFwiXCIpLnNwbGl0KFwiPVwiKTtcblx0XHRcdGlmKGFyZ1swXSA9PSBcImJhc2VVcmxcIil7XG5cdFx0XHRcdGJhc2VVcmwgPSBhcmdbMV07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsb2FkKGJhc2VVcmwgKyBcIi9fYmFzZS9jb25maWdSaGluby5qc1wiKTtcblx0XHRyaGlub0Rvam9Db25maWcoZGVmYXVsdENvbmZpZywgYmFzZVVybCwgcmhpbm9BcmdzKTtcblx0fVxuXG5cdCAwICYmIGhhcy5hZGQoXCJob3N0LXdlYndvcmtlclwiLCAoKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcpICYmIChzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpKSk7XG5cdGlmKCAwICl7XG5cdFx0bWl4KGRlZmF1bHRDb25maWcuaGFzQ2FjaGUsIHtcblx0XHRcdFwiaG9zdC1icm93c2VyXCI6IDAsXG5cdFx0XHRcImRvbVwiOiAwLFxuXHRcdFx0XCJkb2pvLWRvbS1yZWFkeS1hcGlcIjogMCxcblx0XHRcdFwiZG9qby1zbmlmZlwiOiAwLFxuXHRcdFx0XCJkb2pvLWluamVjdC1hcGlcIjogMSxcblx0XHRcdFwiaG9zdC13ZWJ3b3JrZXJcIjogMSxcblx0XHRcdFwiZG9qby1ndWFyYW50ZWUtY29uc29sZVwiOiAwIC8vIGNvbnNvbGUgaXMgaW1tdXRhYmxlIGluIEZGMzArLCBzZWUgaHR0cHM6Ly9idWdzLmRvam90b29sa2l0Lm9yZy90aWNrZXQvMTgxMDBcblx0XHR9KTtcblxuXHRcdGRlZmF1bHRDb25maWcubG9hZGVyUGF0Y2ggPSB7XG5cdFx0XHRpbmplY3RVcmw6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spe1xuXHRcdFx0XHQvLyBUT0RPOlxuXHRcdFx0XHQvL1x0XHRUaGlzIGlzIG5vdCBhc3luYywgbm9yIGNhbiBpdCBiZSBpbiBXZWJ3b3JrZXJzLiAgSXQgY291bGQgYmUgbWFkZSBiZXR0ZXIgYnkgcGFzc2luZ1xuXHRcdFx0XHQvL1x0XHR0aGUgZW50aXJlIHJlcXVpcmUgYXJyYXkgaW50byBpbXBvcnRTY3JpcHRzIGF0LiAgVGhpcyB3YXkgdGhlIHNjcmlwdHMgYXJlIGxvYWRlZCBpblxuXHRcdFx0XHQvL1x0XHRhc3luYyBtb2RlOyBldmVuIGlmIHRoZSBjYWxsYmFja3MgYXJlIHJhbiBpbiBzeW5jLiAgSXQgaXMgbm90IGEgbWFqb3IgaXNzdWUgYXMgd2Vid29ya2Vyc1xuXHRcdFx0XHQvL1x0XHR0ZW5kIHRvIGJlIGxvbmcgcnVubmluZyB3aGVyZSBpbml0aWFsIHN0YXJ0dXAgaXMgbm90IGEgbWFqb3IgZmFjdG9yLlxuXG5cdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRpbXBvcnRTY3JpcHRzKHVybCk7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRcdGNvbnNvbGUuaW5mbyhcImZhaWxlZCB0byBsb2FkIHJlc291cmNlIChcIiArIHVybCArIFwiKVwiKTtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIHVzZXJDb25maWcgaGFzIHRlc3RzIG92ZXJyaWRlIGRlZmF1bHRDb25maWcgaGFzIHRlc3RzOyBkbyB0aGlzIGFmdGVyIHRoZSBlbnZpcm9ubWVudCBkZXRlY3Rpb24gYmVjYXVzZVxuXHQvLyB0aGUgZW52aXJvbm1lbnQgZGV0ZWN0aW9uIHVzdWFsbHkgc2V0cyBzb21lIGhhcyBmZWF0dXJlIHZhbHVlcyBpbiB0aGUgaGFzQ2FjaGUuXG5cdGZvcih2YXIgcCBpbiB1c2VyQ29uZmlnLmhhcyl7XG5cdFx0aGFzLmFkZChwLCB1c2VyQ29uZmlnLmhhc1twXSwgMCwgMSk7XG5cdH1cblxuXHQvL1xuXHQvLyBkZWZpbmUgdGhlIGxvYWRlciBkYXRhXG5cdC8vXG5cblx0Ly8gdGhlIGxvYWRlciB3aWxsIHVzZSB0aGVzZSBsaWtlIHN5bWJvbHMgaWYgdGhlIGxvYWRlciBoYXMgdGhlIHRyYWNlQXBpOyBvdGhlcndpc2Vcblx0Ly8gZGVmaW5lIG1hZ2ljIG51bWJlcnMgc28gdGhhdCBtb2R1bGVzIGNhbiBiZSBwcm92aWRlZCBhcyBwYXJ0IG9mIGRlZmF1bHRDb25maWdcblx0dmFyIHJlcXVlc3RlZCA9IDEsXG5cdFx0YXJyaXZlZCA9IDIsXG5cdFx0bm9ubW9kdWxlID0gMyxcblx0XHRleGVjdXRpbmcgPSA0LFxuXHRcdGV4ZWN1dGVkID0gNTtcblxuXHRpZiggMCApe1xuXHRcdC8vIHRoZXNlIG1ha2UgZGVidWdnaW5nIG5pY2U7IGJ1dCB1c2luZyBzdHJpbmdzIGZvciBzeW1ib2xzIGlzIGEgZ3Jvc3Mgcm9va2llIGVycm9yOyBkb24ndCBkbyBpdCBmb3IgcHJvZHVjdGlvbiBjb2RlXG5cdFx0cmVxdWVzdGVkID0gXCJyZXF1ZXN0ZWRcIjtcblx0XHRhcnJpdmVkID0gXCJhcnJpdmVkXCI7XG5cdFx0bm9ubW9kdWxlID0gXCJub3QtYS1tb2R1bGVcIjtcblx0XHRleGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuXHRcdGV4ZWN1dGVkID0gXCJleGVjdXRlZFwiO1xuXHR9XG5cblx0dmFyIGxlZ2FjeU1vZGUgPSAwLFxuXHRcdHN5bmMgPSBcInN5bmNcIixcblx0XHR4ZCA9IFwieGRcIixcblx0XHRzeW5jRXhlY1N0YWNrID0gW10sXG5cdFx0ZG9qb1JlcXVpcmVQbHVnaW4gPSAwLFxuXHRcdGNoZWNrRG9qb1JlcXVpcmVQbHVnaW4gPSBub29wLFxuXHRcdHRyYW5zZm9ybVRvQW1kID0gbm9vcCxcblx0XHRnZXRYaHI7XG5cdGlmKCAwICl7XG5cdFx0cmVxLmlzWGRVcmwgPSBub29wO1xuXG5cdFx0cmVxLmluaXRTeW5jTG9hZGVyID0gZnVuY3Rpb24oZG9qb1JlcXVpcmVQbHVnaW5fLCBjaGVja0Rvam9SZXF1aXJlUGx1Z2luXywgdHJhbnNmb3JtVG9BbWRfKXtcblx0XHRcdC8vIHRoZSBmaXJzdCBkb2pvL19iYXNlL2xvYWRlciBsb2FkZWQgZ2V0cyB0byBkZWZpbmUgdGhlc2UgdmFyaWFibGVzOyB0aGV5IGFyZSBkZXNpZ25lZCB0byB3b3JrXG5cdFx0XHQvLyBpbiB0aGUgcHJlc2VuY2Ugb2YgemVybyB0byBtYW55IG1hcHBlZCBkb2pvL19iYXNlL2xvYWRlcnNcblx0XHRcdGlmKCFkb2pvUmVxdWlyZVBsdWdpbil7XG5cdFx0XHRcdGRvam9SZXF1aXJlUGx1Z2luID0gZG9qb1JlcXVpcmVQbHVnaW5fO1xuXHRcdFx0XHRjaGVja0Rvam9SZXF1aXJlUGx1Z2luID0gY2hlY2tEb2pvUmVxdWlyZVBsdWdpbl87XG5cdFx0XHRcdHRyYW5zZm9ybVRvQW1kID0gdHJhbnNmb3JtVG9BbWRfO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzeW5jOnN5bmMsXG5cdFx0XHRcdHJlcXVlc3RlZDpyZXF1ZXN0ZWQsXG5cdFx0XHRcdGFycml2ZWQ6YXJyaXZlZCxcblx0XHRcdFx0bm9ubW9kdWxlOm5vbm1vZHVsZSxcblx0XHRcdFx0ZXhlY3V0aW5nOmV4ZWN1dGluZyxcblx0XHRcdFx0ZXhlY3V0ZWQ6ZXhlY3V0ZWQsXG5cdFx0XHRcdHN5bmNFeGVjU3RhY2s6c3luY0V4ZWNTdGFjayxcblx0XHRcdFx0bW9kdWxlczptb2R1bGVzLFxuXHRcdFx0XHRleGVjUTpleGVjUSxcblx0XHRcdFx0Z2V0TW9kdWxlOmdldE1vZHVsZSxcblx0XHRcdFx0aW5qZWN0TW9kdWxlOmluamVjdE1vZHVsZSxcblx0XHRcdFx0c2V0QXJyaXZlZDpzZXRBcnJpdmVkLFxuXHRcdFx0XHRzaWduYWw6c2lnbmFsLFxuXHRcdFx0XHRmaW5pc2hFeGVjOmZpbmlzaEV4ZWMsXG5cdFx0XHRcdGV4ZWNNb2R1bGU6ZXhlY01vZHVsZSxcblx0XHRcdFx0ZG9qb1JlcXVpcmVQbHVnaW46ZG9qb1JlcXVpcmVQbHVnaW4sXG5cdFx0XHRcdGdldExlZ2FjeU1vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gbGVnYWN5TW9kZTt9LFxuXHRcdFx0XHRndWFyZENoZWNrQ29tcGxldGU6Z3VhcmRDaGVja0NvbXBsZXRlXG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHRpZiggMCAgfHwgIDAgKXtcblx0XHRcdC8vIGluIGxlZ2FjeSBzeW5jIG1vZGUsIHRoZSBsb2FkZXIgbmVlZHMgYSBtaW5pbWFsIFhIUiBsaWJyYXJ5XG5cblx0XHRcdHZhciBsb2NhdGlvblByb3RvY29sID0gbG9jYXRpb24ucHJvdG9jb2wsXG5cdFx0XHRcdGxvY2F0aW9uSG9zdCA9IGxvY2F0aW9uLmhvc3Q7XG5cdFx0XHRyZXEuaXNYZFVybCA9IGZ1bmN0aW9uKHVybCl7XG5cdFx0XHRcdGlmKC9eXFwuLy50ZXN0KHVybCkpe1xuXHRcdFx0XHRcdC8vIGJlZ2lucyB3aXRoIGEgZG90IGlzIGFsd2F5cyByZWxhdGl2ZSB0byBwYWdlIFVSTDsgdGhlcmVmb3JlIG5vdCB4ZG9tYWluXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKC9eXFwvXFwvLy50ZXN0KHVybCkpe1xuXHRcdFx0XHRcdC8vIGZvciB2MS42LSBiYWNrY29tcGF0LCB1cmwgc3RhcnRpbmcgd2l0aCAvLyBpbmRpY2F0ZXMgeGRvbWFpblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGdldCBwcm90b2NvbCBhbmQgaG9zdFxuXHRcdFx0XHQvLyBcXC8rIHRha2VzIGNhcmUgb2YgdGhlIHR5cGljYWwgZmlsZSBwcm90b2NvbCB0aGF0IGxvb2tzIGxpa2UgZmlsZTovLy9kcml2ZS9wYXRoL3RvL2ZpbGVcblx0XHRcdFx0Ly8gbG9jYXRpb25Ib3N0IGlzIGZhbHN5IGlmIGZpbGUgcHJvdG9jb2wgPT4gaWYgbG9jYXRpb25Qcm90b2NvbCBtYXRjaGVzIGFuZCBpcyBcImZpbGU6XCIsIHx8IHdpbGwgcmV0dXJuIGZhbHNlXG5cdFx0XHRcdHZhciBtYXRjaCA9IHVybC5tYXRjaCgvXihbXlxcL1xcOl0rXFw6KVxcLysoW15cXC9dKykvKTtcblx0XHRcdFx0cmV0dXJuIG1hdGNoICYmIChtYXRjaFsxXSAhPSBsb2NhdGlvblByb3RvY29sIHx8IChsb2NhdGlvbkhvc3QgJiYgbWF0Y2hbMl0gIT0gbG9jYXRpb25Ib3N0KSk7XG5cdFx0XHR9O1xuXG5cblx0XHRcdC8vIG5vdGU6IHRvIGdldCB0aGUgZmlsZTovLyBwcm90b2NvbCB0byB3b3JrIGluIEZGLCB5b3UgbXVzdCBzZXQgc2VjdXJpdHkuZmlsZXVyaS5zdHJpY3Rfb3JpZ2luX3BvbGljeSB0byBmYWxzZSBpbiBhYm91dDpjb25maWdcblx0XHRcdCAxIHx8IGhhcy5hZGQoXCJkb2pvLXhoci1mYWN0b3J5XCIsIDEpO1xuXHRcdFx0IDAgJiYgaGFzLmFkZChcImRvam8tZm9yY2UtYWN0aXZleC14aHJcIiwgIDEgICYmICFkb2MuYWRkRXZlbnRMaXN0ZW5lciAmJiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT0gXCJmaWxlOlwiKTtcblx0XHRcdGhhcy5hZGQoXCJuYXRpdmUteGhyXCIsIHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSBcInVuZGVmaW5lZFwiKTtcblx0XHRcdGlmKGhhcyhcIm5hdGl2ZS14aHJcIikgJiYgISAwICl7XG5cdFx0XHRcdGdldFhociA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIGlmIGluIHRoZSBicm93c2VyIGFuIG9sZCBJRTsgZmluZCBhbiB4aHJcblx0XHRcdFx0Zm9yKHZhciBYTUxIVFRQX1BST0dJRFMgPSBbJ01zeG1sMi5YTUxIVFRQJywgJ01pY3Jvc29mdC5YTUxIVFRQJywgJ01zeG1sMi5YTUxIVFRQLjQuMCddLCBwcm9naWQsIGkgPSAwOyBpIDwgMzspe1xuXHRcdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRcdHByb2dpZCA9IFhNTEhUVFBfUFJPR0lEU1tpKytdO1xuXHRcdFx0XHRcdFx0aWYobmV3IEFjdGl2ZVhPYmplY3QocHJvZ2lkKSl7XG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgcHJvZ2lkIHdvcmtzOyB0aGVyZWZvcmUsIHVzZSBpdCBmcm9tIG5vdyBvblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0XHQvLyBzcXVlbGNoOyB3ZSdyZSBqdXN0IHRyeWluZyB0byBmaW5kIGEgZ29vZCBBY3RpdmVYIHByb2dpZFxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhleSBhbGwgZmFpbCwgdGhlbiBwcm9naWQgZW5kcyB1cCBhcyB0aGUgbGFzdCBhdHRlbXB0IGFuZCB0aGF0IHdpbGwgc2lnbmFsIHRoZSBlcnJvclxuXHRcdFx0XHRcdFx0Ly8gdGhlIGZpcnN0IHRpbWUgdGhlIGNsaWVudCBhY3R1YWxseSB0cmllcyB0byBleGVjIGFuIHhoclxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRnZXRYaHIgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChwcm9naWQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmVxLmdldFhociA9IGdldFhocjtcblxuXHRcdFx0aGFzLmFkZChcImRvam8tZ2V0dGV4dC1hcGlcIiwgMSk7XG5cdFx0XHRyZXEuZ2V0VGV4dCA9IGZ1bmN0aW9uKHVybCwgYXN5bmMsIG9uTG9hZCl7XG5cdFx0XHRcdHZhciB4aHIgPSBnZXRYaHIoKTtcblx0XHRcdFx0eGhyLm9wZW4oJ0dFVCcsIGZpeHVwVXJsKHVybCksIGZhbHNlKTtcblx0XHRcdFx0eGhyLnNlbmQobnVsbCk7XG5cdFx0XHRcdGlmKHhoci5zdGF0dXMgPT0gMjAwIHx8ICghbG9jYXRpb24uaG9zdCAmJiAheGhyLnN0YXR1cykpe1xuXHRcdFx0XHRcdGlmKG9uTG9hZCl7XG5cdFx0XHRcdFx0XHRvbkxvYWQoeGhyLnJlc3BvbnNlVGV4dCwgYXN5bmMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0dGhyb3cgbWFrZUVycm9yKFwieGhyRmFpbGVkXCIsIHhoci5zdGF0dXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xuXHRcdFx0fTtcblx0XHR9XG5cdH1lbHNle1xuXHRcdHJlcS5hc3luYyA9IDE7XG5cdH1cblxuXHQvL1xuXHQvLyBsb2FkZXIgZXZhbFxuXHQvL1xuXHR2YXIgZXZhbF8gPSAgIDEgID9cblx0XHQvLyBub29wIGV2YWwgaWYgdGhlcmUgYXJlIGNzcCByZXN0cmljdGlvbnNcblx0XHRmdW5jdGlvbigpe30gOlxuXHRcdC8vIHVzZSB0aGUgZnVuY3Rpb24gY29uc3RydWN0b3Igc28gb3VyIGV2YWwgaXMgc2NvcGVkIGNsb3NlIHRvIChidXQgbm90IGluKSBpbiB0aGUgZ2xvYmFsIHNwYWNlIHdpdGggbWluaW1hbCBwb2xsdXRpb25cblx0XHRuZXcgRnVuY3Rpb24oJ3JldHVybiBldmFsKGFyZ3VtZW50c1swXSk7Jyk7XG5cblx0cmVxLmV2YWwgPVxuXHRcdGZ1bmN0aW9uKHRleHQsIGhpbnQpe1xuXHRcdFx0cmV0dXJuIGV2YWxfKHRleHQgKyBcIlxcclxcbi8vIyBzb3VyY2VVUkw9XCIgKyBoaW50KTtcblx0XHR9O1xuXG5cdC8vXG5cdC8vIGxvYWRlciBtaWNybyBldmVudHMgQVBJXG5cdC8vXG5cdHZhciBsaXN0ZW5lclF1ZXVlcyA9IHt9LFxuXHRcdGVycm9yID0gXCJlcnJvclwiLFxuXHRcdHNpZ25hbCA9IHJlcS5zaWduYWwgPSBmdW5jdGlvbih0eXBlLCBhcmdzKXtcblx0XHRcdHZhciBxdWV1ZSA9IGxpc3RlbmVyUXVldWVzW3R5cGVdO1xuXHRcdFx0Ly8gbm90aWNlIHdlIHJ1biBhIGNvcHkgb2YgdGhlIHF1ZXVlOyB0aGlzIGFsbG93cyBsaXN0ZW5lcnMgdG8gYWRkL3JlbW92ZVxuXHRcdFx0Ly8gb3RoZXIgbGlzdGVuZXJzIHdpdGhvdXQgYWZmZWN0aW5nIHRoaXMgcGFydGljdWxhciBzaWduYWxcblx0XHRcdGZvckVhY2gocXVldWUgJiYgcXVldWUuc2xpY2UoMCksIGZ1bmN0aW9uKGxpc3RlbmVyKXtcblx0XHRcdFx0bGlzdGVuZXIuYXBwbHkobnVsbCwgaXNBcnJheShhcmdzKSA/IGFyZ3MgOiBbYXJnc10pO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRvbiA9IHJlcS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKXtcblx0XHRcdC8vIG5vdGljZSBhIHF1ZXVlIGlzIG5vdCBjcmVhdGVkIHVudGlsIGEgY2xpZW50IGFjdHVhbGx5IGNvbm5lY3RzXG5cdFx0XHR2YXIgcXVldWUgPSBsaXN0ZW5lclF1ZXVlc1t0eXBlXSB8fCAobGlzdGVuZXJRdWV1ZXNbdHlwZV0gPSBbXSk7XG5cdFx0XHRxdWV1ZS5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHJlbW92ZTpmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGk8cXVldWUubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdFx0aWYocXVldWVbaV09PT1saXN0ZW5lcil7XG5cdFx0XHRcdFx0XHRcdHF1ZXVlLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXG5cdC8vIGNvbmZpZ3VyYXRpb24gbWFjaGluZXJ5OyB3aXRoIGFuIG9wdGltaXplZC9idWlsdCBkZWZhdWx0Q29uZmlnLCBhbGwgY29uZmlndXJhdGlvbiBtYWNoaW5lcnkgY2FuIGJlIGRpc2NhcmRlZFxuXHQvLyBsZXhpY2FsIHZhcmlhYmxlcyBob2xkIGtleSBsb2FkZXIgZGF0YSBzdHJ1Y3R1cmVzIHRvIGhlbHAgd2l0aCBtaW5pZmljYXRpb247IHRoZXNlIG1heSBiZSBjb21wbGV0ZWx5LFxuXHQvLyBvbmUtdGltZSBpbml0aWFsaXplZCBieSBkZWZhdWx0Q29uZmlnIGZvciBvcHRpbWl6ZWQvYnVpbHQgdmVyc2lvbnNcblx0dmFyXG5cdFx0YWxpYXNlc1xuXHRcdFx0Ly8gYSB2ZWN0b3Igb2YgcGFpcnMgb2YgW3JlZ2V4cyBvciBzdHJpbmcsIHJlcGxhY2VtZW50XSA9PiAoYWxpYXMsIGFjdHVhbClcblx0XHRcdD0gW10sXG5cblx0XHRwYXRoc1xuXHRcdFx0Ly8gQ29tbW9uSlMgcGF0aHNcblx0XHRcdD0ge30sXG5cblx0XHRwYXRoc01hcFByb2dcblx0XHRcdC8vIGxpc3Qgb2YgKGZyb20tcGF0aCwgdG8tcGF0aCwgcmVnZXgsIGxlbmd0aCkgZGVyaXZlZCBmcm9tIHBhdGhzO1xuXHRcdFx0Ly8gYSBcInByb2dyYW1cIiB0byBhcHBseSBwYXRoczsgc2VlIGNvbXB1dGVNYXBQcm9nXG5cdFx0XHQ9IFtdLFxuXG5cdFx0cGFja3Ncblx0XHRcdC8vIGEgbWFwIGZyb20gcGFja2FnZUlkIHRvIHBhY2thZ2UgY29uZmlndXJhdGlvbiBvYmplY3Q7IHNlZSBmaXh1cFBhY2thZ2VJbmZvXG5cdFx0XHQ9IHt9LFxuXG5cdFx0bWFwID0gcmVxLm1hcFxuXHRcdFx0Ly8gQU1EIG1hcCBjb25maWcgdmFyaWFibGU7IGRvam8vX2Jhc2Uva2VybmVsIG5lZWRzIHJlcS5tYXAgdG8gZmlndXJlIG91dCB0aGUgc2NvcGUgbWFwXG5cdFx0XHQ9IHt9LFxuXG5cdFx0bWFwUHJvZ3Ncblx0XHRcdC8vIHZlY3RvciBvZiBxdWFkcyBhcyBkZXNjcmliZWQgYnkgY29tcHV0ZU1hcFByb2c7IG1hcC1rZXkgaXMgQU1EIG1hcCBrZXksIG1hcC12YWx1ZSBpcyBBTUQgbWFwIHZhbHVlXG5cdFx0XHQ9IFtdLFxuXG5cdFx0bW9kdWxlc1xuXHRcdFx0Ly8gQSBoYXNoOihtaWQpIC0tPiAobW9kdWxlLW9iamVjdCkgdGhlIG1vZHVsZSBuYW1lc3BhY2Vcblx0XHRcdC8vXG5cdFx0XHQvLyBwaWQ6IHRoZSBwYWNrYWdlIGlkZW50aWZpZXIgdG8gd2hpY2ggdGhlIG1vZHVsZSBiZWxvbmdzIChlLmcuLCBcImRvam9cIik7IFwiXCIgaW5kaWNhdGVzIHRoZSBzeXN0ZW0gb3IgZGVmYXVsdCBwYWNrYWdlXG5cdFx0XHQvLyBtaWQ6IHRoZSBmdWxseS1yZXNvbHZlZCAoaS5lLiwgbWFwcGluZ3MgaGF2ZSBiZWVuIGFwcGxpZWQpIG1vZHVsZSBpZGVudGlmaWVyIHdpdGhvdXQgdGhlIHBhY2thZ2UgaWRlbnRpZmllciAoZS5nLiwgXCJkb2pvL2lvL3NjcmlwdFwiKVxuXHRcdFx0Ly8gdXJsOiB0aGUgVVJMIGZyb20gd2hpY2ggdGhlIG1vZHVsZSB3YXMgcmV0cmlldmVkXG5cdFx0XHQvLyBwYWNrOiB0aGUgcGFja2FnZSBvYmplY3Qgb2YgdGhlIHBhY2thZ2UgdG8gd2hpY2ggdGhlIG1vZHVsZSBiZWxvbmdzXG5cdFx0XHQvLyBleGVjdXRlZDogMCA9PiBub3QgZXhlY3V0ZWQ7IGV4ZWN1dGluZyA9PiBpbiB0aGUgcHJvY2VzcyBvZiB0cmF2ZXJzaW5nIGRlcHMgYW5kIHJ1bm5pbmcgZmFjdG9yeTsgZXhlY3V0ZWQgPT4gZmFjdG9yeSBoYXMgYmVlbiBleGVjdXRlZFxuXHRcdFx0Ly8gZGVwczogdGhlIGRlcGVuZGVuY3kgdmVjdG9yIGZvciB0aGlzIG1vZHVsZSAodmVjdG9yIG9mIG1vZHVsZXMgb2JqZWN0cylcblx0XHRcdC8vIGRlZjogdGhlIGZhY3RvcnkgZm9yIHRoaXMgbW9kdWxlXG5cdFx0XHQvLyByZXN1bHQ6IHRoZSByZXN1bHQgb2YgdGhlIHJ1bm5pbmcgdGhlIGZhY3RvcnkgZm9yIHRoaXMgbW9kdWxlXG5cdFx0XHQvLyBpbmplY3RlZDogKDAgfCByZXF1ZXN0ZWQgfCBhcnJpdmVkKSB0aGUgc3RhdHVzIG9mIHRoZSBtb2R1bGU7IG5vbm1vZHVsZSBtZWFucyB0aGUgcmVzb3VyY2UgZGlkIG5vdCBjYWxsIGRlZmluZVxuXHRcdFx0Ly8gbG9hZDogcGx1Z2luIGxvYWQgZnVuY3Rpb247IGFwcGxpY2FibGUgb25seSBmb3IgcGx1Z2luc1xuXHRcdFx0Ly9cblx0XHRcdC8vIE1vZHVsZXMgZ28gdGhyb3VnaCBzZXZlcmFsIHBoYXNlcyBpbiBjcmVhdGlvbjpcblx0XHRcdC8vXG5cdFx0XHQvLyAxLiBSZXF1ZXN0ZWQ6IHNvbWUgb3RoZXIgbW9kdWxlJ3MgZGVmaW5pdGlvbiBvciBhIHJlcXVpcmUgYXBwbGljYXRpb24gY29udGFpbmVkIHRoZSByZXF1ZXN0ZWQgbW9kdWxlIGluXG5cdFx0XHQvL1x0ICBpdHMgZGVwZW5kZW5jeSB2ZWN0b3Igb3IgZXhlY3V0aW5nIGNvZGUgZXhwbGljaXRseSBkZW1hbmRzIGEgbW9kdWxlIHZpYSByZXEucmVxdWlyZS5cblx0XHRcdC8vXG5cdFx0XHQvLyAyLiBJbmplY3RlZDogYSBzY3JpcHQgZWxlbWVudCBoYXMgYmVlbiBhcHBlbmRlZCB0byB0aGUgaW5zZXJ0LXBvaW50IGVsZW1lbnQgZGVtYW5kaW5nIHRoZSByZXNvdXJjZSBpbXBsaWVkIGJ5IHRoZSBVUkxcblx0XHRcdC8vXG5cdFx0XHQvLyAzLiBMb2FkZWQ6IHRoZSByZXNvdXJjZSBpbmplY3RlZCBpbiBbMl0gaGFzIGJlZW4gZXZhbHVhdGVkLlxuXHRcdFx0Ly9cblx0XHRcdC8vIDQuIERlZmluZWQ6IHRoZSByZXNvdXJjZSBjb250YWluZWQgYSBkZWZpbmUgc3RhdGVtZW50IHRoYXQgYWR2aXNlZCB0aGUgbG9hZGVyIGFib3V0IHRoZSBtb2R1bGUuIE5vdGljZSB0aGF0IHNvbWVcblx0XHRcdC8vXHQgIHJlc291cmNlcyBtYXkganVzdCBjb250YWluIGEgYnVuZGxlIG9mIGNvZGUgYW5kIG5ldmVyIGZvcm1hbGx5IGRlZmluZSBhIG1vZHVsZSB2aWEgZGVmaW5lXG5cdFx0XHQvL1xuXHRcdFx0Ly8gNS4gRXZhbHVhdGVkOiB0aGUgbW9kdWxlIHdhcyBkZWZpbmVkIHZpYSBkZWZpbmUgYW5kIHRoZSBsb2FkZXIgaGFzIGV2YWx1YXRlZCB0aGUgZmFjdG9yeSBhbmQgY29tcHV0ZWQgYSByZXN1bHQuXG5cdFx0XHQ9IHt9LFxuXG5cdFx0Y2FjaGVCdXN0XG5cdFx0XHQvLyBxdWVyeSBzdHJpbmcgdG8gYXBwZW5kIHRvIG1vZHVsZSBVUkxzIHRvIGJ1c3QgYnJvd3NlciBjYWNoZVxuXHRcdFx0PSBcIlwiLFxuXG5cdFx0Y2FjaGVcblx0XHRcdC8vIGhhc2g6KG1pZCB8IHVybCktLT4oZnVuY3Rpb24gfCBzdHJpbmcpXG5cdFx0XHQvL1xuXHRcdFx0Ly8gQSBjYWNoZSBvZiByZXNvdXJjZXMuIFRoZSByZXNvdXJjZXMgYXJyaXZlIHZpYSBhIGNvbmZpZy5jYWNoZSBvYmplY3QsIHdoaWNoIGlzIGEgaGFzaCBmcm9tIGVpdGhlciBtaWQgLS0+IGZ1bmN0aW9uIG9yXG5cdFx0XHQvLyB1cmwgLS0+IHN0cmluZy4gVGhlIHVybCBrZXkgaXMgZGlzdGluZ3Vpc2hlZCBmcm9tIHRoZSBtaWQga2V5IGJ5IGFsd2F5cyBjb250YWluaW5nIHRoZSBwcmVmaXggXCJ1cmw6XCIuIHVybCBrZXlzIGFzIHByb3ZpZGVkXG5cdFx0XHQvLyBieSBjb25maWcuY2FjaGUgYWx3YXlzIGhhdmUgYSBzdHJpbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50cyBvZiB0aGUgcmVzb3VyY2UgYXQgdGhlIGdpdmVuIHVybC4gbWlkIGtleXMgYXMgcHJvdmlkZWRcblx0XHRcdC8vIGJ5IGNvbmZpZ2wuY2FjaGUgYWx3YXlzIGhhdmUgYSBmdW5jdGlvbiB2YWx1ZSB0aGF0IGNhdXNlcyB0aGUgc2FtZSBjb2RlIHRvIGV4ZWN1dGUgYXMgaWYgdGhlIG1vZHVsZSB3YXMgc2NyaXB0IGluamVjdGVkLlxuXHRcdFx0Ly9cblx0XHRcdC8vIEJvdGgga2luZHMgb2Yga2V5LXZhbHVlIHBhaXJzIGFyZSBlbnRlcmVkIGludG8gY2FjaGUgdmlhIHRoZSBmdW5jdGlvbiBjb25zdW1lUGVuZGluZ0NhY2hlLCB3aGljaCBtYXkgcmVsb2NhdGUga2V5cyBhcyBnaXZlblxuXHRcdFx0Ly8gYnkgYW55IG1hcHBpbmdzICppZmYqIHRoZSBjb25maWcuY2FjaGUgd2FzIHJlY2VpdmVkIGFzIHBhcnQgb2YgYSBtb2R1bGUgcmVzb3VyY2UgcmVxdWVzdC5cblx0XHRcdC8vXG5cdFx0XHQvLyBGdXJ0aGVyLCBmb3IgbWlkIGtleXMsIHRoZSBpbXBsaWVkIHVybCBpcyBjb21wdXRlZCBhbmQgdGhlIHZhbHVlIGlzIGVudGVyZWQgaW50byB0aGF0IGtleSBhcyB3ZWxsLiBUaGlzIGFsbG93cyBtYXBwZWQgbW9kdWxlc1xuXHRcdFx0Ly8gdG8gcmV0cmlldmUgY2FjaGVkIGl0ZW1zIHRoYXQgbWF5IGhhdmUgYXJyaXZlZCBjb25zZXF1ZW50IHRvIGFub3RoZXIgbmFtZXNwYWNlLlxuXHRcdFx0Ly9cblx0XHRcdCA9IHt9LFxuXG5cdFx0dXJsS2V5UHJlZml4XG5cdFx0XHQvLyB0aGUgcHJlZml4IHRvIHByZXBlbmQgdG8gYSBVUkwga2V5IGluIHRoZSBjYWNoZS5cblx0XHRcdD0gXCJ1cmw6XCIsXG5cblx0XHRwZW5kaW5nQ2FjaGVJbnNlcnRcblx0XHRcdC8vIGhhc2g6KG1pZCktLT4oZnVuY3Rpb24pXG5cdFx0XHQvL1xuXHRcdFx0Ly8gR2l2ZXMgYSBzZXQgb2YgY2FjaGUgbW9kdWxlcyBwZW5kaW5nIGVudHJ5IGludG8gY2FjaGUuIFdoZW4gY2FjaGVkIG1vZHVsZXMgYXJlIHB1Ymxpc2hlZCB0byB0aGUgbG9hZGVyLCB0aGV5IGFyZVxuXHRcdFx0Ly8gZW50ZXJlZCBpbnRvIHBlbmRpbmdDYWNoZUluc2VydDsgbW9kdWxlcyBhcmUgdGhlbiBwcmVzc2VkIGludG8gY2FjaGUgdXBvbiAoMSkgQU1EIGRlZmluZSBvciAoMikgdXBvbiByZWNlaXZpbmcgYW5vdGhlclxuXHRcdFx0Ly8gaW5kZXBlbmRlbnQgc2V0IG9mIGNhY2hlZCBtb2R1bGVzLiAoMSkgaXMgdGhlIHVzdWFsIGNhc2UsIGFuZCB0aGlzIGNhc2UgYWxsb3dzIG5vcm1hbGl6aW5nIG1pZHMgZ2l2ZW4gaW4gdGhlIHBlbmRpbmdcblx0XHRcdC8vIGNhY2hlIGZvciB0aGUgbG9jYWwgY29uZmlndXJhdGlvbiwgcG9zc2libHkgcmVsb2NhdGluZyBtb2R1bGVzLlxuXHRcdFx0ID0ge30sXG5cblx0XHRkb2pvU25pZmZDb25maWdcblx0XHRcdC8vIG1hcCBvZiBjb25maWd1cmF0aW9uIHZhcmlhYmxlc1xuXHRcdFx0Ly8gZ2l2ZSB0aGUgZGF0YS1kb2pvLWNvbmZpZyBhcyBzbmlmZmVkIGZyb20gdGhlIGRvY3VtZW50IChpZiBhbnkpXG5cdFx0XHQ9IHt9LFxuXG5cdFx0aW5zZXJ0UG9pbnRTaWJsaW5nXG5cdFx0XHQvLyB0aGUgbm9kZXMgdXNlZCB0byBsb2NhdGUgd2hlcmUgc2NyaXB0cyBhcmUgaW5qZWN0ZWQgaW50byB0aGUgZG9jdW1lbnRcblx0XHRcdD0gMDtcblxuXHRpZiggMSApe1xuXHRcdGlmICghIDEgKSB7XG5cdFx0XHR2YXIgY29uc3VtZVBlbmRpbmdDYWNoZUluc2VydCA9IGZ1bmN0aW9uKHJlZmVyZW5jZU1vZHVsZSwgY2xlYXIpe1xuXHRcdFx0XHRcdGNsZWFyID0gY2xlYXIgIT09IGZhbHNlO1xuXHRcdFx0XHRcdHZhciBwLCBpdGVtLCBtYXRjaCwgbm93LCBtO1xuXHRcdFx0XHRcdGZvcihwIGluIHBlbmRpbmdDYWNoZUluc2VydCl7XG5cdFx0XHRcdFx0XHRpdGVtID0gcGVuZGluZ0NhY2hlSW5zZXJ0W3BdO1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBwLm1hdGNoKC9edXJsXFw6KC4rKS8pO1xuXHRcdFx0XHRcdFx0aWYobWF0Y2gpe1xuXHRcdFx0XHRcdFx0XHRjYWNoZVt1cmxLZXlQcmVmaXggKyB0b1VybChtYXRjaFsxXSwgcmVmZXJlbmNlTW9kdWxlKV0gPSAgaXRlbTtcblx0XHRcdFx0XHRcdH1lbHNlIGlmKHA9PVwiKm5vd1wiKXtcblx0XHRcdFx0XHRcdFx0bm93ID0gaXRlbTtcblx0XHRcdFx0XHRcdH1lbHNlIGlmKHAhPVwiKm5vcmVmXCIpe1xuXHRcdFx0XHRcdFx0XHRtID0gZ2V0TW9kdWxlSW5mbyhwLCByZWZlcmVuY2VNb2R1bGUsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRjYWNoZVttLm1pZF0gPSBjYWNoZVt1cmxLZXlQcmVmaXggKyBtLnVybF0gPSBpdGVtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihub3cpe1xuXHRcdFx0XHRcdFx0bm93KGNyZWF0ZVJlcXVpcmUocmVmZXJlbmNlTW9kdWxlKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGNsZWFyKXtcblx0XHRcdFx0XHRcdHBlbmRpbmdDYWNoZUluc2VydCA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9XG5cdFx0dmFyIGVzY2FwZVN0cmluZyA9IGZ1bmN0aW9uKHMpe1xuXHRcdFx0XHRyZXR1cm4gcy5yZXBsYWNlKC8oW1xcLiQ/Knx7fVxcKFxcKVxcW1xcXVxcXFxcXC9cXCteXSkvZywgZnVuY3Rpb24oYyl7IHJldHVybiBcIlxcXFxcIiArIGM7IH0pO1xuXHRcdFx0fSxcblxuXHRcdFx0Y29tcHV0ZU1hcFByb2cgPSBmdW5jdGlvbihtYXAsIGRlc3Qpe1xuXHRcdFx0XHQvLyBUaGlzIHJvdXRpbmUgdGFrZXMgYSBtYXAgYXMgcmVwcmVzZW50ZWQgYnkgYSBKYXZhU2NyaXB0IG9iamVjdCBhbmQgaW5pdGlhbGl6ZXMgZGVzdCwgYSB2ZWN0b3Igb2Zcblx0XHRcdFx0Ly8gcXVhZHMgb2YgKG1hcC1rZXksIG1hcC12YWx1ZSwgcmVmZXgtZm9yLW1hcC1rZXksIGxlbmd0aC1vZi1tYXAta2V5KSwgc29ydGVkIGRlY3JlYXNpbmcgYnkgbGVuZ3RoLVxuXHRcdFx0XHQvLyBvZi1tYXAta2V5LiBUaGUgcmVnZXggbG9va3MgZm9yIHRoZSBtYXAta2V5IGZvbGxvd2VkIGJ5IGVpdGhlciBcIi9cIiBvciBlbmQtb2Ytc3RyaW5nIGF0IHRoZSBiZWdpbm5pbmdcblx0XHRcdFx0Ly8gb2YgYSB0aGUgc2VhcmNoIHNvdXJjZS4gTm90aWNlIHRoZSBtYXAtdmFsdWUgaXMgaXJyZWxldmFudCB0byB0aGUgYWxnb3JpdGhtXG5cdFx0XHRcdGRlc3Quc3BsaWNlKDAsIGRlc3QubGVuZ3RoKTtcblx0XHRcdFx0Zm9yKHZhciBwIGluIG1hcCl7XG5cdFx0XHRcdFx0ZGVzdC5wdXNoKFtcblx0XHRcdFx0XHRcdHAsXG5cdFx0XHRcdFx0XHRtYXBbcF0sXG5cdFx0XHRcdFx0XHRuZXcgUmVnRXhwKFwiXlwiICsgZXNjYXBlU3RyaW5nKHApICsgXCIoXFwvfCQpXCIpLFxuXHRcdFx0XHRcdFx0cC5sZW5ndGhdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZXN0LnNvcnQoZnVuY3Rpb24obGhzLCByaHMpeyByZXR1cm4gcmhzWzNdIC0gbGhzWzNdOyB9KTtcblx0XHRcdFx0cmV0dXJuIGRlc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHRjb21wdXRlQWxpYXNlcyA9IGZ1bmN0aW9uKGNvbmZpZywgZGVzdCl7XG5cdFx0XHRcdGZvckVhY2goY29uZmlnLCBmdW5jdGlvbihwYWlyKXtcblx0XHRcdFx0XHQvLyB0YWtlIGEgZml4ZWQtdXAgY29weS4uLlxuXHRcdFx0XHRcdGRlc3QucHVzaChbaXNTdHJpbmcocGFpclswXSkgPyBuZXcgUmVnRXhwKFwiXlwiICsgZXNjYXBlU3RyaW5nKHBhaXJbMF0pICsgXCIkXCIpIDogcGFpclswXSwgcGFpclsxXV0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblxuXHRcdFx0Zml4dXBQYWNrYWdlSW5mbyA9IGZ1bmN0aW9uKHBhY2thZ2VJbmZvKXtcblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBwcmVjaXNlIChuYW1lLCBsb2NhdGlvbiwgbWFpbiwgbWFwcGluZ3MpIGZvciBhIHBhY2thZ2Vcblx0XHRcdFx0dmFyIG5hbWUgPSBwYWNrYWdlSW5mby5uYW1lO1xuXHRcdFx0XHRpZighbmFtZSl7XG5cdFx0XHRcdFx0Ly8gcGFja2FnZUluZm8gbXVzdCBiZSBhIHN0cmluZyB0aGF0IGdpdmVzIHRoZSBuYW1lXG5cdFx0XHRcdFx0bmFtZSA9IHBhY2thZ2VJbmZvO1xuXHRcdFx0XHRcdHBhY2thZ2VJbmZvID0ge25hbWU6bmFtZX07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFja2FnZUluZm8gPSBtaXgoe21haW46XCJtYWluXCJ9LCBwYWNrYWdlSW5mbyk7XG5cdFx0XHRcdHBhY2thZ2VJbmZvLmxvY2F0aW9uID0gcGFja2FnZUluZm8ubG9jYXRpb24gPyBwYWNrYWdlSW5mby5sb2NhdGlvbiA6IG5hbWU7XG5cblx0XHRcdFx0Ly8gcGFja2FnZU1hcCBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIEFNRCBtYXBcblx0XHRcdFx0aWYocGFja2FnZUluZm8ucGFja2FnZU1hcCl7XG5cdFx0XHRcdFx0bWFwW25hbWVdID0gcGFja2FnZUluZm8ucGFja2FnZU1hcDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCFwYWNrYWdlSW5mby5tYWluLmluZGV4T2YoXCIuL1wiKSl7XG5cdFx0XHRcdFx0cGFja2FnZUluZm8ubWFpbiA9IHBhY2thZ2VJbmZvLm1haW4uc3Vic3RyaW5nKDIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbm93IHRoYXQgd2UndmUgZ290IGEgZnVsbHktcmVzb2x2ZWQgcGFja2FnZSBvYmplY3QsIHB1c2ggaXQgaW50byB0aGUgY29uZmlndXJhdGlvblxuXHRcdFx0XHRwYWNrc1tuYW1lXSA9IHBhY2thZ2VJbmZvO1xuXHRcdFx0fSxcblxuXHRcdFx0ZGVsYXllZE1vZHVsZUNvbmZpZ1xuXHRcdFx0XHQvLyBtb2R1bGUgY29uZmlnIGNhbm5vdCBiZSBjb25zdW1lZCB1bnRpbCB0aGUgbG9hZGVyIGlzIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQ7IHRoZXJlZm9yZSwgYWxsXG5cdFx0XHRcdC8vIG1vZHVsZSBjb25maWcgZGV0ZWN0ZWQgZHVyaW5nIGJvb3RpbmcgaXMgbWVtb3JpemVkIGFuZCBhcHBsaWVkIGF0IHRoZSBlbmQgb2YgbG9hZGVyIGluaXRpYWxpemF0aW9uXG5cdFx0XHRcdC8vIFRPRE86IHRoaXMgaXMgYSBiaXQgb2YgYSBrbHVkZ2U7IGFsbCBjb25maWcgc2hvdWxkIGJlIG1vdmVkIHRvIGVuZCBvZiBsb2FkZXIgaW5pdGlhbGl6YXRpb24sIGJ1dFxuXHRcdFx0XHQvLyB3ZSdsbCBkZWxheSB0aGlzIGNob3JlIGFuZCBkbyBpdCB3aXRoIGEgZmluYWwgbG9hZGVyIDEueCBjbGVhbnVwIGFmdGVyIHRoZSAyLnggbG9hZGVyIHByb3RvdHlwaW5nIGlzIGNvbXBsZXRlXG5cdFx0XHRcdD0gW10sXG5cblxuXHRcdFx0Y29uZmlnID0gZnVuY3Rpb24oY29uZmlnLCBib290aW5nLCByZWZlcmVuY2VNb2R1bGUpe1xuXHRcdFx0XHRmb3IodmFyIHAgaW4gY29uZmlnKXtcblx0XHRcdFx0XHRpZihwPT1cIndhaXRTZWNvbmRzXCIpe1xuXHRcdFx0XHRcdFx0cmVxLndhaXRtcyA9IChjb25maWdbcF0gfHwgMCkgKiAxMDAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihwPT1cImNhY2hlQnVzdFwiKXtcblx0XHRcdFx0XHRcdGNhY2hlQnVzdCA9IGNvbmZpZ1twXSA/IChpc1N0cmluZyhjb25maWdbcF0pID8gY29uZmlnW3BdIDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIFwiXCIpIDogXCJcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocD09XCJiYXNlVXJsXCIgfHwgcD09XCJjb21ib1wiKXtcblx0XHRcdFx0XHRcdHJlcVtwXSA9IGNvbmZpZ1twXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoIDAgICYmIHA9PVwiYXN5bmNcIil7XG5cdFx0XHRcdFx0XHQvLyBmYWxzeSBvciBcInN5bmNcIiA9PiBsZWdhY3kgc3luYyBsb2FkZXJcblx0XHRcdFx0XHRcdC8vIFwieGRcIiA9PiBzeW5jIGJ1dCBsb2FkaW5nIHhkb21haW4gdHJlZSBhbmQgdGhlcmVmb3JlIGxvYWRpbmcgYXN5bmNocm9ub3VzbHkgKG5vdCBjb25maWd1cmFibGUsIHNldCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBsb2FkZXIpXG5cdFx0XHRcdFx0XHQvLyBcImxlZ2FjeUFzeW5jXCIgPT4gcGVybWFuZW50bHkgaW4gXCJ4ZFwiIGJ5IGNob2ljZVxuXHRcdFx0XHRcdFx0Ly8gXCJkZWJ1Z0F0QWxsQ29zdHNcIiA9PiB0cnlpbmcgdG8gbG9hZCBldmVyeXRoaW5nIHZpYSBzY3JpcHQgaW5qZWN0aW9uIChub3QgaW1wbGVtZW50ZWQpXG5cdFx0XHRcdFx0XHQvLyBvdGhlcndpc2UsIG11c3QgYmUgdHJ1dGh5ID0+IEFNRFxuXHRcdFx0XHRcdFx0Ly8gbGVnYWN5TW9kZTogc3luYyB8IGxlZ2FjeUFzeW5jIHwgeGQgfCBmYWxzZVxuXHRcdFx0XHRcdFx0dmFyIG1vZGUgPSBjb25maWdbcF07XG5cdFx0XHRcdFx0XHRyZXEubGVnYWN5TW9kZSA9IGxlZ2FjeU1vZGUgPSAoaXNTdHJpbmcobW9kZSkgJiYgL3N5bmN8bGVnYWN5QXN5bmMvLnRlc3QobW9kZSkgPyBtb2RlIDogKCFtb2RlID8gc3luYyA6IGZhbHNlKSk7XG5cdFx0XHRcdFx0XHRyZXEuYXN5bmMgPSAhbGVnYWN5TW9kZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoY29uZmlnW3BdIT09aGFzQ2FjaGUpe1xuXHRcdFx0XHRcdFx0Ly8gYWNjdW11bGF0ZSByYXcgY29uZmlnIGluZm8gZm9yIGNsaWVudCBhcHBzIHdoaWNoIGNhbiB1c2UgdGhpcyB0byBwYXNzIHRoZWlyIG93biBjb25maWdcblx0XHRcdFx0XHRcdHJlcS5yYXdDb25maWdbcF0gPSBjb25maWdbcF07XG5cdFx0XHRcdFx0XHRwIT1cImhhc1wiICYmIGhhcy5hZGQoXCJjb25maWctXCIrcCwgY29uZmlnW3BdLCAwLCBib290aW5nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBtYWtlIHN1cmUgYmFzZVVybCBleGlzdHNcblx0XHRcdFx0aWYoIXJlcS5iYXNlVXJsKXtcblx0XHRcdFx0XHRyZXEuYmFzZVVybCA9IFwiLi9cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBtYWtlIHN1cmUgYmFzZVVybCBlbmRzIHdpdGggYSBzbGFzaFxuXHRcdFx0XHRpZighL1xcLyQvLnRlc3QocmVxLmJhc2VVcmwpKXtcblx0XHRcdFx0XHRyZXEuYmFzZVVybCArPSBcIi9cIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vdyBkbyB0aGUgc3BlY2lhbCB3b3JrIGZvciBoYXMsIHBhY2thZ2VzLCBwYWNrYWdlUGF0aHMsIHBhdGhzLCBhbGlhc2VzLCBhbmQgY2FjaGVcblxuXHRcdFx0XHRmb3IocCBpbiBjb25maWcuaGFzKXtcblx0XHRcdFx0XHRoYXMuYWRkKHAsIGNvbmZpZy5oYXNbcF0sIDAsIGJvb3RpbmcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZm9yIGVhY2ggcGFja2FnZSBmb3VuZCBpbiBhbnkgcGFja2FnZXMgY29uZmlnIGl0ZW0sIGF1Z21lbnQgdGhlIHBhY2tzIG1hcCBvd25lZCBieSB0aGUgbG9hZGVyXG5cdFx0XHRcdGZvckVhY2goY29uZmlnLnBhY2thZ2VzLCBmaXh1cFBhY2thZ2VJbmZvKTtcblxuXHRcdFx0XHQvLyBmb3IgZWFjaCBwYWNrYWdlUGF0aCBmb3VuZCBpbiBhbnkgcGFja2FnZVBhdGhzIGNvbmZpZyBpdGVtLCBhdWdtZW50IHRoZSBwYWNrYWdlQ29uZmlnXG5cdFx0XHRcdC8vIHBhY2thZ2VQYXRocyBpcyBkZXByZWNhdGVkOyByZW1vdmUgaW4gMi4wXG5cdFx0XHRcdGZvcih2YXIgYmFzZVVybCBpbiBjb25maWcucGFja2FnZVBhdGhzKXtcblx0XHRcdFx0XHRmb3JFYWNoKGNvbmZpZy5wYWNrYWdlUGF0aHNbYmFzZVVybF0sIGZ1bmN0aW9uKHBhY2thZ2VJbmZvKXtcblx0XHRcdFx0XHRcdHZhciBsb2NhdGlvbiA9IGJhc2VVcmwgKyBcIi9cIiArIHBhY2thZ2VJbmZvO1xuXHRcdFx0XHRcdFx0aWYoaXNTdHJpbmcocGFja2FnZUluZm8pKXtcblx0XHRcdFx0XHRcdFx0cGFja2FnZUluZm8gPSB7bmFtZTpwYWNrYWdlSW5mb307XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYWNrYWdlSW5mby5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuXHRcdFx0XHRcdFx0Zml4dXBQYWNrYWdlSW5mbyhwYWNrYWdlSW5mbyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBub3RpY2UgdGhhdCBjb21wdXRlTWFwUHJvZyB0cmVhdHMgdGhlIGRlc3QgYXMgYSByZWZlcmVuY2U7IHRoZXJlZm9yZSwgaWYvd2hlbiB0aGF0IHZhcmlhYmxlXG5cdFx0XHRcdC8vIGlzIHB1Ymxpc2hlZCAoc2VlIGRvam8tcHVibGlzaC1wcml2YXRlcyksIHRoZSBwdWJsaXNoZWQgdmFyaWFibGUgd2lsbCBhbHdheXMgaG9sZCBhIHZhbGlkIHZhbHVlLlxuXG5cdFx0XHRcdC8vIHRoaXMgbXVzdCBjb21lIGFmdGVyIGFsbCBwYWNrYWdlIHByb2Nlc3Npbmcgc2luY2UgcGFja2FnZSBwcm9jZXNzaW5nIG1heSBtdXRhdGUgbWFwXG5cdFx0XHRcdGNvbXB1dGVNYXBQcm9nKG1peChtYXAsIGNvbmZpZy5tYXApLCBtYXBQcm9ncyk7XG5cdFx0XHRcdGZvckVhY2gobWFwUHJvZ3MsIGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0XHRcdGl0ZW1bMV0gPSBjb21wdXRlTWFwUHJvZyhpdGVtWzFdLCBbXSk7XG5cdFx0XHRcdFx0aWYoaXRlbVswXT09XCIqXCIpe1xuXHRcdFx0XHRcdFx0bWFwUHJvZ3Muc3RhciA9IGl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBwdXNoIGluIGFueSBwYXRocyBhbmQgcmVjb21wdXRlIHRoZSBpbnRlcm5hbCBwYXRobWFwXG5cdFx0XHRcdGNvbXB1dGVNYXBQcm9nKG1peChwYXRocywgY29uZmlnLnBhdGhzKSwgcGF0aHNNYXBQcm9nKTtcblxuXHRcdFx0XHQvLyBhbGlhc2VzXG5cdFx0XHRcdGNvbXB1dGVBbGlhc2VzKGNvbmZpZy5hbGlhc2VzLCBhbGlhc2VzKTtcblxuXHRcdFx0XHRpZiAoISAxICkge1xuXHRcdFx0XHRcdGlmKGJvb3Rpbmcpe1xuXHRcdFx0XHRcdFx0ZGVsYXllZE1vZHVsZUNvbmZpZy5wdXNoKHtjb25maWc6Y29uZmlnLmNvbmZpZ30pO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0Zm9yKHAgaW4gY29uZmlnLmNvbmZpZyl7XG5cdFx0XHRcdFx0XHRcdHZhciBtb2R1bGUgPSBnZXRNb2R1bGUocCwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRcdFx0XHRcdFx0bW9kdWxlLmNvbmZpZyA9IG1peChtb2R1bGUuY29uZmlnIHx8IHt9LCBjb25maWcuY29uZmlnW3BdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBwdXNoIGluIGFueSBuZXcgY2FjaGUgdmFsdWVzXG5cdFx0XHRcdFx0aWYoY29uZmlnLmNhY2hlKXtcblx0XHRcdFx0XHRcdGNvbnN1bWVQZW5kaW5nQ2FjaGVJbnNlcnQoKTtcblx0XHRcdFx0XHRcdHBlbmRpbmdDYWNoZUluc2VydCA9IGNvbmZpZy5jYWNoZTtcblx0XHRcdFx0XHRcdC8vaW5qZWN0IG5vdyBhbGwgZGVwZW5jaWVzIHNvIGNhY2hlIGlzIGF2YWlsYWJsZSBmb3IgbWFwcGVkIG1vZHVsZVxuXHRcdFx0XHRcdFx0Y29uc3VtZVBlbmRpbmdDYWNoZUluc2VydCgwLCAhIWNvbmZpZy5jYWNoZVtcIipub3JlZlwiXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNpZ25hbChcImNvbmZpZ1wiLCBbY29uZmlnLCByZXEucmF3Q29uZmlnXSk7XG5cdFx0XHR9O1xuXG5cdFx0Ly9cblx0XHQvLyBleGVjdXRlIHRoZSB2YXJpb3VzIHNuaWZmczsgdXNlckNvbmZpZyBjYW4gb3ZlcnJpZGUgYW5kIHZhbHVlXG5cdFx0Ly9cblxuXHRcdGlmKCAwICB8fCAgMCApe1xuXHRcdFx0Ly8gdGhlIHNuaWZmIHJlZ2V4IGxvb2tzIGZvciBhIHNyYyBhdHRyaWJ1dGUgZW5kaW5nIGluIGRvam8uanMsIG9wdGlvbmFsbHkgcHJlY2VkZWQgd2l0aCBhIHBhdGguXG5cdFx0XHQvLyBtYXRjaFszXSByZXR1cm5zIHRoZSBwYXRoIHRvIGRvam8uanMgKGlmIGFueSkgd2l0aG91dCB0aGUgdHJhaWxpbmcgc2xhc2guIFRoaXMgaXMgdXNlZCBmb3IgdGhlXG5cdFx0XHQvLyBkb2pvIGxvY2F0aW9uIG9uIENETiBkZXBsb3ltZW50cyBhbmQgYmFzZVVybCB3aGVuIGVpdGhlci9ib3RoIG9mIHRoZXNlIGFyZSBub3QgcHJvdmlkZWRcblx0XHRcdC8vIGV4cGxpY2l0bHkgaW4gdGhlIGNvbmZpZyBkYXRhOyB0aGlzIGlzIHRoZSAxLjYtIGJlaGF2aW9yLlxuXG5cdFx0XHR2YXIgc2NyaXB0cyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdHNjcmlwdCwgZG9qb0Rpciwgc3JjLCBtYXRjaDtcblx0XHRcdHdoaWxlKGkgPCBzY3JpcHRzLmxlbmd0aCl7XG5cdFx0XHRcdHNjcmlwdCA9IHNjcmlwdHNbaSsrXTtcblx0XHRcdFx0aWYoKHNyYyA9IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJzcmNcIikpICYmIChtYXRjaCA9IHNyYy5tYXRjaCgvKCgoLiopXFwvKXxeKWRvam9cXC5qcyhcXFd8JCkvaSkpKXtcblx0XHRcdFx0XHQvLyBzbmlmZiBkb2pvRGlyIGFuZCBiYXNlVXJsXG5cdFx0XHRcdFx0ZG9qb0RpciA9IG1hdGNoWzNdIHx8IFwiXCI7XG5cdFx0XHRcdFx0ZGVmYXVsdENvbmZpZy5iYXNlVXJsID0gZGVmYXVsdENvbmZpZy5iYXNlVXJsIHx8IGRvam9EaXI7XG5cblx0XHRcdFx0XHQvLyByZW1lbWJlciBhbiBpbnNlcnRQb2ludFNpYmxpbmdcblx0XHRcdFx0XHRpbnNlcnRQb2ludFNpYmxpbmcgPSBzY3JpcHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzbmlmZiBjb25maWd1cmF0aW9uIG9uIGF0dHJpYnV0ZSBpbiBzY3JpcHQgZWxlbWVudFxuXHRcdFx0XHRpZigoc3JjID0gKHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRvam8tY29uZmlnXCIpIHx8IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJkakNvbmZpZ1wiKSkpKXtcblx0XHRcdFx0XHRkb2pvU25pZmZDb25maWcgPSByZXEuZXZhbChcIih7IFwiICsgc3JjICsgXCIgfSlcIiwgXCJkYXRhLWRvam8tY29uZmlnXCIpO1xuXG5cdFx0XHRcdFx0Ly8gcmVtZW1iZXIgYW4gaW5zZXJ0UG9pbnRTaWJsaW5nXG5cdFx0XHRcdFx0aW5zZXJ0UG9pbnRTaWJsaW5nID0gc2NyaXB0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc25pZmYgcmVxdWlyZWpzIGF0dHJpYnV0ZVxuXHRcdFx0XHRpZiggMCApe1xuXHRcdFx0XHRcdGlmKChzcmMgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tYWluXCIpKSl7XG5cdFx0XHRcdFx0XHRkb2pvU25pZmZDb25maWcuZGVwcyA9IGRvam9TbmlmZkNvbmZpZy5kZXBzIHx8IFtzcmNdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKCAwICl7XG5cdFx0XHQvLyBwYXNzIGRvd24gZG9oLnRlc3RDb25maWcgZnJvbSBwYXJlbnQgYXMgaWYgaXQgd2VyZSBhIGRhdGEtZG9qby1jb25maWdcblx0XHRcdHRyeXtcblx0XHRcdFx0aWYod2luZG93LnBhcmVudCAhPSB3aW5kb3cgJiYgd2luZG93LnBhcmVudC5yZXF1aXJlKXtcblx0XHRcdFx0XHR2YXIgZG9oID0gd2luZG93LnBhcmVudC5yZXF1aXJlKFwiZG9oXCIpO1xuXHRcdFx0XHRcdGRvaCAmJiBtaXgoZG9qb1NuaWZmQ29uZmlnLCBkb2gudGVzdENvbmZpZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1jYXRjaChlKXt9XG5cdFx0fVxuXG5cdFx0Ly8gY29uZmlndXJlIHRoZSBsb2FkZXI7IGxldCB0aGUgdXNlciBvdmVycmlkZSBkZWZhdWx0c1xuXHRcdHJlcS5yYXdDb25maWcgPSB7fTtcblx0XHRjb25maWcoZGVmYXVsdENvbmZpZywgMSk7XG5cblx0XHQvLyBkbyB0aGlzIGJlZm9yZSBzZXR0aW5nIHVzZXJDb25maWcvc25pZmZDb25maWcgdG8gYWxsb3cgdXNlckNvbmZpZy9zbmlmZiBvdmVycmlkZXNcblx0XHRpZiggMCApe1xuXHRcdFx0cGFja3MuZG9qby5sb2NhdGlvbiA9IGRvam9EaXI7XG5cdFx0XHRpZihkb2pvRGlyKXtcblx0XHRcdFx0ZG9qb0RpciArPSBcIi9cIjtcblx0XHRcdH1cblx0XHRcdHBhY2tzLmRpaml0LmxvY2F0aW9uID0gZG9qb0RpciArIFwiLi4vZGlqaXQvXCI7XG5cdFx0XHRwYWNrcy5kb2pveC5sb2NhdGlvbiA9IGRvam9EaXIgKyBcIi4uL2Rvam94L1wiO1xuXHRcdH1cblxuXHRcdGNvbmZpZyh1c2VyQ29uZmlnLCAxKTtcblx0XHRjb25maWcoZG9qb1NuaWZmQ29uZmlnLCAxKTtcblxuXHR9ZWxzZXtcblx0XHQvLyBubyBjb25maWcgQVBJLCBhc3N1bWUgZGVmYXVsdENvbmZpZyBoYXMgZXZlcnl0aGluZyB0aGUgbG9hZGVyIG5lZWRzLi4uZm9yIHRoZSBlbnRpcmUgbGlmZXRpbWUgb2YgdGhlIGFwcGxpY2F0aW9uXG5cdFx0cGF0aHMgPSBkZWZhdWx0Q29uZmlnLnBhdGhzO1xuXHRcdHBhdGhzTWFwUHJvZyA9IGRlZmF1bHRDb25maWcucGF0aHNNYXBQcm9nO1xuXHRcdHBhY2tzID0gZGVmYXVsdENvbmZpZy5wYWNrcztcblx0XHRhbGlhc2VzID0gZGVmYXVsdENvbmZpZy5hbGlhc2VzO1xuXHRcdG1hcFByb2dzID0gZGVmYXVsdENvbmZpZy5tYXBQcm9ncztcblx0XHRtb2R1bGVzID0gZGVmYXVsdENvbmZpZy5tb2R1bGVzO1xuXHRcdGNhY2hlID0gZGVmYXVsdENvbmZpZy5jYWNoZTtcblx0XHRjYWNoZUJ1c3QgPSBkZWZhdWx0Q29uZmlnLmNhY2hlQnVzdDtcblxuXHRcdC8vIHJlbWVtYmVyIHRoZSBkZWZhdWx0IGNvbmZpZyBmb3Igb3RoZXIgcHJvY2Vzc2VzIChlLmcuLCBkb2pvL2NvbmZpZylcblx0XHRyZXEucmF3Q29uZmlnID0gZGVmYXVsdENvbmZpZztcblx0fVxuXG5cblx0aWYgKCEgMSApIHtcblx0XHRpZiggMCApe1xuXHRcdFx0cmVxLmNvbWJvID0gcmVxLmNvbWJvIHx8IHthZGQ6bm9vcH07XG5cdFx0XHR2YXIgY29tYm9QZW5kaW5nID0gMCxcblx0XHRcdFx0Y29tYm9zUGVuZGluZyA9IFtdLFxuXHRcdFx0XHRjb21ib1BlbmRpbmdUaW1lciA9IG51bGw7XG5cdFx0fVxuXHRcdFxuXG5cdFx0Ly8gYnVpbGQgdGhlIGxvYWRlciBtYWNoaW5lcnkgaWF3IGNvbmZpZ3VyYXRpb24sIGluY2x1ZGluZyBoYXMgZmVhdHVyZSB0ZXN0c1xuXHRcdHZhciBpbmplY3REZXBlbmRlbmNpZXMgPSBmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFx0XHQvLyBjaGVja0NvbXBsZXRlIT0wIGhvbGRzIHRoZSBpZGxlIHNpZ25hbDsgd2UncmUgbm90IGlkbGUgaWYgd2UncmUgaW5qZWN0aW5nIGRlcGVuZGVuY2llc1xuXHRcdFx0XHRndWFyZENoZWNrQ29tcGxldGUoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRmb3JFYWNoKG1vZHVsZS5kZXBzLCBpbmplY3RNb2R1bGUpO1xuXHRcdFx0XHRcdGlmKCAwICAmJiBjb21ib1BlbmRpbmcgJiYgIWNvbWJvUGVuZGluZ1RpbWVyKXtcblx0XHRcdFx0XHRcdGNvbWJvUGVuZGluZ1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Y29tYm9QZW5kaW5nID0gMDtcblx0XHRcdFx0XHRcdFx0Y29tYm9QZW5kaW5nVGltZXIgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRyZXEuY29tYm8uZG9uZShmdW5jdGlvbihtaWRzLCB1cmwpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgb25Mb2FkQ2FsbGJhY2s9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBkZWZRIGlzIGEgdmVjdG9yIG9mIG1vZHVsZSBkZWZpbml0aW9ucyAxLXRvLTEsIG9udG8gbWlkc1xuXHRcdFx0XHRcdFx0XHRcdFx0cnVuRGVmUSgwLCBtaWRzKTtcblx0XHRcdFx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcdGNvbWJvc1BlbmRpbmcucHVzaChtaWRzKTtcblx0XHRcdFx0XHRcdFx0XHRpbmplY3RpbmdNb2R1bGUgPSBtaWRzO1xuXHRcdFx0XHRcdFx0XHRcdHJlcS5pbmplY3RVcmwodXJsLCBvbkxvYWRDYWxsYmFjaywgbWlkcyk7XG5cdFx0XHRcdFx0XHRcdFx0aW5qZWN0aW5nTW9kdWxlID0gMDtcblx0XHRcdFx0XHRcdFx0fSwgcmVxKTtcblx0XHRcdFx0XHRcdH0sIDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRjb250ZXh0UmVxdWlyZSA9IGZ1bmN0aW9uKGExLCBhMiwgYTMsIHJlZmVyZW5jZU1vZHVsZSwgY29udGV4dFJlcXVpcmUpe1xuXHRcdFx0XHR2YXIgbW9kdWxlLCBzeW50aGV0aWNNaWQ7XG5cdFx0XHRcdGlmKGlzU3RyaW5nKGExKSl7XG5cdFx0XHRcdFx0Ly8gc2lnbmF0dXJlIGlzIChtb2R1bGVJZClcblx0XHRcdFx0XHRtb2R1bGUgPSBnZXRNb2R1bGUoYTEsIHJlZmVyZW5jZU1vZHVsZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0aWYobW9kdWxlICYmIG1vZHVsZS5leGVjdXRlZCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbW9kdWxlLnJlc3VsdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhyb3cgbWFrZUVycm9yKFwidW5kZWZpbmVkTW9kdWxlXCIsIGExKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighaXNBcnJheShhMSkpe1xuXHRcdFx0XHRcdC8vIGExIGlzIGEgY29uZmlndXJhdGlvblxuXHRcdFx0XHRcdGNvbmZpZyhhMSwgMCwgcmVmZXJlbmNlTW9kdWxlKTtcblxuXHRcdFx0XHRcdC8vIGp1Z2dsZSBhcmdzOyAoYTIsIGEzKSBtYXkgYmUgKGRlcGVuZGVuY2llcywgY2FsbGJhY2spXG5cdFx0XHRcdFx0YTEgPSBhMjtcblx0XHRcdFx0XHRhMiA9IGEzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGlzQXJyYXkoYTEpKXtcblx0XHRcdFx0XHQvLyBzaWduYXR1cmUgaXMgKHJlcXVlc3RMaXN0IFssY2FsbGJhY2tdKVxuXHRcdFx0XHRcdGlmKCFhMS5sZW5ndGgpe1xuXHRcdFx0XHRcdFx0YTIgJiYgYTIoKTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdHN5bnRoZXRpY01pZCA9IFwicmVxdWlyZSpcIiArIHVpZCgpO1xuXG5cdFx0XHRcdFx0XHQvLyByZXNvbHZlIHRoZSByZXF1ZXN0IGxpc3Qgd2l0aCByZXNwZWN0IHRvIHRoZSByZWZlcmVuY2UgbW9kdWxlXG5cdFx0XHRcdFx0XHRmb3IodmFyIG1pZCwgZGVwcyA9IFtdLCBpID0gMDsgaSA8IGExLmxlbmd0aDspe1xuXHRcdFx0XHRcdFx0XHRtaWQgPSBhMVtpKytdO1xuXHRcdFx0XHRcdFx0XHRkZXBzLnB1c2goZ2V0TW9kdWxlKG1pZCwgcmVmZXJlbmNlTW9kdWxlKSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGNvbnN0cnVjdCBhIHN5bnRoZXRpYyBtb2R1bGUgdG8gY29udHJvbCBleGVjdXRpb24gb2YgdGhlIHJlcXVlc3RMaXN0LCBhbmQsIG9wdGlvbmFsbHksIGNhbGxiYWNrXG5cdFx0XHRcdFx0XHRtb2R1bGUgPSBtaXgobWFrZU1vZHVsZUluZm8oXCJcIiwgc3ludGhldGljTWlkLCAwLCBcIlwiKSwge1xuXHRcdFx0XHRcdFx0XHRpbmplY3RlZDogYXJyaXZlZCxcblx0XHRcdFx0XHRcdFx0ZGVwczogZGVwcyxcblx0XHRcdFx0XHRcdFx0ZGVmOiBhMiB8fCBub29wLFxuXHRcdFx0XHRcdFx0XHRyZXF1aXJlOiByZWZlcmVuY2VNb2R1bGUgPyByZWZlcmVuY2VNb2R1bGUucmVxdWlyZSA6IHJlcSxcblx0XHRcdFx0XHRcdFx0Z2M6IDEgLy9nYXJiYWdlIGNvbGxlY3Rcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0bW9kdWxlc1ttb2R1bGUubWlkXSA9IG1vZHVsZTtcblxuXHRcdFx0XHRcdFx0Ly8gY2hlY2tDb21wbGV0ZSE9MCBob2xkcyB0aGUgaWRsZSBzaWduYWw7IHdlJ3JlIG5vdCBpZGxlIGlmIHdlJ3JlIGluamVjdGluZyBkZXBlbmRlbmNpZXNcblx0XHRcdFx0XHRcdGluamVjdERlcGVuZGVuY2llcyhtb2R1bGUpO1xuXG5cdFx0XHRcdFx0XHQvLyB0cnkgdG8gaW1tZWRpYXRlbHkgZXhlY3V0ZVxuXHRcdFx0XHRcdFx0Ly8gaWYgYWxyZWFkeSB0cmF2ZXJzaW5nIGEgZmFjdG9yeSB0cmVlLCB0aGVuIHN0cmljdCBjYXVzZXMgY2lyY3VsYXIgZGVwZW5kZW5jeSB0byBhYm9ydCB0aGUgZXhlY3V0aW9uOyBtYXliZVxuXHRcdFx0XHRcdFx0Ly8gaXQncyBwb3NzaWJsZSB0byBleGVjdXRlIHRoaXMgcmVxdWlyZSBsYXRlciBhZnRlciB0aGUgY3VycmVudCB0cmF2ZXJzYWwgY29tcGxldGVzIGFuZCBhdm9pZCB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cblx0XHRcdFx0XHRcdC8vIC4uLmJ1dCAqYWx3YXlzKiBpbnNpc3Qgb24gaW1tZWRpYXRlIGluIHN5bmNoIG1vZGVcblx0XHRcdFx0XHRcdHZhciBzdHJpY3QgPSBjaGVja0NvbXBsZXRlR3VhcmQgJiYgbGVnYWN5TW9kZSE9c3luYztcblx0XHRcdFx0XHRcdGd1YXJkQ2hlY2tDb21wbGV0ZShmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRleGVjTW9kdWxlKG1vZHVsZSwgc3RyaWN0KTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0aWYoIW1vZHVsZS5leGVjdXRlZCl7XG5cdFx0XHRcdFx0XHRcdC8vIHNvbWUgZGVwcyB3ZXJlbid0IG9uIGJvYXJkIG9yIGNpcmN1bGFyIGRlcGVuZGVuY3kgZGV0ZWN0ZWQgYW5kIHN0cmljdDsgdGhlcmVmb3JlLCBwdXNoIGludG8gdGhlIGV4ZWNRXG5cdFx0XHRcdFx0XHRcdGV4ZWNRLnB1c2gobW9kdWxlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvbnRleHRSZXF1aXJlO1xuXHRcdFx0fSxcblxuXHRcdFx0Y3JlYXRlUmVxdWlyZSA9IGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0XHRcdGlmKCFtb2R1bGUpe1xuXHRcdFx0XHRcdHJldHVybiByZXE7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHJlc3VsdCA9IG1vZHVsZS5yZXF1aXJlO1xuXHRcdFx0XHRpZighcmVzdWx0KXtcblx0XHRcdFx0XHRyZXN1bHQgPSBmdW5jdGlvbihhMSwgYTIsIGEzKXtcblx0XHRcdFx0XHRcdHJldHVybiBjb250ZXh0UmVxdWlyZShhMSwgYTIsIGEzLCBtb2R1bGUsIHJlc3VsdCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRtb2R1bGUucmVxdWlyZSA9IG1peChyZXN1bHQsIHJlcSk7XG5cdFx0XHRcdFx0cmVzdWx0Lm1vZHVsZSA9IG1vZHVsZTtcblx0XHRcdFx0XHRyZXN1bHQudG9VcmwgPSBmdW5jdGlvbihuYW1lKXtcblx0XHRcdFx0XHRcdHJldHVybiB0b1VybChuYW1lLCBtb2R1bGUpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmVzdWx0LnRvQWJzTWlkID0gZnVuY3Rpb24obWlkKXtcblx0XHRcdFx0XHRcdHJldHVybiB0b0Fic01pZChtaWQsIG1vZHVsZSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpZiggMCApe1xuXHRcdFx0XHRcdFx0cmVzdWx0LnVuZGVmID0gZnVuY3Rpb24obWlkKXtcblx0XHRcdFx0XHRcdFx0cmVxLnVuZGVmKG1pZCwgbW9kdWxlKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCAwICl7XG5cdFx0XHRcdFx0XHRyZXN1bHQuc3luY0xvYWRObHMgPSBmdW5jdGlvbihtaWQpe1xuXHRcdFx0XHRcdFx0XHR2YXIgbmxzTW9kdWxlSW5mbyA9IGdldE1vZHVsZUluZm8obWlkLCBtb2R1bGUpLFxuXHRcdFx0XHRcdFx0XHRcdG5sc01vZHVsZSA9IG1vZHVsZXNbbmxzTW9kdWxlSW5mby5taWRdO1xuXHRcdFx0XHRcdFx0XHRpZighbmxzTW9kdWxlIHx8ICFubHNNb2R1bGUuZXhlY3V0ZWQpe1xuXHRcdFx0XHRcdFx0XHRcdGNhY2hlZCA9IGNhY2hlW25sc01vZHVsZUluZm8ubWlkXSB8fCBjYWNoZVt1cmxLZXlQcmVmaXggKyBubHNNb2R1bGVJbmZvLnVybF07XG5cdFx0XHRcdFx0XHRcdFx0aWYoY2FjaGVkKXtcblx0XHRcdFx0XHRcdFx0XHRcdGV2YWxNb2R1bGVUZXh0KGNhY2hlZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRubHNNb2R1bGUgPSBtb2R1bGVzW25sc01vZHVsZUluZm8ubWlkXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5sc01vZHVsZSAmJiBubHNNb2R1bGUuZXhlY3V0ZWQgJiYgbmxzTW9kdWxlLnJlc3VsdDtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sXG5cblx0XHQgIGV4ZWNRID1cblx0XHRcdFx0Ly8gVGhlIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IG5lZWQgdG8gYmUgZXZhbHVhdGVkLlxuXHRcdFx0XHRbXSxcblxuXHRcdFx0ZGVmUSA9XG5cdFx0XHRcdC8vIFRoZSBxdWV1ZSBvZiBkZWZpbmUgYXJndW1lbnRzIHNlbnQgdG8gbG9hZGVyLlxuXHRcdFx0XHRbXSxcblxuXHRcdFx0d2FpdGluZyA9XG5cdFx0XHRcdC8vIFRoZSBzZXQgb2YgbW9kdWxlcyB1cG9uIHdoaWNoIHRoZSBsb2FkZXIgaXMgd2FpdGluZyBmb3IgZGVmaW5pdGlvbiB0byBhcnJpdmVcblx0XHRcdFx0e30sXG5cblx0XHRcdHNldFJlcXVlc3RlZCA9IGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0XHRcdG1vZHVsZS5pbmplY3RlZCA9IHJlcXVlc3RlZDtcblx0XHRcdFx0d2FpdGluZ1ttb2R1bGUubWlkXSA9IDE7XG5cdFx0XHRcdGlmKG1vZHVsZS51cmwpe1xuXHRcdFx0XHRcdHdhaXRpbmdbbW9kdWxlLnVybF0gPSBtb2R1bGUucGFjayB8fCAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0VGltZXIoKTtcblx0XHRcdH0sXG5cblx0XHRcdHNldEFycml2ZWQgPSBmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFx0XHRtb2R1bGUuaW5qZWN0ZWQgPSBhcnJpdmVkO1xuXHRcdFx0XHRkZWxldGUgd2FpdGluZ1ttb2R1bGUubWlkXTtcblx0XHRcdFx0aWYobW9kdWxlLnVybCl7XG5cdFx0XHRcdFx0ZGVsZXRlIHdhaXRpbmdbbW9kdWxlLnVybF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoaXNFbXB0eSh3YWl0aW5nKSl7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lcigpO1xuXHRcdFx0XHRcdCAwICAmJiBsZWdhY3lNb2RlPT14ZCAmJiAobGVnYWN5TW9kZSA9IHN5bmMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRleGVjQ29tcGxldGUgPSByZXEuaWRsZSA9XG5cdFx0XHRcdC8vIHNheXMgdGhlIGxvYWRlciBoYXMgY29tcGxldGVkIChvciBub3QpIGl0cyB3b3JrXG5cdFx0XHRcdGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0cmV0dXJuICFkZWZRLmxlbmd0aCAmJiBpc0VtcHR5KHdhaXRpbmcpICYmICFleGVjUS5sZW5ndGggJiYgIWNoZWNrQ29tcGxldGVHdWFyZDtcblx0XHRcdFx0fTtcblx0fVxuXG5cdHZhciBydW5NYXBQcm9nID0gZnVuY3Rpb24odGFyZ2V0TWlkLCBtYXApe1xuXHRcdFx0Ly8gc2VhcmNoIGZvciB0YXJnZXRNaWQgaW4gbWFwOyByZXR1cm4gdGhlIG1hcCBpdGVtIGlmIGZvdW5kOyBmYWxzeSBvdGhlcndpc2Vcblx0XHRcdGlmKG1hcCl7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0aWYobWFwW2ldWzJdLnRlc3QodGFyZ2V0TWlkKSl7XG5cdFx0XHRcdFx0cmV0dXJuIG1hcFtpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fSxcblxuXHRcdGNvbXBhY3RQYXRoID0gZnVuY3Rpb24ocGF0aCl7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0XHRcdHNlZ21lbnQsIGxhc3RTZWdtZW50O1xuXHRcdFx0cGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpLnNwbGl0KCcvJyk7XG5cdFx0XHR3aGlsZShwYXRoLmxlbmd0aCl7XG5cdFx0XHRcdHNlZ21lbnQgPSBwYXRoLnNoaWZ0KCk7XG5cdFx0XHRcdGlmKHNlZ21lbnQ9PVwiLi5cIiAmJiByZXN1bHQubGVuZ3RoICYmIGxhc3RTZWdtZW50IT1cIi4uXCIpe1xuXHRcdFx0XHRcdHJlc3VsdC5wb3AoKTtcblx0XHRcdFx0XHRsYXN0U2VnbWVudCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG5cdFx0XHRcdH1lbHNlIGlmKHNlZ21lbnQhPVwiLlwiKXtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChsYXN0U2VnbWVudD0gc2VnbWVudCk7XG5cdFx0XHRcdH0gLy8gZWxzZSBpZ25vcmUgXCIuXCJcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQuam9pbihcIi9cIik7XG5cdFx0fSxcblxuXHRcdG1ha2VNb2R1bGVJbmZvID0gZnVuY3Rpb24ocGlkLCBtaWQsIHBhY2ssIHVybCl7XG5cdFx0XHRpZiggMCApe1xuXHRcdFx0XHR2YXIgeGQ9IHJlcS5pc1hkVXJsKHVybCk7XG5cdFx0XHRcdHJldHVybiB7cGlkOnBpZCwgbWlkOm1pZCwgcGFjazpwYWNrLCB1cmw6dXJsLCBleGVjdXRlZDowLCBkZWY6MCwgaXNYZDp4ZCwgaXNBbWQ6ISEoeGQgfHwgKHBhY2tzW3BpZF0gJiYgcGFja3NbcGlkXS5pc0FtZCkpfTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRyZXR1cm4ge3BpZDpwaWQsIG1pZDptaWQsIHBhY2s6cGFjaywgdXJsOnVybCwgZXhlY3V0ZWQ6MCwgZGVmOjB9O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRNb2R1bGVJbmZvXyA9IGZ1bmN0aW9uKG1pZCwgcmVmZXJlbmNlTW9kdWxlLCBwYWNrcywgbW9kdWxlcywgYmFzZVVybCwgbWFwUHJvZ3MsIHBhdGhzTWFwUHJvZywgYWxpYXNlcywgYWx3YXlzQ3JlYXRlLCBmcm9tUGVuZGluZ0NhY2hlKXtcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluc3RlYWQgb2YgdXNpbmcgbGV4aWNhbCB2YXJpYWJsZXMgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIG15IGJlIHVzZWQgaW5kZXBlbmRlbnQgb2YgdGhlIGxvYWRlciAoZS5nLiwgdGhlIGJ1aWxkZXIpXG5cdFx0XHQvLyBhbHdheXNDcmVhdGUgaXMgdXNlZnVsIGluIHRoaXMgY2FzZSBzbyB0aGF0IGdldE1vZHVsZUluZm8gbmV2ZXIgcmV0dXJucyByZWZlcmVuY2VzIHRvIHJlYWwgbW9kdWxlcyBvd25lZCBieSB0aGUgbG9hZGVyXG5cdFx0XHR2YXIgcGlkLCBwYWNrLCBtaWRJblBhY2thZ2UsIG1hcEl0ZW0sIHVybCwgcmVzdWx0LCBpc1JlbGF0aXZlLCByZXF1ZXN0ZWRNaWQ7XG5cdFx0XHRyZXF1ZXN0ZWRNaWQgPSBtaWQ7XG5cdFx0XHRpc1JlbGF0aXZlID0gL15cXC4vLnRlc3QobWlkKTtcblx0XHRcdGlmKC8oXlxcLyl8KFxcOil8KFxcLmpzJCkvLnRlc3QobWlkKSB8fCAoaXNSZWxhdGl2ZSAmJiAhcmVmZXJlbmNlTW9kdWxlKSl7XG5cdFx0XHRcdC8vIGFic29sdXRlIHBhdGggb3IgcHJvdG9jb2wgb2YgLmpzIGZpbGV0eXBlLCBvciByZWxhdGl2ZSBwYXRoIGJ1dCBubyByZWZlcmVuY2UgbW9kdWxlIGFuZCB0aGVyZWZvcmUgcmVsYXRpdmUgdG8gcGFnZVxuXHRcdFx0XHQvLyB3aGF0ZXZlciBpdCBpcywgaXQncyBub3QgYSBtb2R1bGUgYnV0IGp1c3QgYSBVUkwgb2Ygc29tZSBzb3J0XG5cdFx0XHRcdC8vIG5vdGU6IHBpZD09PTAgaW5kaWNhdGVzIHRoZSByb3V0aW5lIGlzIHJldHVybmluZyBhbiB1bm1vZGlmaWVkIG1pZFxuXG5cdFx0XHRcdHJldHVybiBtYWtlTW9kdWxlSW5mbygwLCBtaWQsIDAsIG1pZCk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gcmVsYXRpdmUgbW9kdWxlIGlkcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHJlZmVyZW5jZU1vZHVsZTsgZ2V0IHJpZCBvZiBhbnkgZG90c1xuXHRcdFx0XHRtaWQgPSBjb21wYWN0UGF0aChpc1JlbGF0aXZlID8gKHJlZmVyZW5jZU1vZHVsZS5taWQgKyBcIi8uLi9cIiArIG1pZCkgOiBtaWQpO1xuXHRcdFx0XHRpZigvXlxcLi8udGVzdChtaWQpKXtcblx0XHRcdFx0XHR0aHJvdyBtYWtlRXJyb3IoXCJpcnJhdGlvbmFsUGF0aFwiLCBtaWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGF0IHRoaXMgcG9pbnQsIG1pZCBpcyBhbiBhYnNvbHV0ZSBtaWRcblxuXHRcdFx0XHQvLyBtYXAgdGhlIG1pZFxuXHRcdFx0XHRpZighZnJvbVBlbmRpbmdDYWNoZSAmJiAhaXNSZWxhdGl2ZSAmJiBtYXBQcm9ncy5zdGFyKXtcblx0XHRcdFx0XHRtYXBJdGVtID0gcnVuTWFwUHJvZyhtaWQsIG1hcFByb2dzLnN0YXJbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFtYXBJdGVtICYmIHJlZmVyZW5jZU1vZHVsZSl7XG5cdFx0XHRcdFx0bWFwSXRlbSA9IHJ1bk1hcFByb2cocmVmZXJlbmNlTW9kdWxlLm1pZCwgbWFwUHJvZ3MpO1xuXHRcdFx0XHRcdG1hcEl0ZW0gPSBtYXBJdGVtICYmIHJ1bk1hcFByb2cobWlkLCBtYXBJdGVtWzFdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKG1hcEl0ZW0pe1xuXHRcdFx0XHRcdG1pZCA9IG1hcEl0ZW1bMV0gKyBtaWQuc3Vic3RyaW5nKG1hcEl0ZW1bM10pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRtYXRjaCA9IG1pZC5tYXRjaCgvXihbXlxcL10rKShcXC8oLispKT8kLyk7XG5cdFx0XHRcdHBpZCA9IG1hdGNoID8gbWF0Y2hbMV0gOiBcIlwiO1xuXHRcdFx0XHRpZigocGFjayA9IHBhY2tzW3BpZF0pKXtcblx0XHRcdFx0XHRtaWQgPSBwaWQgKyBcIi9cIiArIChtaWRJblBhY2thZ2UgPSAobWF0Y2hbM10gfHwgcGFjay5tYWluKSk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHBpZCA9IFwiXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzZWFyY2ggYWxpYXNlc1xuXHRcdFx0XHR2YXIgY2FuZGlkYXRlTGVuZ3RoID0gMCxcblx0XHRcdFx0XHRjYW5kaWRhdGUgPSAwO1xuXHRcdFx0XHRmb3JFYWNoKGFsaWFzZXMsIGZ1bmN0aW9uKHBhaXIpe1xuXHRcdFx0XHRcdHZhciBtYXRjaCA9IG1pZC5tYXRjaChwYWlyWzBdKTtcblx0XHRcdFx0XHRpZihtYXRjaCAmJiBtYXRjaC5sZW5ndGg+Y2FuZGlkYXRlTGVuZ3RoKXtcblx0XHRcdFx0XHRcdGNhbmRpZGF0ZSA9IGlzRnVuY3Rpb24ocGFpclsxXSkgPyBtaWQucmVwbGFjZShwYWlyWzBdLCBwYWlyWzFdKSA6IHBhaXJbMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0aWYoY2FuZGlkYXRlKXtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0TW9kdWxlSW5mb18oY2FuZGlkYXRlLCAwLCBwYWNrcywgbW9kdWxlcywgYmFzZVVybCwgbWFwUHJvZ3MsIHBhdGhzTWFwUHJvZywgYWxpYXNlcywgYWx3YXlzQ3JlYXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCA9IG1vZHVsZXNbbWlkXTtcblx0XHRcdFx0aWYocmVzdWx0KXtcblx0XHRcdFx0XHRyZXR1cm4gYWx3YXlzQ3JlYXRlID8gbWFrZU1vZHVsZUluZm8ocmVzdWx0LnBpZCwgcmVzdWx0Lm1pZCwgcmVzdWx0LnBhY2ssIHJlc3VsdC51cmwpIDogbW9kdWxlc1ttaWRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBnZXQgaGVyZSBpZmYgdGhlIHNvdWdodC1hZnRlciBtb2R1bGUgZG9lcyBub3QgeWV0IGV4aXN0OyB0aGVyZWZvcmUsIHdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgVVJMIGdpdmVuIHRoZVxuXHRcdFx0Ly8gZnVsbHkgcmVzb2x2ZWQgKGkuZS4sIGFsbCByZWxhdGl2ZSBpbmRpY2F0b3JzIGFuZCBwYWNrYWdlIG1hcHBpbmcgcmVzb2x2ZWQpIG1vZHVsZSBpZFxuXG5cdFx0XHQvLyBub3RlOiBwaWQhPT0wIGluZGljYXRlcyB0aGUgcm91dGluZSBpcyByZXR1cm5pbmcgYSB1cmwgdGhhdCBoYXMgLmpzIGFwcGVuZGVkIHVubW9kaWZpZWQgbWlkXG5cdFx0XHRtYXBJdGVtID0gcnVuTWFwUHJvZyhtaWQsIHBhdGhzTWFwUHJvZyk7XG5cdFx0XHRpZihtYXBJdGVtKXtcblx0XHRcdFx0dXJsID0gbWFwSXRlbVsxXSArIG1pZC5zdWJzdHJpbmcobWFwSXRlbVszXSk7XG5cdFx0XHR9ZWxzZSBpZihwaWQpe1xuXHRcdFx0XHR1cmwgPSAocGFjay5sb2NhdGlvbi5zbGljZSgtMSkgPT09ICcvJyA/IHBhY2subG9jYXRpb24uc2xpY2UoMCwgLTEpIDogcGFjay5sb2NhdGlvbikgKyBcIi9cIiArIG1pZEluUGFja2FnZTtcblx0XHRcdH1lbHNlIGlmKCAwICl7XG5cdFx0XHRcdHVybCA9IFwiLi4vXCIgKyBtaWQ7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0dXJsID0gbWlkO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgcmVzdWx0IGlzIG5vdCBhYnNvbHV0ZSwgYWRkIGJhc2VVcmxcblx0XHRcdGlmKCEoLyheXFwvKXwoXFw6KS8udGVzdCh1cmwpKSl7XG5cdFx0XHRcdHVybCA9IGJhc2VVcmwgKyB1cmw7XG5cdFx0XHR9XG5cdFx0XHR1cmwgKz0gXCIuanNcIjtcblx0XHRcdHJldHVybiBtYWtlTW9kdWxlSW5mbyhwaWQsIG1pZCwgcGFjaywgY29tcGFjdFBhdGgodXJsKSk7XG5cdFx0fSxcblxuXHRcdGdldE1vZHVsZUluZm8gPSBmdW5jdGlvbihtaWQsIHJlZmVyZW5jZU1vZHVsZSwgZnJvbVBlbmRpbmdDYWNoZSl7XG5cdFx0XHRyZXR1cm4gZ2V0TW9kdWxlSW5mb18obWlkLCByZWZlcmVuY2VNb2R1bGUsIHBhY2tzLCBtb2R1bGVzLCByZXEuYmFzZVVybCwgbWFwUHJvZ3MsIHBhdGhzTWFwUHJvZywgYWxpYXNlcywgdW5kZWZpbmVkLCBmcm9tUGVuZGluZ0NhY2hlKTtcblx0XHR9O1xuXG5cdGlmICghIDEgKSB7XG5cdFx0dmFyIHJlc29sdmVQbHVnaW5SZXNvdXJjZUlkID0gZnVuY3Rpb24ocGx1Z2luLCBwcmlkLCByZWZlcmVuY2VNb2R1bGUpe1xuXHRcdFx0XHRyZXR1cm4gcGx1Z2luLm5vcm1hbGl6ZSA/IHBsdWdpbi5ub3JtYWxpemUocHJpZCwgZnVuY3Rpb24obWlkKXtyZXR1cm4gdG9BYnNNaWQobWlkLCByZWZlcmVuY2VNb2R1bGUpO30pIDogdG9BYnNNaWQocHJpZCwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRcdH0sXG5cblx0XHRcdGR5bmFtaWNQbHVnaW5VaWRHZW5lcmF0b3IgPSAwLFxuXG5cdFx0XHRnZXRNb2R1bGUgPSBmdW5jdGlvbihtaWQsIHJlZmVyZW5jZU1vZHVsZSwgaW1tZWRpYXRlKXtcblx0XHRcdFx0Ly8gY29tcHV0ZSBhbmQgb3B0aW9uYWxseSBjb25zdHJ1Y3QgKGlmIG5lY2Vzc2FyeSkgdGhlIG1vZHVsZSBpbXBsaWVkIGJ5IHRoZSBtaWQgd2l0aCByZXNwZWN0IHRvIHJlZmVyZW5jZU1vZHVsZVxuXHRcdFx0XHR2YXIgbWF0Y2gsIHBsdWdpbiwgcHJpZCwgcmVzdWx0O1xuXHRcdFx0XHRtYXRjaCA9IG1pZC5tYXRjaCgvXiguKz8pXFwhKC4qKSQvKTtcblx0XHRcdFx0aWYobWF0Y2gpe1xuXHRcdFx0XHRcdC8vIG5hbWUgd2FzIDxwbHVnaW4tbW9kdWxlPiE8cGx1Z2luLXJlc291cmNlLWlkPlxuXHRcdFx0XHRcdHBsdWdpbiA9IGdldE1vZHVsZShtYXRjaFsxXSwgcmVmZXJlbmNlTW9kdWxlLCBpbW1lZGlhdGUpO1xuXG5cdFx0XHRcdFx0aWYoIDAgICYmIGxlZ2FjeU1vZGUgPT0gc3luYyAmJiAhcGx1Z2luLmV4ZWN1dGVkKXtcblx0XHRcdFx0XHRcdGluamVjdE1vZHVsZShwbHVnaW4pO1xuXHRcdFx0XHRcdFx0aWYocGx1Z2luLmluamVjdGVkPT09YXJyaXZlZCAmJiAhcGx1Z2luLmV4ZWN1dGVkKXtcblx0XHRcdFx0XHRcdFx0Z3VhcmRDaGVja0NvbXBsZXRlKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0ZXhlY01vZHVsZShwbHVnaW4pO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKHBsdWdpbi5leGVjdXRlZCl7XG5cdFx0XHRcdFx0XHRcdHByb21vdGVNb2R1bGVUb1BsdWdpbihwbHVnaW4pO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdC8vIHdlIGFyZSBpbiB4ZG9tYWluIG1vZGUgZm9yIHNvbWUgcmVhc29uXG5cdFx0XHRcdFx0XHRcdGV4ZWNRLnVuc2hpZnQocGx1Z2luKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblxuXG5cdFx0XHRcdFx0aWYocGx1Z2luLmV4ZWN1dGVkID09PSBleGVjdXRlZCAmJiAhcGx1Z2luLmxvYWQpe1xuXHRcdFx0XHRcdFx0Ly8gZXhlY3V0ZWQgdGhlIG1vZHVsZSBub3Qga25vd2luZyBpdCB3YXMgYSBwbHVnaW5cblx0XHRcdFx0XHRcdHByb21vdGVNb2R1bGVUb1BsdWdpbihwbHVnaW4pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBwbHVnaW4gaGFzIG5vdCBiZWVuIGxvYWRlZCwgdGhlbiBjYW4ndCByZXNvbHZlIHRoZSBwcmlkIGFuZCAgbXVzdCBhc3N1bWUgdGhpcyBwbHVnaW4gaXMgZHluYW1pYyB1bnRpbCB3ZSBmaW5kIG91dCBvdGhlcndpc2Vcblx0XHRcdFx0XHRpZihwbHVnaW4ubG9hZCl7XG5cdFx0XHRcdFx0XHRwcmlkID0gcmVzb2x2ZVBsdWdpblJlc291cmNlSWQocGx1Z2luLCBtYXRjaFsyXSwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRcdFx0XHRcdG1pZCA9IChwbHVnaW4ubWlkICsgXCIhXCIgKyAocGx1Z2luLmR5bmFtaWMgPyArK2R5bmFtaWNQbHVnaW5VaWRHZW5lcmF0b3IgKyBcIiFcIiA6IFwiXCIpICsgcHJpZCk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRwcmlkID0gbWF0Y2hbMl07XG5cdFx0XHRcdFx0XHRtaWQgPSBwbHVnaW4ubWlkICsgXCIhXCIgKyAoKytkeW5hbWljUGx1Z2luVWlkR2VuZXJhdG9yKSArIFwiIXdhaXRpbmdGb3JQbHVnaW5cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ID0ge3BsdWdpbjpwbHVnaW4sIG1pZDptaWQsIHJlcTpjcmVhdGVSZXF1aXJlKHJlZmVyZW5jZU1vZHVsZSksIHByaWQ6cHJpZH07XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHJlc3VsdCA9IGdldE1vZHVsZUluZm8obWlkLCByZWZlcmVuY2VNb2R1bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtb2R1bGVzW3Jlc3VsdC5taWRdIHx8ICghaW1tZWRpYXRlICYmIChtb2R1bGVzW3Jlc3VsdC5taWRdID0gcmVzdWx0KSk7XG5cdFx0XHR9O1xuXHR9XG5cblx0dmFyIHRvQWJzTWlkID0gcmVxLnRvQWJzTWlkID0gZnVuY3Rpb24obWlkLCByZWZlcmVuY2VNb2R1bGUpe1xuXHRcdFx0cmV0dXJuIGdldE1vZHVsZUluZm8obWlkLCByZWZlcmVuY2VNb2R1bGUpLm1pZDtcblx0XHR9LFxuXG5cdFx0dG9VcmwgPSByZXEudG9VcmwgPSBmdW5jdGlvbihuYW1lLCByZWZlcmVuY2VNb2R1bGUpe1xuXHRcdFx0dmFyIG1vZHVsZUluZm8gPSBnZXRNb2R1bGVJbmZvKG5hbWUrXCIveFwiLCByZWZlcmVuY2VNb2R1bGUpLFxuXHRcdFx0XHR1cmw9IG1vZHVsZUluZm8udXJsO1xuXHRcdFx0cmV0dXJuIGZpeHVwVXJsKG1vZHVsZUluZm8ucGlkPT09MCA/XG5cdFx0XHRcdC8vIGlmIHBpZD09PTAsIHRoZW4gbmFtZSBoYWQgYSBwcm90b2NvbCBvciBhYnNvbHV0ZSBwYXRoOyBlaXRoZXIgd2F5LCB0b1VybCBpcyB0aGUgaWRlbnRpZnkgZnVuY3Rpb24gaW4gc3VjaCBjYXNlc1xuXHRcdFx0XHRuYW1lIDpcblx0XHRcdFx0Ly8gXCIveC5qc1wiIHNpbmNlIGdldE1vZHVsZUluZm8gYXV0b21hdGljYWxseSBhcHBlbmRzIFwiLmpzXCIgYW5kIHdlIGFwcGVuZGVkIFwiL3hcIiB0byBtYWtlIG5hbWUgbG9vayBsaWtlIGEgbW9kdWxlIGlkXG5cdFx0XHRcdHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aC01KVxuXHRcdFx0KTtcblx0XHR9O1xuXG5cdGlmICghIDEgKSB7XG5cdFx0dmFyIG5vbk1vZHVsZVByb3BzID0ge1xuXHRcdFx0XHRpbmplY3RlZDogYXJyaXZlZCxcblx0XHRcdFx0ZXhlY3V0ZWQ6IGV4ZWN1dGVkLFxuXHRcdFx0XHRkZWY6IG5vbm1vZHVsZSxcblx0XHRcdFx0cmVzdWx0OiBub25tb2R1bGVcblx0XHRcdH0sXG5cblx0XHRcdG1ha2VDanMgPSBmdW5jdGlvbihtaWQpe1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlc1ttaWRdID0gbWl4KHttaWQ6bWlkfSwgbm9uTW9kdWxlUHJvcHMpO1xuXHRcdFx0fSxcblxuXHRcdFx0Y2pzUmVxdWlyZU1vZHVsZSA9IG1ha2VDanMoXCJyZXF1aXJlXCIpLFxuXHRcdFx0Y2pzRXhwb3J0c01vZHVsZSA9IG1ha2VDanMoXCJleHBvcnRzXCIpLFxuXHRcdFx0Y2pzTW9kdWxlTW9kdWxlID0gbWFrZUNqcyhcIm1vZHVsZVwiKSxcblxuXHRcdFx0cnVuRmFjdG9yeSA9IGZ1bmN0aW9uKG1vZHVsZSwgYXJncyl7XG5cdFx0XHRcdHJlcS50cmFjZShcImxvYWRlci1ydW4tZmFjdG9yeVwiLCBbbW9kdWxlLm1pZF0pO1xuXHRcdFx0XHR2YXIgZmFjdG9yeSA9IG1vZHVsZS5kZWYsXG5cdFx0XHRcdFx0cmVzdWx0O1xuXHRcdFx0XHQgMCAgJiYgc3luY0V4ZWNTdGFjay51bnNoaWZ0KG1vZHVsZSk7XG5cdFx0XHRcdGlmKCAwICl7XG5cdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0cmVzdWx0PSBpc0Z1bmN0aW9uKGZhY3RvcnkpID8gZmFjdG9yeS5hcHBseShudWxsLCBhcmdzKSA6IGZhY3Rvcnk7XG5cdFx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRcdFx0c2lnbmFsKGVycm9yLCBtb2R1bGUucmVzdWx0ID0gbWFrZUVycm9yKFwiZmFjdG9yeVRocmV3XCIsIFttb2R1bGUsIGVdKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRyZXN1bHQ9IGlzRnVuY3Rpb24oZmFjdG9yeSkgPyBmYWN0b3J5LmFwcGx5KG51bGwsIGFyZ3MpIDogZmFjdG9yeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtb2R1bGUucmVzdWx0ID0gcmVzdWx0PT09dW5kZWZpbmVkICYmIG1vZHVsZS5janMgPyBtb2R1bGUuY2pzLmV4cG9ydHMgOiByZXN1bHQ7XG5cdFx0XHRcdCAwICAmJiBzeW5jRXhlY1N0YWNrLnNoaWZ0KG1vZHVsZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydEV4ZWMgPSB7fSxcblxuXHRcdFx0ZGVmT3JkZXIgPSAwLFxuXG5cdFx0XHRwcm9tb3RlTW9kdWxlVG9QbHVnaW4gPSBmdW5jdGlvbihwbHVnaW5Nb2R1bGUpe1xuXHRcdFx0XHR2YXIgcGx1Z2luID0gcGx1Z2luTW9kdWxlLnJlc3VsdDtcblx0XHRcdFx0cGx1Z2luTW9kdWxlLmR5bmFtaWMgPSBwbHVnaW4uZHluYW1pYztcblx0XHRcdFx0cGx1Z2luTW9kdWxlLm5vcm1hbGl6ZSA9IHBsdWdpbi5ub3JtYWxpemU7XG5cdFx0XHRcdHBsdWdpbk1vZHVsZS5sb2FkID0gcGx1Z2luLmxvYWQ7XG5cdFx0XHRcdHJldHVybiBwbHVnaW5Nb2R1bGU7XG5cdFx0XHR9LFxuXG5cdFx0XHRyZXNvbHZlUGx1Z2luTG9hZFEgPSBmdW5jdGlvbihwbHVnaW4pe1xuXHRcdFx0XHQvLyBwbHVnaW5zIGlzIGEgbmV3bHkgZXhlY3V0ZWQgbW9kdWxlIHRoYXQgaGFzIGEgbG9hZFEgd2FpdGluZyB0byBydW5cblxuXHRcdFx0XHQvLyBzdGVwIDE6IHRyYXZlcnNlIHRoZSBsb2FkUSBhbmQgZml4dXAgdGhlIG1pZCBhbmQgcHJpZDsgcmVtZW1iZXIgdGhlIG1hcCBmcm9tIG9yaWdpbmFsIG1pZCB0byBuZXcgbWlkXG5cdFx0XHRcdC8vIHJlY2FsbCB0aGUgb3JpZ2luYWwgbWlkIHdhcyBjcmVhdGVkIGJlZm9yZSB0aGUgcGx1Z2luIHdhcyBvbiBib2FyZCBhbmQgdGhlcmVmb3JlIGl0IHdhcyBpbXBvc3NpYmxlIHRvXG5cdFx0XHRcdC8vIGNvbXB1dGUgdGhlIGZpbmFsIG1pZDsgYWNjb3JkaW5nbHksIHByaWQgbWF5IG9yIG1heSBub3QgY2hhbmdlLCBidXQgdGhlIG1pZCB3aWxsIGRlZmluaXRlbHkgY2hhbmdlXG5cdFx0XHRcdHZhciBtYXAgPSB7fTtcblx0XHRcdFx0Zm9yRWFjaChwbHVnaW4ubG9hZFEsIGZ1bmN0aW9uKHBzZXVkb1BsdWdpblJlc291cmNlKXtcblx0XHRcdFx0XHQvLyBtYW51ZmFjdHVyZSBhbmQgaW5zZXJ0IHRoZSByZWFsIG1vZHVsZSBpbiBtb2R1bGVzXG5cdFx0XHRcdFx0dmFyIHByaWQgPSByZXNvbHZlUGx1Z2luUmVzb3VyY2VJZChwbHVnaW4sIHBzZXVkb1BsdWdpblJlc291cmNlLnByaWQsIHBzZXVkb1BsdWdpblJlc291cmNlLnJlcS5tb2R1bGUpLFxuXHRcdFx0XHRcdFx0bWlkID0gcGx1Z2luLmR5bmFtaWMgPyBwc2V1ZG9QbHVnaW5SZXNvdXJjZS5taWQucmVwbGFjZSgvd2FpdGluZ0ZvclBsdWdpbiQvLCBwcmlkKSA6IChwbHVnaW4ubWlkICsgXCIhXCIgKyBwcmlkKSxcblx0XHRcdFx0XHRcdHBsdWdpblJlc291cmNlID0gbWl4KG1peCh7fSwgcHNldWRvUGx1Z2luUmVzb3VyY2UpLCB7bWlkOm1pZCwgcHJpZDpwcmlkLCBpbmplY3RlZDowfSk7XG5cdFx0XHRcdFx0aWYoIW1vZHVsZXNbbWlkXSB8fCAhbW9kdWxlc1ttaWRdLmluamVjdGVkIC8qZm9yIHJlcXVpcmUudW5kZWYqLyl7XG5cdFx0XHRcdFx0XHQvLyBjcmVhdGUgYSBuZXcgKHRoZSByZWFsKSBwbHVnaW4gcmVzb3VyY2UgYW5kIGluamVjdCBpdCBub3JtYWxseSBub3cgdGhhdCB0aGUgcGx1Z2luIGlzIG9uIGJvYXJkXG5cdFx0XHRcdFx0XHRpbmplY3RQbHVnaW4obW9kdWxlc1ttaWRdID0gcGx1Z2luUmVzb3VyY2UpO1xuXHRcdFx0XHRcdH0gLy8gZWxzZSB0aGlzIHdhcyBhIGR1cGxpY2F0ZSByZXF1ZXN0IGZvciB0aGUgc2FtZSAocGx1Z2luLCByaWQpIGZvciBhIG5vbmR5bmFtaWMgcGx1Z2luXG5cblx0XHRcdFx0XHQvLyBwbHVnaW5SZXNvdXJjZSBpcyByZWFsbHkganVzdCBhIHBsYWNlaG9sZGVyIHdpdGggdGhlIHdyb25nIG1pZCAoYmVjYXVzZSB3ZSBjb3VsZG4ndCBjYWxjdWxhdGUgaXQgdW50aWwgdGhlIHBsdWdpbiB3YXMgb24gYm9hcmQpXG5cdFx0XHRcdFx0Ly8gbWFyayBpcyBhcyBhcnJpdmVkIGFuZCBkZWxldGUgaXQgZnJvbSBtb2R1bGVzOyB0aGUgcmVhbCBtb2R1bGUgd2FzIHJlcXVlc3RlZCBhYm92ZVxuXHRcdFx0XHRcdG1hcFtwc2V1ZG9QbHVnaW5SZXNvdXJjZS5taWRdID0gbW9kdWxlc1ttaWRdO1xuXHRcdFx0XHRcdHNldEFycml2ZWQocHNldWRvUGx1Z2luUmVzb3VyY2UpO1xuXHRcdFx0XHRcdGRlbGV0ZSBtb2R1bGVzW3BzZXVkb1BsdWdpblJlc291cmNlLm1pZF07XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRwbHVnaW4ubG9hZFEgPSAwO1xuXG5cdFx0XHRcdC8vIHN0ZXAyOiByZXBsYWNlIGFsbCByZWZlcmVuY2VzIHRvIGFueSBwbGFjZWhvbGRlciBtb2R1bGVzIHdpdGggcmVhbCBtb2R1bGVzXG5cdFx0XHRcdHZhciBzdWJzdGl0dXRlTW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0XHRcdFx0Zm9yKHZhciByZXBsYWNlbWVudCwgZGVwcyA9IG1vZHVsZS5kZXBzIHx8IFtdLCBpID0gMDsgaTxkZXBzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRcdHJlcGxhY2VtZW50ID0gbWFwW2RlcHNbaV0ubWlkXTtcblx0XHRcdFx0XHRcdGlmKHJlcGxhY2VtZW50KXtcblx0XHRcdFx0XHRcdFx0ZGVwc1tpXSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0Zm9yKHZhciBwIGluIG1vZHVsZXMpe1xuXHRcdFx0XHRcdHN1YnN0aXR1dGVNb2R1bGVzKG1vZHVsZXNbcF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvckVhY2goZXhlY1EsIHN1YnN0aXR1dGVNb2R1bGVzKTtcblx0XHRcdH0sXG5cblx0XHRcdGZpbmlzaEV4ZWMgPSBmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFx0XHRyZXEudHJhY2UoXCJsb2FkZXItZmluaXNoLWV4ZWNcIiwgW21vZHVsZS5taWRdKTtcblx0XHRcdFx0bW9kdWxlLmV4ZWN1dGVkID0gZXhlY3V0ZWQ7XG5cdFx0XHRcdG1vZHVsZS5kZWZPcmRlciA9IGRlZk9yZGVyKys7XG5cdFx0XHRcdCAwICAmJiBmb3JFYWNoKG1vZHVsZS5wcm92aWRlcywgZnVuY3Rpb24oY2IpeyBjYigpOyB9KTtcblx0XHRcdFx0aWYobW9kdWxlLmxvYWRRKXtcblx0XHRcdFx0XHQvLyB0aGUgbW9kdWxlIHdhcyBhIHBsdWdpblxuXHRcdFx0XHRcdHByb21vdGVNb2R1bGVUb1BsdWdpbihtb2R1bGUpO1xuXHRcdFx0XHRcdHJlc29sdmVQbHVnaW5Mb2FkUShtb2R1bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgb2NjdXJyZW5jZXMgb2YgdGhpcyBtb2R1bGUgZnJvbSB0aGUgZXhlY1Fcblx0XHRcdFx0Zm9yKGkgPSAwOyBpIDwgZXhlY1EubGVuZ3RoOyl7XG5cdFx0XHRcdFx0aWYoZXhlY1FbaV0gPT09IG1vZHVsZSl7XG5cdFx0XHRcdFx0XHRleGVjUS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGRlbGV0ZSByZWZlcmVuY2VzIHRvIHN5bnRoZXRpYyBtb2R1bGVzXG5cdFx0XHRcdGlmICgvXnJlcXVpcmVcXCovLnRlc3QobW9kdWxlLm1pZCkpIHtcblx0XHRcdFx0XHRkZWxldGUgbW9kdWxlc1ttb2R1bGUubWlkXTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Y2lyY2xlVHJhY2UgPSBbXSxcblxuXHRcdFx0ZXhlY01vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSwgc3RyaWN0KXtcblx0XHRcdFx0Ly8gcnVuIHRoZSBkZXBlbmRlbmN5IHZlY3RvciwgdGhlbiBydW4gdGhlIGZhY3RvcnkgZm9yIG1vZHVsZVxuXHRcdFx0XHRpZihtb2R1bGUuZXhlY3V0ZWQgPT09IGV4ZWN1dGluZyl7XG5cdFx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWNpcmN1bGFyLWRlcGVuZGVuY3lcIiwgW2NpcmNsZVRyYWNlLmNvbmNhdChtb2R1bGUubWlkKS5qb2luKFwiLT5cIildKTtcblx0XHRcdFx0XHRyZXR1cm4gKCFtb2R1bGUuZGVmIHx8IHN0cmljdCkgPyBhYm9ydEV4ZWMgOiAgKG1vZHVsZS5janMgJiYgbW9kdWxlLmNqcy5leHBvcnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBhdCB0aGlzIHBvaW50IHRoZSBtb2R1bGUgaXMgZWl0aGVyIG5vdCBleGVjdXRlZCBvciBmdWxseSBleGVjdXRlZFxuXG5cblx0XHRcdFx0aWYoIW1vZHVsZS5leGVjdXRlZCl7XG5cdFx0XHRcdFx0aWYoIW1vZHVsZS5kZWYpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIGFib3J0RXhlYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIG1pZCA9IG1vZHVsZS5taWQsXG5cdFx0XHRcdFx0XHRkZXBzID0gbW9kdWxlLmRlcHMgfHwgW10sXG5cdFx0XHRcdFx0XHRhcmcsIGFyZ1Jlc3VsdCxcblx0XHRcdFx0XHRcdGFyZ3MgPSBbXSxcblx0XHRcdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHRcdGNpcmNsZVRyYWNlLnB1c2gobWlkKTtcblx0XHRcdFx0XHRcdHJlcS50cmFjZShcImxvYWRlci1leGVjLW1vZHVsZVwiLCBbXCJleGVjXCIsIGNpcmNsZVRyYWNlLmxlbmd0aCwgbWlkXSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZm9yIGNpcmN1bGFyIGRlcGVuZGVuY2llcywgYXNzdW1lIHRoZSBmaXJzdCBtb2R1bGUgZW5jb3VudGVyZWQgd2FzIGV4ZWN1dGVkIE9LXG5cdFx0XHRcdFx0Ly8gbW9kdWxlcyB0aGF0IGNpcmN1bGFybHkgZGVwZW5kIG9uIGEgbW9kdWxlIHRoYXQgaGFzIG5vdCBydW4gaXRzIGZhY3Rvcnkgd2lsbCBnZXRcblx0XHRcdFx0XHQvLyB0aGUgcHJlLW1hZGUgY2pzLmV4cG9ydHM9PT1tb2R1bGUucmVzdWx0LiBUaGV5IGNhbiB0YWtlIGEgcmVmZXJlbmNlIHRvIHRoaXMgb2JqZWN0IGFuZC9vclxuXHRcdFx0XHRcdC8vIGFkZCBwcm9wZXJ0aWVzIHRvIGl0LiBXaGVuIHRoZSBtb2R1bGUgZmluYWxseSBydW5zIGl0cyBmYWN0b3J5LCB0aGUgZmFjdG9yeSBjYW5cblx0XHRcdFx0XHQvLyByZWFkL3dyaXRlL3JlcGxhY2UgdGhpcyBvYmplY3QuIE5vdGljZSB0aGF0IHNvIGxvbmcgYXMgdGhlIG9iamVjdCBpc24ndCByZXBsYWNlZCwgYW55XG5cdFx0XHRcdFx0Ly8gcmVmZXJlbmNlIHRha2VuIGVhcmxpZXIgd2hpbGUgd2Fsa2luZyB0aGUgZGVwcyBsaXN0IGlzIHN0aWxsIHZhbGlkLlxuXHRcdFx0XHRcdG1vZHVsZS5leGVjdXRlZCA9IGV4ZWN1dGluZztcblx0XHRcdFx0XHR3aGlsZSgoYXJnID0gZGVwc1tpKytdKSl7XG5cdFx0XHRcdFx0XHRhcmdSZXN1bHQgPSAoKGFyZyA9PT0gY2pzUmVxdWlyZU1vZHVsZSkgPyBjcmVhdGVSZXF1aXJlKG1vZHVsZSkgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoKGFyZyA9PT0gY2pzRXhwb3J0c01vZHVsZSkgPyBtb2R1bGUuY2pzLmV4cG9ydHMgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCgoYXJnID09PSBjanNNb2R1bGVNb2R1bGUpID8gbW9kdWxlLmNqcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRleGVjTW9kdWxlKGFyZywgc3RyaWN0KSkpKTtcblx0XHRcdFx0XHRcdGlmKGFyZ1Jlc3VsdCA9PT0gYWJvcnRFeGVjKXtcblx0XHRcdFx0XHRcdFx0bW9kdWxlLmV4ZWN1dGVkID0gMDtcblx0XHRcdFx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWV4ZWMtbW9kdWxlXCIsIFtcImFib3J0XCIsIG1pZF0pO1xuXHRcdFx0XHRcdFx0XHQgMCAgJiYgY2lyY2xlVHJhY2UucG9wKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBhYm9ydEV4ZWM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhcmdzLnB1c2goYXJnUmVzdWx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cnVuRmFjdG9yeShtb2R1bGUsIGFyZ3MpO1xuXHRcdFx0XHRcdGZpbmlzaEV4ZWMobW9kdWxlKTtcblx0XHRcdFx0XHQgMCAgJiYgY2lyY2xlVHJhY2UucG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYXQgdGhpcyBwb2ludCB0aGUgbW9kdWxlIGlzIGd1YXJhbnRlZWQgZnVsbHkgZXhlY3V0ZWRcblxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLnJlc3VsdDtcblx0XHRcdH0sXG5cblxuXHRcdFx0Y2hlY2tDb21wbGV0ZUd1YXJkID0gMCxcblxuXHRcdFx0Z3VhcmRDaGVja0NvbXBsZXRlID0gZnVuY3Rpb24ocHJvYyl7XG5cdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRjaGVja0NvbXBsZXRlR3VhcmQrKztcblx0XHRcdFx0XHRwcm9jKCk7XG5cdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHQvLyBodHRwczovL2J1Z3MuZG9qb3Rvb2xraXQub3JnL3RpY2tldC8xNjYxN1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1maW5hbGx5e1xuXHRcdFx0XHRcdGNoZWNrQ29tcGxldGVHdWFyZC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGV4ZWNDb21wbGV0ZSgpKXtcblx0XHRcdFx0XHRzaWduYWwoXCJpZGxlXCIsIFtdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Y2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdC8vIGtlZXAgZ29pbmcgdGhyb3VnaCB0aGUgZXhlY1EgYXMgbG9uZyBhcyBhdCBsZWFzdCBvbmUgZmFjdG9yeSBpcyBleGVjdXRlZFxuXHRcdFx0XHQvLyBwbHVnaW5zLCByZWN1cnNpb24sIGNhY2hlZCBtb2R1bGVzIGFsbCBtYWtlIGZvciBtYW55IGV4ZWN1dGlvbiBwYXRoIHBvc3NpYmlsaXRpZXNcblx0XHRcdFx0aWYoY2hlY2tDb21wbGV0ZUd1YXJkKXtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Z3VhcmRDaGVja0NvbXBsZXRlKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0Y2hlY2tEb2pvUmVxdWlyZVBsdWdpbigpO1xuXHRcdFx0XHRcdGZvcih2YXIgY3VycmVudERlZk9yZGVyLCBtb2R1bGUsIGkgPSAwOyBpIDwgZXhlY1EubGVuZ3RoOyl7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVmT3JkZXIgPSBkZWZPcmRlcjtcblx0XHRcdFx0XHRcdG1vZHVsZSA9IGV4ZWNRW2ldO1xuXHRcdFx0XHRcdFx0ZXhlY01vZHVsZShtb2R1bGUpO1xuXHRcdFx0XHRcdFx0aWYoY3VycmVudERlZk9yZGVyIT1kZWZPcmRlcil7XG5cdFx0XHRcdFx0XHRcdC8vIGRlZk9yZGVyIHdhcyBidW1wZWQgb25lIG9yIG1vcmUgdGltZXMgaW5kaWNhdGluZyBzb21ldGhpbmcgd2FzIGV4ZWN1dGVkIChub3RlLCB0aGlzIGluZGljYXRlc1xuXHRcdFx0XHRcdFx0XHQvLyB0aGUgZXhlY1Egd2FzIG1vZGlmaWVkLCBtYXliZSBhIGxvdCAoZm9yIGV4YW1wbGUgYSBsYXRlciBtb2R1bGUgY2F1c2VzIGFuIGVhcmxpZXIgbW9kdWxlIHRvIGV4ZWN1dGUpXG5cdFx0XHRcdFx0XHRcdGNoZWNrRG9qb1JlcXVpcmVQbHVnaW4oKTtcblx0XHRcdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0Ly8gbm90aGluZyBoYXBwZW5lZDsgY2hlY2sgdGhlIG5leHQgbW9kdWxlIGluIHRoZSBleGVjIHF1ZXVlXG5cdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblx0fVxuXG5cdHZhciBmaXh1cFVybD0gdHlwZW9mIHVzZXJDb25maWcuZml4dXBVcmwgPT0gXCJmdW5jdGlvblwiID8gdXNlckNvbmZpZy5maXh1cFVybCA6IGZ1bmN0aW9uKHVybCl7XG5cdFx0XHR1cmwgKz0gXCJcIjsgLy8gbWFrZSBzdXJlIHVybCBpcyBhIEphdmFzY3JpcHQgc3RyaW5nIChzb21lIHBhdGhzIG1heSBiZSBhIEphdmEgc3RyaW5nKVxuXHRcdFx0cmV0dXJuIHVybCArIChjYWNoZUJ1c3QgPyAoKC9cXD8vLnRlc3QodXJsKSA/IFwiJlwiIDogXCI/XCIpICsgY2FjaGVCdXN0KSA6IFwiXCIpO1xuXHRcdH07XG5cblxuXG5cdGlmKCAwICl7XG5cdFx0cmVxLnVuZGVmID0gZnVuY3Rpb24obW9kdWxlSWQsIHJlZmVyZW5jZU1vZHVsZSl7XG5cdFx0XHQvLyBJbiBvcmRlciB0byByZWxvYWQgYSBtb2R1bGUsIGl0IG11c3QgYmUgdW5kZWZpbmVkICh0aGlzIHJvdXRpbmUpIGFuZCB0aGVuIHJlLXJlcXVlc3RlZC5cblx0XHRcdC8vIFRoaXMgaXMgdXNlZnVsIGZvciB0ZXN0aW5nIGZyYW1ld29ya3MgKGF0IGxlYXN0KS5cblx0XHRcdHZhciBtb2R1bGUgPSBnZXRNb2R1bGUobW9kdWxlSWQsIHJlZmVyZW5jZU1vZHVsZSk7XG5cdFx0XHRzZXRBcnJpdmVkKG1vZHVsZSk7XG5cdFx0XHRtaXgobW9kdWxlLCB7ZGVmOjAsIGV4ZWN1dGVkOjAsIGluamVjdGVkOjAsIG5vZGU6MCwgbG9hZDowfSk7XG5cdFx0fTtcblx0fVxuXG5cdGlmKCBmYWxzZSApe1xuXHRcdGlmKCAwID09PXVuZGVmaW5lZCl7XG5cdFx0XHQgMCAmJiBoYXMuYWRkKFwiZG9qby1sb2FkZXItZXZhbC1oaW50LXVybFwiLCAxKTtcblx0XHR9XG5cblx0XHR2YXIgaW5qZWN0UGx1Z2luID0gZnVuY3Rpb24oXG5cdFx0XHRcdG1vZHVsZVxuXHRcdFx0KXtcblx0XHRcdFx0Ly8gaW5qZWN0cyB0aGUgcGx1Z2luIG1vZHVsZSBnaXZlbiBieSBtb2R1bGU7IG1heSBoYXZlIHRvIGluamVjdCB0aGUgcGx1Z2luIGl0c2VsZlxuXHRcdFx0XHR2YXIgcGx1Z2luID0gbW9kdWxlLnBsdWdpbjtcblxuXHRcdFx0XHRpZihwbHVnaW4uZXhlY3V0ZWQgPT09IGV4ZWN1dGVkICYmICFwbHVnaW4ubG9hZCl7XG5cdFx0XHRcdFx0Ly8gZXhlY3V0ZWQgdGhlIG1vZHVsZSBub3Qga25vd2luZyBpdCB3YXMgYSBwbHVnaW5cblx0XHRcdFx0XHRwcm9tb3RlTW9kdWxlVG9QbHVnaW4ocGx1Z2luKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBvbkxvYWQgPSBmdW5jdGlvbihkZWYpe1xuXHRcdFx0XHRcdFx0bW9kdWxlLnJlc3VsdCA9IGRlZjtcblx0XHRcdFx0XHRcdHNldEFycml2ZWQobW9kdWxlKTtcblx0XHRcdFx0XHRcdGZpbmlzaEV4ZWMobW9kdWxlKTtcblx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmKHBsdWdpbi5sb2FkKXtcblx0XHRcdFx0XHRwbHVnaW4ubG9hZChtb2R1bGUucHJpZCwgbW9kdWxlLnJlcSwgb25Mb2FkKTtcblx0XHRcdFx0fWVsc2UgaWYocGx1Z2luLmxvYWRRKXtcblx0XHRcdFx0XHRwbHVnaW4ubG9hZFEucHVzaChtb2R1bGUpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHQvLyB0aGUgdW5zaGlmdCBpbnN0ZWFkIG9mIHB1c2ggaXMgaW1wb3J0YW50OiB3ZSBkb24ndCB3YW50IHBsdWdpbnMgdG8gZXhlY3V0ZSBhc1xuXHRcdFx0XHRcdC8vIGRlcGVuZGVuY2llcyBvZiBzb21lIG90aGVyIG1vZHVsZSBiZWNhdXNlIHRoaXMgbWF5IGNhdXNlIGNpcmNsZXMgd2hlbiB0aGUgcGx1Z2luXG5cdFx0XHRcdFx0Ly8gbG9hZFEgaXMgcnVuOyBhbHNvLCBnZW5lcmFsbHksIHdlIHdhbnQgcGx1Z2lucyB0byBydW4gZWFybHkgc2luY2UgdGhleSBtYXkgbG9hZFxuXHRcdFx0XHRcdC8vIHNldmVyYWwgb3RoZXIgbW9kdWxlcyBhbmQgdGhlcmVmb3JlIGNhbiBwb3RlbnRpYWxseSB1bmJsb2NrIG1hbnkgbW9kdWxlc1xuXHRcdFx0XHRcdHBsdWdpbi5sb2FkUSA9IFttb2R1bGVdO1xuXHRcdFx0XHRcdGV4ZWNRLnVuc2hpZnQocGx1Z2luKTtcblx0XHRcdFx0XHRpbmplY3RNb2R1bGUocGx1Z2luKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gZm9yIElFLCBpbmplY3RpbmcgYSBtb2R1bGUgbWF5IHJlc3VsdCBpbiBhIHJlY3Vyc2l2ZSBleGVjdXRpb24gaWYgdGhlIG1vZHVsZSBpcyBpbiB0aGUgY2FjaGVcblxuXHRcdFx0Y2FjaGVkID0gMCxcblxuXHRcdFx0aW5qZWN0aW5nTW9kdWxlID0gMCxcblxuXHRcdFx0aW5qZWN0aW5nQ2FjaGVkTW9kdWxlID0gMCxcblxuXHRcdFx0ZXZhbE1vZHVsZVRleHQgPSBmdW5jdGlvbih0ZXh0LCBtb2R1bGUpe1xuXHRcdFx0XHQvLyBzZWUgZGVmKCkgZm9yIHRoZSBpbmplY3RpbmdDYWNoZWRNb2R1bGUgYnJhY2tldDsgaXQgc2ltcGx5IGNhdXNlcyBhIHNob3J0LCBzYWZlIGNpcmN1aXRcblx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oW1wiJ10pdXNlIHN0cmljdFxcMS9nLCAnJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5qZWN0aW5nQ2FjaGVkTW9kdWxlID0gMTtcblx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHRpZih0ZXh0PT09Y2FjaGVkKXtcblx0XHRcdFx0XHRcdFx0Y2FjaGVkLmNhbGwobnVsbCk7XG5cdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0cmVxLmV2YWwodGV4dCwgIDAgID8gbW9kdWxlLnVybCA6IG1vZHVsZS5taWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwiZXZhbE1vZHVsZVRocmV3XCIsIG1vZHVsZSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0aWYodGV4dD09PWNhY2hlZCl7XG5cdFx0XHRcdFx0XHRjYWNoZWQuY2FsbChudWxsKTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdHJlcS5ldmFsKHRleHQsICAwICA/IG1vZHVsZS51cmwgOiBtb2R1bGUubWlkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5qZWN0aW5nQ2FjaGVkTW9kdWxlID0gMDtcblx0XHRcdH0sXG5cblx0XHRcdGluamVjdE1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSl7XG5cdFx0XHRcdC8vIEluamVjdCB0aGUgbW9kdWxlLiBJbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCwgdGhpcyBtZWFucyBhcHBlbmRpbmcgYSBzY3JpcHQgZWxlbWVudCBpbnRvXG5cdFx0XHRcdC8vIHRoZSBkb2N1bWVudDsgaW4gb3RoZXIgZW52aXJvbm1lbnRzLCBpdCBtZWFucyBsb2FkaW5nIGEgZmlsZS5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gSWYgaW4gc3luY2hyb25vdXMgbW9kZSwgdGhlbiBnZXQgdGhlIG1vZHVsZSBzeW5jaHJvbm91c2x5IGlmIGl0J3Mgbm90IHhkb21haW5Mb2FkaW5nLlxuXG5cdFx0XHRcdHZhciBtaWQgPSBtb2R1bGUubWlkLFxuXHRcdFx0XHRcdHVybCA9IG1vZHVsZS51cmw7XG5cdFx0XHRcdGlmKG1vZHVsZS5leGVjdXRlZCB8fCBtb2R1bGUuaW5qZWN0ZWQgfHwgd2FpdGluZ1ttaWRdIHx8IChtb2R1bGUudXJsICYmICgobW9kdWxlLnBhY2sgJiYgd2FpdGluZ1ttb2R1bGUudXJsXT09PW1vZHVsZS5wYWNrKSB8fCB3YWl0aW5nW21vZHVsZS51cmxdPT0xKSkpe1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRSZXF1ZXN0ZWQobW9kdWxlKTtcblxuXHRcdFx0XHRpZiggMCApe1xuXHRcdFx0XHRcdHZhciB2aWFDb21ibyA9IDA7XG5cdFx0XHRcdFx0aWYobW9kdWxlLnBsdWdpbiAmJiBtb2R1bGUucGx1Z2luLmlzQ29tYm8pe1xuXHRcdFx0XHRcdFx0Ly8gYSBjb21ibyBwbHVnaW47IHRoZXJlZm9yZSwgbXVzdCBiZSBoYW5kbGVkIGJ5IGNvbWJvIHNlcnZpY2Vcblx0XHRcdFx0XHRcdC8vIHRoZSBwcmlkIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgdG8gYSBVUkwgKGlmIHJlcXVpcmVkIGJ5IHRoZSBwbHVnaW4pIGR1cmluZ1xuXHRcdFx0XHRcdFx0Ly8gdGhlIG5vcm1hbGl6ZSBwcm9jZXNzOyBpbiBhbnkgZXZlbnQsIHRoZXJlIGlzIG5vIHdheSBmb3IgdGhlIGxvYWRlciB0byBrbm93IGhvdyB0b1xuXHRcdFx0XHRcdFx0Ly8gdG8gdGhlIGNvbnZlcnNpb247IHRoZXJlZm9yZSB0aGUgdGhpcmQgYXJndW1lbnQgaXMgemVyb1xuXHRcdFx0XHRcdFx0cmVxLmNvbWJvLmFkZChtb2R1bGUucGx1Z2luLm1pZCwgbW9kdWxlLnByaWQsIDAsIHJlcSk7XG5cdFx0XHRcdFx0XHR2aWFDb21ibyA9IDE7XG5cdFx0XHRcdFx0fWVsc2UgaWYoIW1vZHVsZS5wbHVnaW4pe1xuXHRcdFx0XHRcdFx0dmlhQ29tYm8gPSByZXEuY29tYm8uYWRkKDAsIG1vZHVsZS5taWQsIG1vZHVsZS51cmwsIHJlcSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHZpYUNvbWJvKXtcblx0XHRcdFx0XHRcdGNvbWJvUGVuZGluZz0gMTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihtb2R1bGUucGx1Z2luKXtcblx0XHRcdFx0XHRpbmplY3RQbHVnaW4obW9kdWxlKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gLy8gZWxzZSBhIG5vcm1hbCBtb2R1bGUgKG5vdCBhIHBsdWdpbilcblxuXG5cdFx0XHRcdHZhciBvbkxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0cnVuRGVmUShtb2R1bGUpO1xuXHRcdFx0XHRcdGlmKG1vZHVsZS5pbmplY3RlZCAhPT0gYXJyaXZlZCl7XG5cdFx0XHRcdFx0XHQvLyB0aGUgc2NyaXB0IHRoYXQgY29udGFpbmVkIHRoZSBtb2R1bGUgYXJyaXZlZCBhbmQgaGFzIGJlZW4gZXhlY3V0ZWQgeWV0XG5cdFx0XHRcdFx0XHQvLyBub3RoaW5nIHdhcyBhZGRlZCB0byB0aGUgZGVmUSAoc28gaXQgd2Fzbid0IGFuIEFNRCBtb2R1bGUpIGFuZCB0aGUgbW9kdWxlXG5cdFx0XHRcdFx0XHQvLyB3YXNuJ3QgbWFya2VkIGFzIGFycml2ZWQgYnkgZG9qby5wcm92aWRlIChzbyBpdCB3YXNuJ3QgYSB2MS42LSBtb2R1bGUpO1xuXHRcdFx0XHRcdFx0Ly8gdGhlcmVmb3JlLCBpdCBtdXN0IG5vdCBoYXZlIGJlZW4gYSBtb2R1bGU7IGFkanVzdCBzdGF0ZSBhY2NvcmRpbmdseVxuXHRcdFx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHRcdFx0c2lnbmFsKGVycm9yLCBtYWtlRXJyb3IoXCJub0RlZmluZVwiLCBtb2R1bGUpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c2V0QXJyaXZlZChtb2R1bGUpO1xuXHRcdFx0XHRcdFx0bWl4KG1vZHVsZSwgbm9uTW9kdWxlUHJvcHMpO1xuXHRcdFx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWRlZmluZS1ub25tb2R1bGVcIiwgW21vZHVsZS51cmxdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiggMCAgJiYgbGVnYWN5TW9kZSl7XG5cdFx0XHRcdFx0XHQvLyBtdXN0IGNhbGwgY2hlY2tDb21wbGV0ZSBldmVuIGluIGZvciBzeW5jIGxvYWRlciBiZWNhdXNlIHdlIG1heSBiZSBpbiB4ZG9tYWluTG9hZGluZyBtb2RlO1xuXHRcdFx0XHRcdFx0Ly8gYnV0LCBpZiB4ZCBsb2FkaW5nLCB0aGVuIGRvbid0IGNhbGwgY2hlY2tDb21wbGV0ZSB1bnRpbCBvdXQgb2YgdGhlIGN1cnJlbnQgc3luYyB0cmF2ZXJzYWxcblx0XHRcdFx0XHRcdC8vIGluIG9yZGVyIHRvIHByZXNlcnZlIG9yZGVyIG9mIGV4ZWN1dGlvbiBvZiB0aGUgZG9qby5yZXF1aXJlZCBtb2R1bGVzXG5cdFx0XHRcdFx0XHQhc3luY0V4ZWNTdGFjay5sZW5ndGggJiYgY2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0Y2FjaGVkID0gY2FjaGVbbWlkXSB8fCBjYWNoZVt1cmxLZXlQcmVmaXggKyBtb2R1bGUudXJsXTtcblx0XHRcdFx0aWYoY2FjaGVkKXtcblx0XHRcdFx0XHRyZXEudHJhY2UoXCJsb2FkZXItaW5qZWN0XCIsIFtcImNhY2hlXCIsIG1vZHVsZS5taWQsIHVybF0pO1xuXHRcdFx0XHRcdGV2YWxNb2R1bGVUZXh0KGNhY2hlZCwgbW9kdWxlKTtcblx0XHRcdFx0XHRvbkxvYWRDYWxsYmFjaygpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiggMCAgJiYgbGVnYWN5TW9kZSl7XG5cdFx0XHRcdFx0aWYobW9kdWxlLmlzWGQpe1xuXHRcdFx0XHRcdFx0Ly8gc3dpdGNoIHRvIGFzeW5jIG1vZGUgdGVtcG9yYXJpbHk7IGlmIGN1cnJlbnQgbGVnYWN5TW9kZSE9c3luYywgdGhlbiBpcyBtdXN0IGJlIG9uZSBvZiB7bGVnYWN5QXN5bmMsIHhkLCBmYWxzZX1cblx0XHRcdFx0XHRcdGxlZ2FjeU1vZGU9PXN5bmMgJiYgKGxlZ2FjeU1vZGUgPSB4ZCk7XG5cdFx0XHRcdFx0XHQvLyBmYWxsIHRocm91Z2ggYW5kIGxvYWQgdmlhIHNjcmlwdCBpbmplY3Rpb25cblx0XHRcdFx0XHR9ZWxzZSBpZihtb2R1bGUuaXNBbWQgJiYgbGVnYWN5TW9kZSE9c3luYyl7XG5cdFx0XHRcdFx0XHQvLyBmYWxsIHRocm91Z2ggYW5kIGxvYWQgdmlhIHNjcmlwdCBpbmplY3Rpb25cblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdC8vIG1vZGUgbWF5IGJlIHN5bmMsIHhkL2xlZ2FjeUFzeW5jLCBvciBhc3luYzsgbW9kdWxlIG1heSBiZSBBTUQgb3IgbGVnYWN5OyBidXQgbW9kdWxlIGlzIGFsd2F5cyBsb2NhdGVkIG9uIHRoZSBzYW1lIGRvbWFpblxuXHRcdFx0XHRcdFx0dmFyIHhockNhbGxiYWNrID0gZnVuY3Rpb24odGV4dCl7XG5cdFx0XHRcdFx0XHRcdGlmKGxlZ2FjeU1vZGU9PXN5bmMpe1xuXHRcdFx0XHRcdFx0XHRcdC8vIHRoZSB0b3Agb2Ygc3luY0V4ZWNTdGFjayBnaXZlcyB0aGUgY3VycmVudCBzeW5jaHJvbm91c2x5IGV4ZWN1dGluZyBtb2R1bGU7IHRoZSBsb2FkZXIgbmVlZHNcblx0XHRcdFx0XHRcdFx0XHQvLyB0byBrbm93IHRoaXMgaWYgaXQgaGFzIHRvIHN3aXRjaCB0byBhc3luYyBsb2FkaW5nIGluIHRoZSBtaWRkbGUgb2YgZXZhbHVhdGluZyBhIGxlZ2FjeSBtb2R1bGVcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzIGhhcHBlbnMgd2hlbiBhIG1vZHVsZXMgZG9qby5yZXF1aXJlJ3MgYSBtb2R1bGUgdGhhdCBtdXN0IGJlIGxvYWRlZCBhc3luYyBiZWNhdXNlIGl0J3MgeGRvbWFpblxuXHRcdFx0XHRcdFx0XHRcdC8vICh1c2luZyB1bnNoaWZ0L3NoaWZ0IGJlY2F1c2UgdGhlcmUgaXMgbm8gYmFjaygpIG1ldGhvZHMgZm9yIEphdmFzY3JpcHQgYXJyYXlzKVxuXHRcdFx0XHRcdFx0XHRcdHN5bmNFeGVjU3RhY2sudW5zaGlmdChtb2R1bGUpO1xuXHRcdFx0XHRcdFx0XHRcdGV2YWxNb2R1bGVUZXh0KHRleHQsIG1vZHVsZSk7XG5cdFx0XHRcdFx0XHRcdFx0c3luY0V4ZWNTdGFjay5zaGlmdCgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gbWF5YmUgdGhlIG1vZHVsZSB3YXMgYW4gQU1EIG1vZHVsZVxuXHRcdFx0XHRcdFx0XHRcdHJ1bkRlZlEobW9kdWxlKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGxlZ2FjeSBtb2R1bGVzIG5ldmVyIGdldCB0byBkZWZpbmVNb2R1bGUoKSA9PiBjanMgYW5kIGluamVjdGVkIG5ldmVyIHNldDsgYWxzbyBldmFsdWF0aW9uIGltcGxpZXMgZXhlY3V0aW5nXG5cdFx0XHRcdFx0XHRcdFx0aWYoIW1vZHVsZS5janMpe1xuXHRcdFx0XHRcdFx0XHRcdFx0c2V0QXJyaXZlZChtb2R1bGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmluaXNoRXhlYyhtb2R1bGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGlmKG1vZHVsZS5maW5pc2gpe1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gd2hpbGUgc3luY2hyb25vdXNseSBldmFsdWF0aW5nIHRoaXMgbW9kdWxlLCBkb2pvLnJlcXVpcmUgd2FzIGFwcGxpZWQgcmVmZXJlbmNpbmcgYSBtb2R1bGVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHRoYXQgaGFkIHRvIGJlIGxvYWRlZCBhc3luYzsgdGhlcmVmb3JlLCB0aGUgbG9hZGVyIHN0b3BwZWQgYW5zd2VyaW5nIGFsbCBkb2pvLnJlcXVpcmVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHJlcXVlc3RzIHNvIHRoZXkgY291bGQgYmUgYW5zd2VyZWQgY29tcGxldGVseSBpbiB0aGUgY29ycmVjdCBzZXF1ZW5jZTsgbW9kdWxlLmZpbmlzaCBnaXZlc1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhlIGxpc3Qgb2YgZG9qby5yZXF1aXJlcyB0aGF0IG11c3QgYmUgcmUtYXBwbGllZCBvbmNlIGFsbCB0YXJnZXQgbW9kdWxlcyBhcmUgYXZhaWxhYmxlO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gbWFrZSBhIHN5bnRoZXRpYyBtb2R1bGUgdG8gZXhlY3V0ZSB0aGUgZG9qby5yZXF1aXJlJ3MgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gY29tcHV0ZSBhIGd1YXJhbnRlZWQtdW5pcXVlIG1pZCBmb3IgdGhlIHN5bnRoZXRpYyBmaW5pc2ggbW9kdWxlOyByZW1lbWJlciB0aGUgZmluaXNoIHZlY3RvcjsgcmVtb3ZlIGl0IGZyb20gdGhlIHJlZmVyZW5jZSBtb2R1bGVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFRPRE86IGNhbiB3ZSBqdXN0IGxlYXZlIHRoZSBtb2R1bGUuZmluaXNoLi4ud2hhdCdzIGl0IGh1cnRpbmc/XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgZmluaXNoTWlkID0gbWlkICsgXCIqZmluaXNoXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpbmlzaCA9IG1vZHVsZS5maW5pc2g7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgbW9kdWxlLmZpbmlzaDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVmKGZpbmlzaE1pZCwgW1wiZG9qb1wiLCAoXCJkb2pvL3JlcXVpcmUhXCIgKyBmaW5pc2guam9pbihcIixcIikpLnJlcGxhY2UoL1xcLi9nLCBcIi9cIildLCBmdW5jdGlvbihkb2pvKXtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yRWFjaChmaW5pc2gsIGZ1bmN0aW9uKG1pZCl7IGRvam8ucmVxdWlyZShtaWQpOyB9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdW5zaGlmdCwgbm90IHB1c2gsIHdoaWNoIGNhdXNlcyB0aGUgY3VycmVudCB0cmF2ZXJzYWwgdG8gYmUgcmVhdHRlbXB0ZWQgZnJvbSB0aGUgdG9wXG5cdFx0XHRcdFx0XHRcdFx0XHRleGVjUS51bnNoaWZ0KGdldE1vZHVsZShmaW5pc2hNaWQpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0b25Mb2FkQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0dGV4dCA9IHRyYW5zZm9ybVRvQW1kKG1vZHVsZSwgdGV4dCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYodGV4dCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRldmFsTW9kdWxlVGV4dCh0ZXh0LCBtb2R1bGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Mb2FkQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGlmIHRyYW5zZm9ybVRvQW1kIHJldHVybmVkIGZhbHN5LCB0aGVuIHRoZSBtb2R1bGUgd2FzIGFscmVhZHkgQU1EIGFuZCBpdCBjYW4gYmUgc2NyaXB0LWluamVjdGVkXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBkbyBzbyB0byBpbXByb3ZlIGRlYnVnYWJpbGl0eShldmVuIHRob3VnaCBpdCBtZWFucyBhbm90aGVyIGRvd25sb2FkLi4ud2hpY2ggcHJvYmFibHkgd29uJ3QgaGFwcGVuIHdpdGggYSBnb29kIGJyb3dzZXIgY2FjaGUpXG5cdFx0XHRcdFx0XHRcdFx0XHRpbmplY3RpbmdNb2R1bGUgPSBtb2R1bGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXEuaW5qZWN0VXJsKGZpeHVwVXJsKHVybCksIG9uTG9hZENhbGxiYWNrLCBtb2R1bGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5qZWN0aW5nTW9kdWxlID0gMDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHJlcS50cmFjZShcImxvYWRlci1pbmplY3RcIiwgW1wieGhyXCIsIG1vZHVsZS5taWQsIHVybCwgbGVnYWN5TW9kZSE9c3luY10pO1xuXHRcdFx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0XHRcdHJlcS5nZXRUZXh0KHVybCwgbGVnYWN5TW9kZSE9c3luYywgeGhyQ2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0XHRcdFx0c2lnbmFsKGVycm9yLCBtYWtlRXJyb3IoXCJ4aHJJbmplY3RGYWlsZWRcIiwgW21vZHVsZSwgZV0pKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdHJlcS5nZXRUZXh0KHVybCwgbGVnYWN5TW9kZSE9c3luYywgeGhyQ2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSAvLyBlbHNlIGFzeW5jIG1vZGUgb3IgZmVsbCB0aHJvdWdoIGluIHhkb21haW4gbG9hZGluZyBtb2RlOyBlaXRoZXIgd2F5LCBsb2FkIGJ5IHNjcmlwdCBpbmplY3Rpb25cblx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWluamVjdFwiLCBbXCJzY3JpcHRcIiwgbW9kdWxlLm1pZCwgdXJsXSk7XG5cdFx0XHRcdGluamVjdGluZ01vZHVsZSA9IG1vZHVsZTtcblx0XHRcdFx0cmVxLmluamVjdFVybChmaXh1cFVybCh1cmwpLCBvbkxvYWRDYWxsYmFjaywgbW9kdWxlKTtcblx0XHRcdFx0aW5qZWN0aW5nTW9kdWxlID0gMDtcblx0XHRcdH0sXG5cblx0XHRcdGRlZmluZU1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSwgZGVwcywgZGVmKXtcblx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWRlZmluZS1tb2R1bGVcIiwgW21vZHVsZS5taWQsIGRlcHNdKTtcblxuXHRcdFx0XHRpZiggMCAgJiYgbW9kdWxlLnBsdWdpbiAmJiBtb2R1bGUucGx1Z2luLmlzQ29tYm8pe1xuXHRcdFx0XHRcdC8vIHRoZSBtb2R1bGUgaXMgYSBwbHVnaW4gcmVzb3VyY2UgbG9hZGVkIGJ5IHRoZSBjb21ibyBzZXJ2aWNlXG5cdFx0XHRcdFx0Ly8gbm90ZTogY2hlY2sgZm9yIG1vZHVsZS5wbHVnaW4gc2hvdWxkIGJlIGVub3VnaCBzaW5jZSBub3JtYWwgcGx1Z2luIHJlc291cmNlcyBzaG91bGRcblx0XHRcdFx0XHQvLyBub3QgZm9sbG93IHRoaXMgcGF0aDsgbW9kdWxlLnBsdWdpbi5pc0NvbWJvIGlzIGZ1dHVyZS1wcm9vZmluZyBiZWx0IGFuZCBzdXNwZW5kZXJzXG5cdFx0XHRcdFx0bW9kdWxlLnJlc3VsdCA9IGlzRnVuY3Rpb24oZGVmKSA/IGRlZigpIDogZGVmO1xuXHRcdFx0XHRcdHNldEFycml2ZWQobW9kdWxlKTtcblx0XHRcdFx0XHRmaW5pc2hFeGVjKG1vZHVsZSk7XG5cdFx0XHRcdFx0cmV0dXJuIG1vZHVsZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtaWQgPSBtb2R1bGUubWlkO1xuXHRcdFx0XHRpZihtb2R1bGUuaW5qZWN0ZWQgPT09IGFycml2ZWQpe1xuXHRcdFx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwibXVsdGlwbGVEZWZpbmVcIiwgbW9kdWxlKSk7XG5cdFx0XHRcdFx0cmV0dXJuIG1vZHVsZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtaXgobW9kdWxlLCB7XG5cdFx0XHRcdFx0ZGVwczogZGVwcyxcblx0XHRcdFx0XHRkZWY6IGRlZixcblx0XHRcdFx0XHRjanM6IHtcblx0XHRcdFx0XHRcdGlkOiBtb2R1bGUubWlkLFxuXHRcdFx0XHRcdFx0dXJpOiBtb2R1bGUudXJsLFxuXHRcdFx0XHRcdFx0ZXhwb3J0czogKG1vZHVsZS5yZXN1bHQgPSB7fSksXG5cdFx0XHRcdFx0XHRzZXRFeHBvcnRzOiBmdW5jdGlvbihleHBvcnRzKXtcblx0XHRcdFx0XHRcdFx0bW9kdWxlLmNqcy5leHBvcnRzID0gZXhwb3J0cztcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRjb25maWc6ZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG1vZHVsZS5jb25maWc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyByZXNvbHZlIGRlcHMgd2l0aCByZXNwZWN0IHRvIHRoaXMgbW9kdWxlXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGRlcHNbaV07IGkrKyl7XG5cdFx0XHRcdFx0ZGVwc1tpXSA9IGdldE1vZHVsZShkZXBzW2ldLCBtb2R1bGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoIDAgICYmIGxlZ2FjeU1vZGUgJiYgIXdhaXRpbmdbbWlkXSl7XG5cdFx0XHRcdFx0Ly8gdGhlIG1vZHVsZSBzaG93ZWQgdXAgd2l0aG91dCBiZWluZyBhc2tlZCBmb3I7IGl0IHdhcyBwcm9iYWJseSBpbiBhIDxzY3JpcHQ+IGVsZW1lbnRcblx0XHRcdFx0XHRpbmplY3REZXBlbmRlbmNpZXMobW9kdWxlKTtcblx0XHRcdFx0XHRleGVjUS5wdXNoKG1vZHVsZSk7XG5cdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldEFycml2ZWQobW9kdWxlKTtcblxuXHRcdFx0XHRpZighaXNGdW5jdGlvbihkZWYpICYmICFkZXBzLmxlbmd0aCl7XG5cdFx0XHRcdFx0bW9kdWxlLnJlc3VsdCA9IGRlZjtcblx0XHRcdFx0XHRmaW5pc2hFeGVjKG1vZHVsZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlO1xuXHRcdFx0fSxcblxuXHRcdFx0cnVuRGVmUSA9IGZ1bmN0aW9uKHJlZmVyZW5jZU1vZHVsZSwgbWlkcyl7XG5cdFx0XHRcdC8vIGRlZlEgaXMgYW4gYXJyYXkgb2YgW2lkLCBkZXBlbmRlbmNpZXMsIGZhY3RvcnldXG5cdFx0XHRcdC8vIG1pZHMgKGlmIGFueSkgaXMgYSB2ZWN0b3Igb2YgbWlkcyBnaXZlbiBieSBhIGNvbWJvIHNlcnZpY2Vcblx0XHRcdFx0dmFyIGRlZmluZWRNb2R1bGVzID0gW10sXG5cdFx0XHRcdFx0bW9kdWxlLCBhcmdzO1xuXHRcdFx0XHR3aGlsZShkZWZRLmxlbmd0aCl7XG5cdFx0XHRcdFx0YXJncyA9IGRlZlEuc2hpZnQoKTtcblx0XHRcdFx0XHRtaWRzICYmIChhcmdzWzBdPSBtaWRzLnNoaWZ0KCkpO1xuXHRcdFx0XHRcdC8vIGV4cGxpY2l0IGRlZmluZSBpbmRpY2F0ZXMgcG9zc2libGUgbXVsdGlwbGUgbW9kdWxlcyBpbiBhIHNpbmdsZSBmaWxlOyBkZWxheSBpbmplY3RpbmcgZGVwZW5kZW5jaWVzIHVudGlsIGRlZlEgZnVsbHlcblx0XHRcdFx0XHQvLyBwcm9jZXNzZWQgc2luY2UgbW9kdWxlcyBlYXJsaWVyIGluIHRoZSBxdWV1ZSBkZXBlbmQgb24gYWxyZWFkeS1hcnJpdmVkIG1vZHVsZXMgdGhhdCBhcmUgbGF0ZXIgaW4gdGhlIHF1ZXVlXG5cdFx0XHRcdFx0Ly8gVE9ETzogd2hhdCBpZiBubyBhcmdzWzBdIGFuZCBubyByZWZlcmVuY2VNb2R1bGVcblx0XHRcdFx0XHRtb2R1bGUgPSAoYXJnc1swXSAmJiBnZXRNb2R1bGUoYXJnc1swXSkpIHx8IHJlZmVyZW5jZU1vZHVsZTtcblx0XHRcdFx0XHRkZWZpbmVkTW9kdWxlcy5wdXNoKFttb2R1bGUsIGFyZ3NbMV0sIGFyZ3NbMl1dKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdW1lUGVuZGluZ0NhY2hlSW5zZXJ0KHJlZmVyZW5jZU1vZHVsZSk7XG5cdFx0XHRcdGZvckVhY2goZGVmaW5lZE1vZHVsZXMsIGZ1bmN0aW9uKGFyZ3Mpe1xuXHRcdFx0XHRcdGluamVjdERlcGVuZGVuY2llcyhkZWZpbmVNb2R1bGUuYXBwbHkobnVsbCwgYXJncykpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdH1cblxuXHR2YXIgdGltZXJJZCA9IDAsXG5cdFx0Y2xlYXJUaW1lciA9IG5vb3AsXG5cdFx0c3RhcnRUaW1lciA9IG5vb3A7XG5cdGlmKCAwICl7XG5cdFx0Ly8gVGltZXIgbWFjaGluZXJ5IHRoYXQgbW9uaXRvcnMgaG93IGxvbmcgdGhlIGxvYWRlciBpcyB3YWl0aW5nIGFuZCBzaWduYWxzIGFuIGVycm9yIHdoZW4gdGhlIHRpbWVyIHJ1bnMgb3V0LlxuXHRcdGNsZWFyVGltZXIgPSBmdW5jdGlvbigpe1xuXHRcdFx0dGltZXJJZCAmJiBjbGVhclRpbWVvdXQodGltZXJJZCk7XG5cdFx0XHR0aW1lcklkID0gMDtcblx0XHR9O1xuXG5cdFx0c3RhcnRUaW1lciA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRjbGVhclRpbWVyKCk7XG5cdFx0XHRpZihyZXEud2FpdG1zKXtcblx0XHRcdFx0dGltZXJJZCA9IGdsb2JhbC5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lcigpO1xuXHRcdFx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwidGltZW91dFwiLCB3YWl0aW5nKSk7XG5cdFx0XHRcdH0sIHJlcS53YWl0bXMpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRpZiAoIDAgKSB7XG5cdFx0Ly8gVGVzdCBmb3IgSUUncyBkaWZmZXJlbnQgd2F5IG9mIHNpZ25hbGluZyB3aGVuIHNjcmlwdHMgZmluaXNoIGxvYWRpbmcuICBOb3RlIHRoYXQgYWNjb3JkaW5nIHRvXG5cdFx0Ly8gaHR0cDovL2J1Z3MuZG9qb3Rvb2xraXQub3JnL3RpY2tldC8xNTA5NiNjb21tZW50OjE0LCBJRTkgYWxzbyBuZWVkcyB0byBmb2xsb3cgdGhlXG5cdFx0Ly8gSUUgc3BlY2lmaWMgY29kZSBwYXRoIGV2ZW4gdGhvdWdoIGl0IGhhcyBhbiBhZGRFdmVudExpc3RlbmVyKCkgbWV0aG9kLlxuXHRcdC8vIFVua25vd24gaWYgc3BlY2lhbCBwYXRoIG5lZWRlZCBvbiBJRTEwKywgd2hpY2ggYWxzbyBoYXMgYSBkb2N1bWVudC5hdHRhY2hFdmVudCgpIG1ldGhvZC5cblx0XHQvLyBTaG91bGQgZXZhbHVhdGUgdG8gZmFsc2UgZm9yIE9wZXJhIGFuZCBXaW5kb3dzIDggYXBwcywgZXZlbiB0aG91Z2ggdGhleSBkb2N1bWVudC5hdHRhY2hFdmVudCgpXG5cdFx0Ly8gIGlzIGRlZmluZWQgaW4gYm90aCB0aG9zZSBlbnZpcm9ubWVudHMuXG5cdFx0IDAgJiYgaGFzLmFkZChcImllLWV2ZW50LWJlaGF2aW9yXCIsIGRvYy5hdHRhY2hFdmVudCAmJiB0eXBlb2YgV2luZG93cyA9PT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0KHR5cGVvZiBvcGVyYSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvcGVyYS50b1N0cmluZygpICE9IFwiW29iamVjdCBPcGVyYV1cIikpO1xuXHR9XG5cblx0aWYoIDAgICYmICggZmFsc2UgIHx8ICAxICkpe1xuXHRcdHZhciBkb21PbiA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50TmFtZSwgaWVFdmVudE5hbWUsIGhhbmRsZXIpe1xuXHRcdFx0XHQvLyBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBET00gbm9kZSB1c2luZyB0aGUgQVBJIGFwcHJvcHJpYXRlIGZvciB0aGUgY3VycmVudCBicm93c2VyO1xuXHRcdFx0XHQvLyByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgZGlzY29ubmVjdCB0aGUgbGlzdGVuZXIuXG5cdFx0XHRcdGlmKCEgMCApe1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRub2RlLmF0dGFjaEV2ZW50KGllRXZlbnROYW1lLCBoYW5kbGVyKTtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdG5vZGUuZGV0YWNoRXZlbnQoaWVFdmVudE5hbWUsIGhhbmRsZXIpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR3aW5kb3dPbkxvYWRMaXN0ZW5lciA9IGRvbU9uKHdpbmRvdywgXCJsb2FkXCIsIFwib25sb2FkXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJlcS5wYWdlTG9hZGVkID0gMTtcblx0XHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmRvam90b29sa2l0Lm9yZy90aWNrZXQvMTYyNDhcblx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdGRvYy5yZWFkeVN0YXRlIT1cImNvbXBsZXRlXCIgJiYgKGRvYy5yZWFkeVN0YXRlID0gXCJjb21wbGV0ZVwiKTtcblx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdpbmRvd09uTG9hZExpc3RlbmVyKCk7XG5cdFx0XHR9KTtcblxuXHRcdGlmKCBmYWxzZSApe1xuXHRcdFx0Ly8gaWYgdGhlIGxvYWRlciBpcyBvbiB0aGUgcGFnZSwgdGhlcmUgbXVzdCBiZSBhdCBsZWFzdCBvbmUgc2NyaXB0IGVsZW1lbnRcblx0XHRcdC8vIGdldHRpbmcgaXRzIHBhcmVudCBhbmQgdGhlbiBkb2luZyBpbnNlcnRCZWZvcmUgc29sdmVzIHRoZSBcIk9wZXJhdGlvbiBBYm9ydGVkXCJcblx0XHRcdC8vIGVycm9yIGluIElFIGZyb20gYXBwZW5kaW5nIHRvIGEgbm9kZSB0aGF0IGlzbid0IHByb3Blcmx5IGNsb3NlZDsgc2VlXG5cdFx0XHQvLyBkb2pvL3Rlc3RzL19iYXNlL2xvYWRlci9yZXF1aXJlanMvc2ltcGxlLWJhZGJhc2UuaHRtbCBmb3IgYW4gZXhhbXBsZVxuXHRcdFx0Ly8gZG9uJ3QgdXNlIHNjcmlwdHMgd2l0aCB0eXBlIGRvam8vLi4uIHNpbmNlIHRoZXNlIG1heSBiZSByZW1vdmVkOyBzZWUgIzE1ODA5XG5cdFx0XHQvLyBwcmVmZXIgdG8gdXNlIHRoZSBpbnNlcnRQb2ludCBjb21wdXRlZCBkdXJpbmcgdGhlIGNvbmZpZyBzbmlmZiBpbiBjYXNlIGEgc2NyaXB0IGlzIHJlbW92ZWQ7IHNlZSAjMTY5NThcblx0XHRcdHZhciBzY3JpcHRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0c2NyaXB0O1xuXHRcdFx0d2hpbGUoIWluc2VydFBvaW50U2libGluZyl7XG5cdFx0XHRcdGlmKCEvXmRvam8vLnRlc3QoKHNjcmlwdCA9IHNjcmlwdHNbaSsrXSkgJiYgc2NyaXB0LnR5cGUpKXtcblx0XHRcdFx0XHRpbnNlcnRQb2ludFNpYmxpbmc9IHNjcmlwdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXEuaW5qZWN0VXJsID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgb3duZXIpe1xuXHRcdFx0XHQvLyBpbnNlcnQgYSBzY3JpcHQgZWxlbWVudCB0byB0aGUgaW5zZXJ0LXBvaW50IGVsZW1lbnQgd2l0aCBzcmM9dXJsO1xuXHRcdFx0XHQvLyBhcHBseSBjYWxsYmFjayB1cG9uIGRldGVjdGluZyB0aGUgc2NyaXB0IGhhcyBsb2FkZWQuXG5cblx0XHRcdFx0dmFyIG5vZGUgPSBvd25lci5ub2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksXG5cdFx0XHRcdFx0b25Mb2FkID0gZnVuY3Rpb24oZSl7XG5cdFx0XHRcdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cdFx0XHRcdFx0XHR2YXIgbm9kZSA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblx0XHRcdFx0XHRcdGlmKGUudHlwZSA9PT0gXCJsb2FkXCIgfHwgL2NvbXBsZXRlfGxvYWRlZC8udGVzdChub2RlLnJlYWR5U3RhdGUpKXtcblx0XHRcdFx0XHRcdFx0bG9hZERpc2Nvbm5lY3RvcigpO1xuXHRcdFx0XHRcdFx0XHRlcnJvckRpc2Nvbm5lY3RvcigpO1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bG9hZERpc2Nvbm5lY3RvciA9IGRvbU9uKG5vZGUsIFwibG9hZFwiLCBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBvbkxvYWQpLFxuXHRcdFx0XHRcdGVycm9yRGlzY29ubmVjdG9yID0gZG9tT24obm9kZSwgXCJlcnJvclwiLCBcIm9uZXJyb3JcIiwgZnVuY3Rpb24oZSl7XG5cdFx0XHRcdFx0XHRsb2FkRGlzY29ubmVjdG9yKCk7XG5cdFx0XHRcdFx0XHRlcnJvckRpc2Nvbm5lY3RvcigpO1xuXHRcdFx0XHRcdFx0c2lnbmFsKGVycm9yLCBtYWtlRXJyb3IoXCJzY3JpcHRFcnJvcjogXCIgKyB1cmwsIFt1cmwsIGVdKSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0bm9kZS50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcblx0XHRcdFx0bm9kZS5jaGFyc2V0ID0gXCJ1dGYtOFwiO1xuXHRcdFx0XHRub2RlLnNyYyA9IHVybDtcblx0XHRcdFx0aW5zZXJ0UG9pbnRTaWJsaW5nLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGluc2VydFBvaW50U2libGluZyk7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRpZiggMCApe1xuXHRcdHJlcS5sb2cgPSBmdW5jdGlvbigpe1xuXHRcdFx0dHJ5e1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhhcmd1bWVudHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9Y2F0Y2goZSl7fVxuXHRcdH07XG5cdH1lbHNle1xuXHRcdHJlcS5sb2cgPSBub29wO1xuXHR9XG5cblx0aWYoIDAgKXtcblx0XHR2YXIgdHJhY2UgPSByZXEudHJhY2UgPSBmdW5jdGlvbihcblx0XHRcdGdyb3VwLFx0Ly8gdGhlIHRyYWNlIGdyb3VwIHRvIHdoaWNoIHRoaXMgYXBwbGljYXRpb24gYmVsb25nc1xuXHRcdFx0YXJnc1x0Ly8gdGhlIGNvbnRlbnRzIG9mIHRoZSB0cmFjZVxuXHRcdCl7XG5cdFx0XHQvLy9cblx0XHRcdC8vIFRyYWNpbmcgaW50ZXJmYWNlIGJ5IGdyb3VwLlxuXHRcdFx0Ly9cblx0XHRcdC8vIFNlbmRzIHRoZSBjb250ZW50cyBvZiBhcmdzIHRvIHRoZSBjb25zb2xlIGlmZiAocmVxLnRyYWNlLm9uICYmIHJlcS50cmFjZVtncm91cF0pXG5cblx0XHRcdGlmKHRyYWNlLm9uICYmIHRyYWNlLmdyb3VwW2dyb3VwXSl7XG5cdFx0XHRcdHNpZ25hbChcInRyYWNlXCIsIFtncm91cCwgYXJnc10pO1xuXHRcdFx0XHRmb3IodmFyIGFyZywgZHVtcCA9IFtdLCB0ZXh0PSBcInRyYWNlOlwiICsgZ3JvdXAgKyAoYXJncy5sZW5ndGggPyAoXCI6XCIgKyBhcmdzWzBdKSA6IFwiXCIpLCBpPSAxOyBpPGFyZ3MubGVuZ3RoOyl7XG5cdFx0XHRcdFx0YXJnID0gYXJnc1tpKytdO1xuXHRcdFx0XHRcdGlmKGlzU3RyaW5nKGFyZykpe1xuXHRcdFx0XHRcdFx0dGV4dCArPSBcIiwgXCIgKyBhcmc7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRkdW1wLnB1c2goYXJnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVxLmxvZyh0ZXh0KTtcblx0XHRcdFx0ZHVtcC5sZW5ndGggJiYgZHVtcC5wdXNoKFwiLlwiKTtcblx0XHRcdFx0cmVxLmxvZy5hcHBseShyZXEsIGR1bXApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0bWl4KHRyYWNlLCB7XG5cdFx0XHRvbjoxLFxuXHRcdFx0Z3JvdXA6e30sXG5cdFx0XHRzZXQ6ZnVuY3Rpb24oZ3JvdXAsIHZhbHVlKXtcblx0XHRcdFx0aWYoaXNTdHJpbmcoZ3JvdXApKXtcblx0XHRcdFx0XHR0cmFjZS5ncm91cFtncm91cF09IHZhbHVlO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRtaXgodHJhY2UuZ3JvdXAsIGdyb3VwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRyYWNlLnNldChtaXgobWl4KG1peCh7fSwgZGVmYXVsdENvbmZpZy50cmFjZSksIHVzZXJDb25maWcudHJhY2UpLCBkb2pvU25pZmZDb25maWcudHJhY2UpKTtcblx0XHRvbihcImNvbmZpZ1wiLCBmdW5jdGlvbihjb25maWcpe1xuXHRcdFx0Y29uZmlnLnRyYWNlICYmIHRyYWNlLnNldChjb25maWcudHJhY2UpO1xuXHRcdH0pO1xuXHR9ZWxzZXtcblx0XHRyZXEudHJhY2UgPSBub29wO1xuXHR9XG5cdGlmICghIDEgKSB7XG5cdFx0dmFyIGRlZiA9IGZ1bmN0aW9uKFxuXHRcdFx0bWlkLFx0XHQgIC8vKGNvbW1vbmpzLm1vZHVsZUlkLCBvcHRpb25hbClcblx0XHRcdGRlcGVuZGVuY2llcywgLy8oYXJyYXkgb2YgY29tbW9uanMubW9kdWxlSWQsIG9wdGlvbmFsKSBsaXN0IG9mIG1vZHVsZXMgdG8gYmUgbG9hZGVkIGJlZm9yZSBydW5uaW5nIGZhY3Rvcnlcblx0XHRcdGZhY3RvcnlcdFx0ICAvLyhhbnkpXG5cdFx0KXtcblx0XHRcdC8vL1xuXHRcdFx0Ly8gQWR2aXNlcyB0aGUgbG9hZGVyIG9mIGEgbW9kdWxlIGZhY3RvcnkuIC8vSW1wbGVtZW50cyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Nb2R1bGVzL0FzeW5jaHJvbm91c0RlZmluaXRpb24uXG5cdFx0XHQvLy9cblx0XHRcdC8vbm90ZVxuXHRcdFx0Ly8gQ29tbW9uSlMgZmFjdG9yeSBzY2FuIGNvdXJ0ZXN5IG9mIGh0dHA6Ly9yZXF1aXJlanMub3JnXG5cblx0XHRcdHZhciBhcml0eSA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRcdGRlZmF1bHREZXBzID0gW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJtb2R1bGVcIl0sXG5cdFx0XHRcdC8vIHRoZSBwcmVkb21pbmF0ZSBzaWduYXR1cmUuLi5cblx0XHRcdFx0YXJncyA9IFswLCBtaWQsIGRlcGVuZGVuY2llc107XG5cdFx0XHRpZihhcml0eT09MSl7XG5cdFx0XHRcdGFyZ3MgPSBbMCwgKGlzRnVuY3Rpb24obWlkKSA/IGRlZmF1bHREZXBzIDogW10pLCBtaWRdO1xuXHRcdFx0fWVsc2UgaWYoYXJpdHk9PTIgJiYgaXNTdHJpbmcobWlkKSl7XG5cdFx0XHRcdGFyZ3MgPSBbbWlkLCAoaXNGdW5jdGlvbihkZXBlbmRlbmNpZXMpID8gZGVmYXVsdERlcHMgOiBbXSksIGRlcGVuZGVuY2llc107XG5cdFx0XHR9ZWxzZSBpZihhcml0eT09Myl7XG5cdFx0XHRcdGFyZ3MgPSBbbWlkLCBkZXBlbmRlbmNpZXMsIGZhY3RvcnldO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggMCAgJiYgYXJnc1sxXT09PWRlZmF1bHREZXBzKXtcblx0XHRcdFx0YXJnc1syXS50b1N0cmluZygpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLyhcXC9cXCooW1xcc1xcU10qPylcXCpcXC98XFwvXFwvKC4qKSQpL21nLCBcIlwiKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9yZXF1aXJlXFwoW1wiJ10oW1xcd1xcIVxcLV9cXC5cXC9dKylbXCInXVxcKS9nLCBmdW5jdGlvbihtYXRjaCwgZGVwKXtcblx0XHRcdFx0XHRhcmdzWzFdLnB1c2goZGVwKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJlcS50cmFjZShcImxvYWRlci1kZWZpbmVcIiwgYXJncy5zbGljZSgwLCAyKSk7XG5cdFx0XHR2YXIgdGFyZ2V0TW9kdWxlID0gYXJnc1swXSAmJiBnZXRNb2R1bGUoYXJnc1swXSksXG5cdFx0XHRcdG1vZHVsZTtcblx0XHRcdGlmKHRhcmdldE1vZHVsZSAmJiAhd2FpdGluZ1t0YXJnZXRNb2R1bGUubWlkXSl7XG5cdFx0XHRcdC8vIGdpdmVuIGEgbWlkIHRoYXQgaGFzbid0IGJlZW4gcmVxdWVzdGVkOyB0aGVyZWZvcmUsIGRlZmluZWQgdGhyb3VnaCBtZWFucyBvdGhlciB0aGFuIGluamVjdGluZ1xuXHRcdFx0XHQvLyBjb25zZXF1ZW50IHRvIGEgcmVxdWlyZSgpIG9yIGRlZmluZSgpIGFwcGxpY2F0aW9uOyBleGFtcGxlcyBpbmNsdWRlIGRlZmluaW5nIG1vZHVsZXMgb24tdGhlLWZseVxuXHRcdFx0XHQvLyBkdWUgdG8gc29tZSBjb2RlIHBhdGggb3IgaW5jbHVkaW5nIGEgbW9kdWxlIGluIGEgc2NyaXB0IGVsZW1lbnQuIEluIGFueSBjYXNlLFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBjYWxsYmFjayB3YWl0aW5nIHRvIGZpbmlzaCBwcm9jZXNzaW5nIGFuZCBub3RoaW5nIHRvIHRyaWdnZXIgdGhlIGRlZlEgYW5kIHRoZVxuXHRcdFx0XHQvLyBkZXBlbmRlbmNpZXMgYXJlIG5ldmVyIHJlcXVlc3RlZDsgdGhlcmVmb3JlLCBkbyBpdCBoZXJlLlxuXHRcdFx0XHRpbmplY3REZXBlbmRlbmNpZXMoZGVmaW5lTW9kdWxlKHRhcmdldE1vZHVsZSwgYXJnc1sxXSwgYXJnc1syXSkpO1xuXHRcdFx0fWVsc2UgaWYoISAwICB8fCAhIDEgIHx8IGluamVjdGluZ0NhY2hlZE1vZHVsZSl7XG5cdFx0XHRcdC8vIG5vdCBJRSBwYXRoOiBhbm9ueW1vdXMgbW9kdWxlIGFuZCB0aGVyZWZvcmUgbXVzdCBoYXZlIGJlZW4gaW5qZWN0ZWQ7IHRoZXJlZm9yZSwgb25Mb2FkIHdpbGwgZmlyZSBpbW1lZGlhdGVseVxuXHRcdFx0XHQvLyBhZnRlciBzY3JpcHQgZmluaXNoZXMgYmVpbmcgZXZhbHVhdGVkIGFuZCB0aGUgZGVmUSBjYW4gYmUgcnVuIGZyb20gdGhhdCBjYWxsYmFjayB0byBkZXRlY3QgdGhlIG1vZHVsZSBpZFxuXHRcdFx0XHRkZWZRLnB1c2goYXJncyk7XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0Ly8gSUUgcGF0aDogcG9zc2libHkgYW5vbnltb3VzIG1vZHVsZSBhbmQgdGhlcmVmb3JlIGluamVjdGVkOyB0aGVyZWZvcmUsIGNhbm5vdCBkZXBlbmQgb24gMS10by0xLFxuXHRcdFx0XHQvLyBpbi1vcmRlciBleGVjIG9mIG9uTG9hZCB3aXRoIHNjcmlwdCBldmFsIChzaW5jZSBpdCdzIElFKSBhbmQgbXVzdCBtYW51YWxseSBkZXRlY3QgaGVyZVxuXHRcdFx0XHR0YXJnZXRNb2R1bGUgPSB0YXJnZXRNb2R1bGUgfHwgaW5qZWN0aW5nTW9kdWxlO1xuXHRcdFx0XHRpZighdGFyZ2V0TW9kdWxlKXtcblx0XHRcdFx0XHRmb3IobWlkIGluIHdhaXRpbmcpe1xuXHRcdFx0XHRcdFx0bW9kdWxlID0gbW9kdWxlc1ttaWRdO1xuXHRcdFx0XHRcdFx0aWYobW9kdWxlICYmIG1vZHVsZS5ub2RlICYmIG1vZHVsZS5ub2RlLnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScpe1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRNb2R1bGUgPSBtb2R1bGU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiggMCAgJiYgIXRhcmdldE1vZHVsZSl7XG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpPGNvbWJvc1BlbmRpbmcubGVuZ3RoOyBpKyspe1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRNb2R1bGUgPSBjb21ib3NQZW5kaW5nW2ldO1xuXHRcdFx0XHRcdFx0XHRpZih0YXJnZXRNb2R1bGUubm9kZSAmJiB0YXJnZXRNb2R1bGUubm9kZS5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnKXtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRNb2R1bGU9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCAwICAmJiBpc0FycmF5KHRhcmdldE1vZHVsZSkpe1xuXHRcdFx0XHRcdGluamVjdERlcGVuZGVuY2llcyhkZWZpbmVNb2R1bGUoZ2V0TW9kdWxlKHRhcmdldE1vZHVsZS5zaGlmdCgpKSwgYXJnc1sxXSwgYXJnc1syXSkpO1xuXHRcdFx0XHRcdGlmKCF0YXJnZXRNb2R1bGUubGVuZ3RoKXtcblx0XHRcdFx0XHRcdGNvbWJvc1BlbmRpbmcuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fWVsc2UgaWYodGFyZ2V0TW9kdWxlKXtcblx0XHRcdFx0XHRjb25zdW1lUGVuZGluZ0NhY2hlSW5zZXJ0KHRhcmdldE1vZHVsZSk7XG5cdFx0XHRcdFx0aW5qZWN0RGVwZW5kZW5jaWVzKGRlZmluZU1vZHVsZSh0YXJnZXRNb2R1bGUsIGFyZ3NbMV0sIGFyZ3NbMl0pKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0c2lnbmFsKGVycm9yLCBtYWtlRXJyb3IoXCJpZURlZmluZUZhaWxlZFwiLCBhcmdzWzBdKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0ZGVmLmFtZCA9IHtcblx0XHRcdHZlbmRvcjpcImRvam90b29sa2l0Lm9yZ1wiXG5cdFx0fTtcblxuXHRcdGlmKCAwICl7XG5cdFx0XHRyZXEuZGVmID0gZGVmO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR2YXIgZGVmID0gbm9vcDtcblx0fVxuXHQvLyBhbGxvdyBjb25maWcgdG8gb3ZlcnJpZGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBuYW1lZCBmdW5jdGlvbnM7IHRoaXMgaXMgdXNlZnVsIGZvclxuXHQvLyBub24tYnJvd3NlciBlbnZpcm9ubWVudHMsIGUuZy4sIG92ZXJyaWRpbmcgaW5qZWN0VXJsLCBnZXRUZXh0LCBsb2csIGV0Yy4gaW4gbm9kZS5qcywgUmhpbm8sIGV0Yy5cblx0Ly8gYWxzbyB1c2VmdWwgZm9yIHRlc3RpbmcgYW5kIG1vbmtleSBwYXRjaGluZyBsb2FkZXJcblx0bWl4KG1peChyZXEsIGRlZmF1bHRDb25maWcubG9hZGVyUGF0Y2gpLCB1c2VyQ29uZmlnLmxvYWRlclBhdGNoKTtcblxuXHQvLyBub3cgdGhhdCByZXEgaXMgZnVsbHkgaW5pdGlhbGl6ZWQgYW5kIHdvbid0IGNoYW5nZSwgd2UgY2FuIGhvb2sgaXQgdXAgdG8gdGhlIGVycm9yIHNpZ25hbFxuXHRvbihlcnJvciwgZnVuY3Rpb24oYXJnKXtcblx0XHR0cnl7XG5cdFx0XHRjb25zb2xlLmVycm9yKGFyZyk7XG5cdFx0XHRpZihhcmcgaW5zdGFuY2VvZiBFcnJvcil7XG5cdFx0XHRcdGZvcih2YXIgcCBpbiBhcmcpe1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKHAgKyBcIjpcIiwgYXJnW3BdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIi5cIik7XG5cdFx0XHR9XG5cdFx0fWNhdGNoKGUpe31cblx0fSk7XG5cblx0Ly8gYWx3YXlzIHB1Ymxpc2ggdGhlc2Vcblx0bWl4KHJlcSwge1xuXHRcdHVpZDp1aWQsXG5cdFx0Y2FjaGU6Y2FjaGUsXG5cdFx0cGFja3M6cGFja3Ncblx0fSk7XG5cblxuXHRpZiggMCApe1xuXHRcdG1peChyZXEsIHtcblx0XHRcdC8vIHRoZXNlIG1heSBiZSBpbnRlcmVzdGluZyB0byBsb29rIGF0IHdoZW4gZGVidWdnaW5nXG5cdFx0XHRwYXRoczpwYXRocyxcblx0XHRcdGFsaWFzZXM6YWxpYXNlcyxcblx0XHRcdG1vZHVsZXM6bW9kdWxlcyxcblx0XHRcdGxlZ2FjeU1vZGU6bGVnYWN5TW9kZSxcblx0XHRcdGV4ZWNROmV4ZWNRLFxuXHRcdFx0ZGVmUTpkZWZRLFxuXHRcdFx0d2FpdGluZzp3YWl0aW5nLFxuXG5cdFx0XHQvLyB0aGVzZSBhcmUgdXNlZCBmb3IgdGVzdGluZ1xuXHRcdFx0Ly8gVE9ETzogbW92ZSB0ZXN0aW5nIGluZnJhc3RydWN0dXJlIHRvIGEgZGlmZmVyZW50IGhhcyBmZWF0dXJlXG5cdFx0XHRwYWNrczpwYWNrcyxcblx0XHRcdG1hcFByb2dzOm1hcFByb2dzLFxuXHRcdFx0cGF0aHNNYXBQcm9nOnBhdGhzTWFwUHJvZyxcblx0XHRcdGxpc3RlbmVyUXVldWVzOmxpc3RlbmVyUXVldWVzLFxuXG5cdFx0XHQvLyB0aGVzZSBhcmUgdXNlZCBieSB0aGUgYnVpbGRlciAoYXQgbGVhc3QpXG5cdFx0XHRjb21wdXRlTWFwUHJvZzpjb21wdXRlTWFwUHJvZyxcblx0XHRcdGNvbXB1dGVBbGlhc2VzOmNvbXB1dGVBbGlhc2VzLFxuXHRcdFx0cnVuTWFwUHJvZzpydW5NYXBQcm9nLFxuXHRcdFx0Y29tcGFjdFBhdGg6Y29tcGFjdFBhdGgsXG5cdFx0XHRnZXRNb2R1bGVJbmZvOmdldE1vZHVsZUluZm9fXG5cdFx0fSk7XG5cdH1cblxuXHQvLyB0aGUgbG9hZGVyIGNhbiBiZSBkZWZpbmVkIGV4YWN0bHkgb25jZTsgbG9vayBmb3IgZ2xvYmFsIGRlZmluZSB3aGljaCBpcyB0aGUgc3ltYm9sIEFNRCBsb2FkZXJzIGFyZVxuXHQvLyAqcmVxdWlyZWQqIHRvIGRlZmluZSAoYXMgb3Bwb3NlZCB0byByZXF1aXJlLCB3aGljaCBpcyBvcHRpb25hbClcblx0aWYoZ2xvYmFsLmRlZmluZSl7XG5cdFx0aWYoIDAgKXtcblx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwiZGVmaW5lQWxyZWFkeURlZmluZWRcIiwgMCkpO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1lbHNle1xuXHRcdGdsb2JhbC5kZWZpbmUgPSBkZWY7XG5cdFx0Z2xvYmFsLnJlcXVpcmUgPSByZXE7XG5cdFx0aWYoIDAgKXtcblx0XHRcdHJlcXVpcmUgPSByZXE7XG5cdFx0fVxuXHR9XG5cblx0aWYoIDAgICYmIHJlcS5jb21ibyAmJiByZXEuY29tYm8ucGx1Z2lucyl7XG5cdFx0dmFyIHBsdWdpbnMgPSByZXEuY29tYm8ucGx1Z2lucyxcblx0XHRcdHBsdWdpbk5hbWU7XG5cdFx0Zm9yKHBsdWdpbk5hbWUgaW4gcGx1Z2lucyl7XG5cdFx0XHRtaXgobWl4KGdldE1vZHVsZShwbHVnaW5OYW1lKSwgcGx1Z2luc1twbHVnaW5OYW1lXSksIHtpc0NvbWJvOjEsIGV4ZWN1dGVkOlwiZXhlY3V0ZWRcIiwgbG9hZDoxfSk7XG5cdFx0fVxuXHR9XG5cblx0aWYoIDEgICYmICEgMSApe1xuXHRcdGZvckVhY2goZGVsYXllZE1vZHVsZUNvbmZpZywgZnVuY3Rpb24oYyl7IGNvbmZpZyhjKTsgfSk7XG5cdFx0dmFyIGJvb3REZXBzID0gZG9qb1NuaWZmQ29uZmlnLmRlcHMgfHxcdHVzZXJDb25maWcuZGVwcyB8fCBkZWZhdWx0Q29uZmlnLmRlcHMsXG5cdFx0XHRib290Q2FsbGJhY2sgPSBkb2pvU25pZmZDb25maWcuY2FsbGJhY2sgfHwgdXNlckNvbmZpZy5jYWxsYmFjayB8fCBkZWZhdWx0Q29uZmlnLmNhbGxiYWNrO1xuXHRcdHJlcS5ib290ID0gKGJvb3REZXBzIHx8IGJvb3RDYWxsYmFjaykgPyBbYm9vdERlcHMgfHwgW10sIGJvb3RDYWxsYmFja10gOiAwO1xuXHR9XG5cdGlmKCEgMSApe1xuXHRcdCFyZXEuYXN5bmMgJiYgcmVxKFtcImRvam9cIl0pO1xuXHRcdHJlcS5ib290ICYmIHJlcS5hcHBseShudWxsLCByZXEuYm9vdCk7XG5cdH1cbn0pXG4uY2FsbCh0aGlzLCB1c2VyQ29uZmlnLCBkZWZhdWx0Q29uZmlnKTt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../../../private/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-99518WoBdoDEK43Ej/dojo/dojo.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/dojo-webpack-plugin */
/******/ 	(() => {
/******/ 		(function() { /* Start dojo-webpack-plugin extensions */
/******/ 				function mix(dest, src) { // eslint-disable-line no-unused-vars
/******/ 					for(var n in src) dest[n] = src[n];
/******/ 					return dest;
/******/ 				}
/******/ 		
/******/ 				function toUrl(name, referenceModule) {
/******/ 					return loaderScope.require.toUrl(name, referenceModule);
/******/ 				}
/******/ 		
/******/ 				function toAbsMid(name, referenceModule) {
/******/ 					return loaderScope.require.toAbsMid(name, referenceModule);
/******/ 				}
/******/ 		
/******/ 				// dojo require function.
/******/ 				function req(config, dependencies, callback) {
/******/ 					return contextRequire(config, dependencies, callback, 0, req);
/******/ 				};
/******/ 		
/******/ 				function createContextRequire(module) { // eslint-disable-line no-unused-vars
/******/ 					if (!module) return req;
/******/ 					var moduleId = module.absMid;
/******/ 					if (!moduleId && req.absMidsById[module.id]) {
/******/ 						moduleId = req.absMidsById[module.id];
/******/ 					}
/******/ 					if (!moduleId) return req;
/******/ 					var result = function(a1, a2, a3) {
/******/ 						return contextRequire(a1, a2, a3, moduleId, req);
/******/ 					};
/******/ 					for (var p in req) {
/******/ 						if (req.hasOwnProperty(p)) {
/******/ 							result[p] = req[p];
/******/ 						}
/******/ 					}
/******/ 					result.toUrl = function(name) {
/******/ 						return toUrl(name, moduleId ? {mid: moduleId} : null);
/******/ 					};
/******/ 					result.toAbsMid = function(name) {
/******/ 						return toAbsMid(name, moduleId ? {mid: moduleId} : null);
/******/ 					};
/******/ 		
/******/ 					if (req.undef) {
/******/ 						result.undef = function(mid) {
/******/ 							req.undef(mid, moduleId);
/******/ 						};
/******/ 					}
/******/ 					return result;
/******/ 				}
/******/ 		
/******/ 				function registerAbsMids(absMids) { // eslint-disable-line no-unused-vars
/******/ 					for (var s in absMids) {
/******/ 						req.absMids[s] = absMids[s];
/******/ 						if (!req.absMidsById[absMids[s]]) {
/******/ 							req.absMidsById[absMids[s]] = s;
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				function resolveTernaryHasExpression(expr) { // eslint-disable-line no-unused-vars
/******/ 					// Expects an expression of the form supported by dojo/has.js loader, except that module identifiers are
/******/ 					// integers corresponding to webpack module ids.  Returns a module reference if evaluation of the expression
/******/ 					// using the currently defined features returns a module id, or else undefined.
/******/ 		
/******/ 					var has = findModule("dojo/has", null, false);
/******/ 					var id = has.normalize(expr, function(arg){return arg;});
/******/ 					return id && __webpack_require__(id) || undefined;
/******/ 				}
/******/ 		
/******/ 				function findModule(mid, referenceModule, noInstall, asModuleObj) {
/******/ 					mid = mid.split("!").map(function(segment) {
/******/ 						var isRelative = segment.charAt(0) === '.';
/******/ 						if(isRelative && !referenceModule){
/******/ 							return segment;
/******/ 						}
/******/ 						return toAbsMid(segment, referenceModule ? {mid: referenceModule} : null);
/******/ 					}).join("!");
/******/ 					var result;
/******/ 					if (mid in req.absMids && __webpack_require__.m[req.absMids[mid]]) {
/******/ 						if (noInstall) {
/******/ 							var module = __webpack_module_cache__[req.absMids[mid]];
/******/ 							result = module && (asModuleObj ? module : module.exports);
/******/ 						} else {
/******/ 							result = __webpack_require__(req.absMids[mid]);
/******/ 						}
/******/ 					}
/******/ 					if (!result) {
/******/ 						throw new Error('Module not found: ' + mid);
/******/ 					}
/******/ 					return result;
/******/ 				}
/******/ 		
/******/ 				function dojoModuleFromWebpackModule(webpackModule) { // eslint-disable-line no-unused-vars
/******/ 					if (webpackModule.absMid) return webpackModule;  // Already converted
/******/ 					var result = {i:webpackModule.id};
/******/ 					var id = req.absMidsById[webpackModule.id];
/******/ 					if (id) {
/******/ 						result.id = result.absMid = id;
/******/ 					}
/******/ 					Object.defineProperty(result, "exports", {
/******/ 						get: function() { return webpackModule.exports;},
/******/ 						set: function(value) {webpackModule.exports = value;},
/******/ 						enumerable: true,
/******/ 						configurable: true
/******/ 					});
/******/ 					return result;
/******/ 				}
/******/ 		
/******/ 				function contextRequire(a1, a2, a3, referenceModule, req) { // eslint-disable-line no-shadow
/******/ 					var type = ({}.toString).call(a1);
/******/ 					if (type === '[object String]') {
/******/ 						// a3 is passed by require calls injected into dependency arrays for dependencies specified
/******/ 						// as identifiers (vs. string literals).
/******/ 						var noInstall = !(a3 === false);
/******/ 						var m = findModule(a1, referenceModule, noInstall);
/******/ 						if (typeof m === 'object' && m.__DOJO_WEBPACK_DEFINE_PROMISE__) {
/******/ 							throw new Error('Module not found: ' + a1);
/******/ 						}
/******/ 						return m;
/******/ 					} else if (type === '[object Object]') {
/******/ 						throw new Error('Require config is not supported by WebPack');
/******/ 					}
/******/ 					if (type === '[object Array]') {
/******/ 						var modules = [], callback = a2, errors = [];
/******/ 						a1.forEach(function (mid) {
/******/ 							try {
/******/ 								modules.push(findModule(mid, referenceModule));
/******/ 							} catch (e) {
/******/ 								errors.push({mid: mid, error: e});
/******/ 							}
/******/ 						});
/******/ 						if (errors.length === 0) {
/******/ 							if (callback) {
/******/ 								if (false && isDefinePromise(modules)) { // eslint-disable-line no-undef
/******/ 									Promise.all(wrapPromises(modules)).then(function(deps) { // eslint-disable-line no-undef
/******/ 										callback.apply(this, unwrapPromises(deps)); // eslint-disable-line no-undef
/******/ 									}.bind(this)).catch(function(err){console.error(err);});
/******/ 								} else {
/******/ 									callback.apply(this, modules);
/******/ 								}
/******/ 							}
/******/ 						} else {
/******/ 							var error = new Error("findModules");
/******/ 							error.src = "dojo-webpack-plugin";
/******/ 							error.info = errors;
/******/ 							req.signal("error", error);
/******/ 						}
/******/ 						return req;
/******/ 					} else {
/******/ 						throw new Error('Unsupported require call');
/******/ 					}
/******/ 				}
/******/ 				req.toUrl = toUrl;
/******/ 				req.toAbsMid = toAbsMid;
/******/ 				req.absMids = {};
/******/ 				req.absMidsById = [];
/******/ 				req.async = 1;
/******/ 			var globalObj = this||window;
/******/ 			registerAbsMids({
/******/ 				// "./src/mathworker.js" = "./src/mathworker.js"
/******/ 				// "browser-peers/src/dedworkerpeer" = "./node_modules/browser-peers/src/dedworkerpeer.js"
/******/ 				// "browser-peers/src/peer" = "./node_modules/browser-peers/src/peer.js"
/******/ 				// "browser-peers/src/errors" = "./node_modules/browser-peers/src/errors.js"
/******/ 				// "browser-peers/src/util" = "./node_modules/browser-peers/src/util.js"
/******/ 				// "/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-99518WoBdoDEK43Ej/dojo/dojo.js" = "../../../../../../private/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-99518WoBdoDEK43Ej/dojo/dojo.js"
/******/ 			});
/******/ 		
/******/ 			globalObj.require = req;
/******/ 				(self["webpackChunkpfsc_ise"] = self["webpackChunkpfsc_ise"] || []).registerAbsMids = registerAbsMids;
/******/ 		
/******/ 			// expose the Dojo compatibility functions as a properties of __webpack_require__
/******/ 			if (__webpack_require__.dj && __webpack_require__.dj.name !== 'dojo-webpack-plugin') throw new Error("__webpack_require__.dj name collision.")
/******/ 			__webpack_require__.dj = {
/******/ 				name: 'dojo-webpack-plugin',
/******/ 				r: req,
/******/ 				c: createContextRequire,
/******/ 				m: dojoModuleFromWebpackModule,
/******/ 				h: resolveTernaryHasExpression,
/******/ 			};
/******/ 			var loaderScope = Object.create(globalObj, {
/******/ 			   document:{value: globalObj.document},
/******/ 			});
/******/ 			Object.defineProperties(loaderScope, {
/******/ 			   window:{value:loaderScope},
/******/ 			   global:{value:loaderScope}
/******/ 			});
/******/ 			loaderScope.define = loaderScope.require = undefined
/******/ 			globalObj.dojoConfig = globalObj.dojoConfig || {}
/******/ 			var userConfig = mix(globalObj.dojoConfig, ({'packages':[({'name':'dojo','location':'static/dojo'}),({'name':'dijit','location':'static/dijit'}),({'name':'dojox','location':'static/dojox'})],'paths':({'ise':'src'})}));
/******/ 			var defaultConfig = ({'hasCache':({'webpack':1,'host-browser':1,'dom':1,'dojo-loader':1,'dojo-has-api':1,'dojo-dom-ready-api':1,'dojo-sniff':1,'dojo-test-sniff':1,'config-deferredInstrumentation':1,'config-tlmSiblingOfDojo':1})});
/******/ 			var dojoLoader = __webpack_require__("../../../../../../private/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-99518WoBdoDEK43Ej/dojo/dojo.js");
/******/ 			dojoLoader.call(loaderScope, userConfig, defaultConfig, loaderScope, loaderScope);
/******/ 			Object.keys(loaderScope.require.packs).forEach(function(key) {
/******/ 				var pkg = loaderScope.require.packs[key];
/******/ 				if ((/(^\/)|(\:)/.test(pkg.main)	// main path is absolute
/******/ 				    || pkg.main.split('/').reduce(function(acc, pathComp) {
/******/ 							if (acc < 0 || pathComp === '.') return acc;
/******/ 							return (pathComp === '..' ? --acc : ++acc);
/******/ 						}, 0) <= 0) // main path is outside package
/******/ 						&& typeof pkg.realMain === 'undefined'	// hasn't already been adjusted
/******/ 				) {
/******/ 					pkg.realMain = pkg.main;
/******/ 					pkg.main = '';
/******/ 				}
/******/ 			});
/******/ 			function toAbsMid(name, referenceModule) {
/******/ 				var absMid = loaderScope.require.originalToAbsMid(name, referenceModule);
/******/ 				if (absMid.indexOf('/') === absMid.length-1) {
/******/ 					var pkgName = absMid.substring(0, absMid.length-1);
/******/ 					var pkg = loaderScope.require.packs[pkgName];
/******/ 					if (pkg && pkg.realMain) {
/******/ 						absMid = pkgName;
/******/ 					}
/******/ 				}
/******/ 				return absMid;
/******/ 			}
/******/ 			function toUrl(name, referenceModule) {
/******/ 				var url = loaderScope.require.originalToUrl(name, referenceModule);
/******/ 				var pkg = loaderScope.require.packs[name];
/******/ 				if (pkg && pkg.realMain) {
/******/ 					var parts = url.split('?');
/******/ 					if (/(^\/)|(\:)/.test(pkg.realMain)) {
/******/ 						// absolute URL
/******/ 						parts[0] = pkg.realMain;
/******/ 					} else {
/******/ 						// relative URL
/******/ 						parts[0] = parts[0] + '/' + pkg.realMain;
/******/ 					}
/******/ 					url = parts.join('?');
/******/ 				}
/******/ 				return url;
/******/ 			}
/******/ 			loaderScope.require.originalToAbsMid = loaderScope.require.toAbsMid;
/******/ 			loaderScope.require.originalToUrl = loaderScope.require.toUrl;
/******/ 			loaderScope.require.toAbsMid = toAbsMid;
/******/ 			loaderScope.require.toUrl = toUrl;
/******/ 			['baseUrl','has','rawConfig','on','signal'].forEach(function(name) {req[name] = loaderScope.require[name]})
/******/ 			var absMidsWaiting = globalObj["webpackChunkpfsc_ise"].absMidsWaiting;
/******/ 			if (absMidsWaiting) {
/******/ 			   absMidsWaiting.forEach(registerAbsMids);
/******/ 			   delete globalObj["webpackChunkpfsc_ise"].absMidsWaiting;
/******/ 			}
/******/ 		})(); /* End dojo-webpack-plugin extensions */
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/mathworker.js");
/******/ 	
/******/ })()
;