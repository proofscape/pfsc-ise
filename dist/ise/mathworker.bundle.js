/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/browser-peers/src/dedworkerpeer.js":
/*!*********************************************************!*\
  !*** ./node_modules/browser-peers/src/dedworkerpeer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DedicatedWorkerPeer\": () => (/* binding */ DedicatedWorkerPeer)\n/* harmony export */ });\n/* harmony import */ var _peer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./peer */ \"./node_modules/browser-peers/src/peer.js\");\n/*! browser-peers v0.1.0 | Copyright (c) 2020-2022 Steve Kieffer | MIT license */\n/* SPDX-License-Identifier: MIT */\n\n\n\n\n/*\n * This peer class supports communication between a page and a web worker,\n * specifically a *dedicated* worker.\n *\n * Usage:\n *\n *  In the page:\n *\n *      const worker = new Worker('worker.js');\n *      const peer = new DedicatedWorkerPeer(worker);\n *\n *  In the worker script (worker.js in this example):\n *\n *      const peer = new DedicatedWorkerPeer(self);\n *\n */\nclass DedicatedWorkerPeer extends _peer__WEBPACK_IMPORTED_MODULE_0__.Peer {\n\n    /*\n     * @param iface {Worker, DedicatedWorkerGlobalScope} An interface that has a `postMessage` method,\n     *   and an `onmessage` property. On the page side this will be the `Worker` instance with which you\n     *   want to communicate, and in the worker script this will be `self`.\n     */\n    constructor(iface) {\n        const [myName, nameOfPeer] = iface instanceof Worker ? ['page', 'worker'] : ['worker', 'page'];\n        super(myName);\n        this.nameOfPeer = nameOfPeer;\n        this.iface = iface;\n        this.boundMessageHandler = this.handleMessageEvent.bind(this);\n        this.activateMessaging();\n    }\n\n    // Convenient way to terminate the Worker, from the page side.\n    terminate() {\n        if (this.nameOfPeer === 'worker') {\n            this.iface.terminate();\n        }\n    }\n\n    activateMessaging() {\n        this.iface.onmessage = this.boundMessageHandler;\n    }\n\n    handleMessageEvent(event) {\n        const wrapper = event.data;\n        super.handleMessage(wrapper);\n    }\n\n    // ------------------------------------------------------------------------\n    // Override abstract base class methods\n\n    postMessageAsPeer(peerName, wrapper) {\n        wrapper.to = peerName;\n        this.iface.postMessage(wrapper);\n    }\n\n    /* Shortcut for makeRequest, so that you don't need to pass the name of the peer\n     * as the first argument.\n     */\n    postRequest(handlerDescrip, args, options) {\n        return this.makeRequest(this.nameOfPeer, handlerDescrip, args, options);\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvZGVkd29ya2VycGVlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGZzYy1pc2UvLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvZGVkd29ya2VycGVlci5qcz82OTRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBicm93c2VyLXBlZXJzIHYwLjEuMCB8IENvcHlyaWdodCAoYykgMjAyMC0yMDIyIFN0ZXZlIEtpZWZmZXIgfCBNSVQgbGljZW5zZSAqL1xuLyogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVCAqL1xuXG5cbmltcG9ydCB7IFBlZXIgfSBmcm9tIFwiLi9wZWVyXCI7XG5cbi8qXG4gKiBUaGlzIHBlZXIgY2xhc3Mgc3VwcG9ydHMgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIGEgcGFnZSBhbmQgYSB3ZWIgd29ya2VyLFxuICogc3BlY2lmaWNhbGx5IGEgKmRlZGljYXRlZCogd29ya2VyLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICBJbiB0aGUgcGFnZTpcbiAqXG4gKiAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoJ3dvcmtlci5qcycpO1xuICogICAgICBjb25zdCBwZWVyID0gbmV3IERlZGljYXRlZFdvcmtlclBlZXIod29ya2VyKTtcbiAqXG4gKiAgSW4gdGhlIHdvcmtlciBzY3JpcHQgKHdvcmtlci5qcyBpbiB0aGlzIGV4YW1wbGUpOlxuICpcbiAqICAgICAgY29uc3QgcGVlciA9IG5ldyBEZWRpY2F0ZWRXb3JrZXJQZWVyKHNlbGYpO1xuICpcbiAqL1xuZXhwb3J0IGNsYXNzIERlZGljYXRlZFdvcmtlclBlZXIgZXh0ZW5kcyBQZWVyIHtcblxuICAgIC8qXG4gICAgICogQHBhcmFtIGlmYWNlIHtXb3JrZXIsIERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlfSBBbiBpbnRlcmZhY2UgdGhhdCBoYXMgYSBgcG9zdE1lc3NhZ2VgIG1ldGhvZCxcbiAgICAgKiAgIGFuZCBhbiBgb25tZXNzYWdlYCBwcm9wZXJ0eS4gT24gdGhlIHBhZ2Ugc2lkZSB0aGlzIHdpbGwgYmUgdGhlIGBXb3JrZXJgIGluc3RhbmNlIHdpdGggd2hpY2ggeW91XG4gICAgICogICB3YW50IHRvIGNvbW11bmljYXRlLCBhbmQgaW4gdGhlIHdvcmtlciBzY3JpcHQgdGhpcyB3aWxsIGJlIGBzZWxmYC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZmFjZSkge1xuICAgICAgICBjb25zdCBbbXlOYW1lLCBuYW1lT2ZQZWVyXSA9IGlmYWNlIGluc3RhbmNlb2YgV29ya2VyID8gWydwYWdlJywgJ3dvcmtlciddIDogWyd3b3JrZXInLCAncGFnZSddO1xuICAgICAgICBzdXBlcihteU5hbWUpO1xuICAgICAgICB0aGlzLm5hbWVPZlBlZXIgPSBuYW1lT2ZQZWVyO1xuICAgICAgICB0aGlzLmlmYWNlID0gaWZhY2U7XG4gICAgICAgIHRoaXMuYm91bmRNZXNzYWdlSGFuZGxlciA9IHRoaXMuaGFuZGxlTWVzc2FnZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNZXNzYWdpbmcoKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW50IHdheSB0byB0ZXJtaW5hdGUgdGhlIFdvcmtlciwgZnJvbSB0aGUgcGFnZSBzaWRlLlxuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZU9mUGVlciA9PT0gJ3dvcmtlcicpIHtcbiAgICAgICAgICAgIHRoaXMuaWZhY2UudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZU1lc3NhZ2luZygpIHtcbiAgICAgICAgdGhpcy5pZmFjZS5vbm1lc3NhZ2UgPSB0aGlzLmJvdW5kTWVzc2FnZUhhbmRsZXI7XG4gICAgfVxuXG4gICAgaGFuZGxlTWVzc2FnZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBldmVudC5kYXRhO1xuICAgICAgICBzdXBlci5oYW5kbGVNZXNzYWdlKHdyYXBwZXIpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE92ZXJyaWRlIGFic3RyYWN0IGJhc2UgY2xhc3MgbWV0aG9kc1xuXG4gICAgcG9zdE1lc3NhZ2VBc1BlZXIocGVlck5hbWUsIHdyYXBwZXIpIHtcbiAgICAgICAgd3JhcHBlci50byA9IHBlZXJOYW1lO1xuICAgICAgICB0aGlzLmlmYWNlLnBvc3RNZXNzYWdlKHdyYXBwZXIpO1xuICAgIH1cblxuICAgIC8qIFNob3J0Y3V0IGZvciBtYWtlUmVxdWVzdCwgc28gdGhhdCB5b3UgZG9uJ3QgbmVlZCB0byBwYXNzIHRoZSBuYW1lIG9mIHRoZSBwZWVyXG4gICAgICogYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqL1xuICAgIHBvc3RSZXF1ZXN0KGhhbmRsZXJEZXNjcmlwLCBhcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KHRoaXMubmFtZU9mUGVlciwgaGFuZGxlckRlc2NyaXAsIGFyZ3MsIG9wdGlvbnMpO1xuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/browser-peers/src/dedworkerpeer.js\n");

/***/ }),

/***/ "./node_modules/browser-peers/src/errors.js":
/*!**************************************************!*\
  !*** ./node_modules/browser-peers/src/errors.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NoGroupError\": () => (/* binding */ NoGroupError),\n/* harmony export */   \"ExtensionUnavailableError\": () => (/* binding */ ExtensionUnavailableError),\n/* harmony export */   \"UnknownPeerError\": () => (/* binding */ UnknownPeerError),\n/* harmony export */   \"LackingHostPermissionError\": () => (/* binding */ LackingHostPermissionError),\n/* harmony export */   \"FetchResolvedNotOkError\": () => (/* binding */ FetchResolvedNotOkError),\n/* harmony export */   \"FetchRejectedError\": () => (/* binding */ FetchRejectedError),\n/* harmony export */   \"FetchWrongContentTypeError\": () => (/* binding */ FetchWrongContentTypeError),\n/* harmony export */   \"reconstituteError\": () => (/* binding */ reconstituteError)\n/* harmony export */ });\n/*! browser-peers v0.1.0 | Copyright (c) 2020-2022 Steve Kieffer | MIT license */\n/* SPDX-License-Identifier: MIT */\n\n/*\n * Here we define special error classes that are designed to be serializable.\n * This is so that they can be communicated via various messaging systems,\n * and then reconstructed on the other side.\n *\n * All error classes defined here MUST:\n *\n *   * have a constructor that accepts an object\n *\n *   * define `this.name` equal to their own class name (as string!)\n *\n *   * be registered in `KNOWN_ERROR_CLASSES` (see below) under their class name\n *\n *   * have a `serialize()` method that returns the JSON.stringify of an\n *     object that:\n *       - can be passed to the class's constructor, and\n *       - includes `_error_class_name: this.name`\n *\n */\n\n// ---------------------------------------------------------------------------\n// Special error classes\n\n/*\n * This error class represents cases in which we are trying to do something\n * that involves belonging to a group, but we do not (yet) belong to one.\n */\nclass NoGroupError extends Error {\n\n    constructor({ message }) {\n        super(message);\n        this.name = \"NoGroupError\";\n    }\n\n    serialize() {\n        return JSON.stringify({\n            _error_class_name: this.name,\n            message: this.message,\n        });\n    }\n\n}\n\n/*\n * This error class is intended to represent cases in which the extension has\n * become unavailable. Usually (actually the only case I'm currently aware of)\n * this is because the extension was uninstalled after that page was loaded.\n */\nclass ExtensionUnavailableError extends Error {\n\n    constructor({ message }) {\n        super(message);\n        this.name = \"ExtensionUnavailableError\";\n    }\n\n    serialize() {\n        return JSON.stringify({\n            _error_class_name: this.name,\n            message: this.message,\n        });\n    }\n\n}\n\n/* Represents cases in which a Peer is attempting to look up another\n * Peer, but cannot find it.\n */\nclass UnknownPeerError extends Error {\n\n    constructor({ message }) {\n        super(message);\n        this.name = \"UnknownPeerError\";\n    }\n\n    serialize() {\n        return JSON.stringify({\n            _error_class_name: this.name,\n            message: this.message,\n        });\n    }\n\n}\n\n/*\n * This represents cases in which the extension is lacking host permission\n * for a given URL.\n */\nclass LackingHostPermissionError extends Error {\n\n    constructor({ url }) {\n        super(`Extension lacks host permission for ${url}.`);\n        this.name = \"LackingHostPermissionError\";\n        this.url = url;\n    }\n\n    serialize() {\n        return JSON.stringify({\n            _error_class_name: this.name,\n            url: this.url,\n        });\n    }\n}\n\n/*\n * Superclass of more specific fetch error types defined below.\n * For now, not exported, since I think users only need the more specific types.\n */\nclass FetchError extends Error {\n\n    /* We record those attributes of a fetch Response object\n     * (see <https://developer.mozilla.org/en-US/docs/Web/API/Response>)\n     * that we think will be useful (and that we want to bother with right\n     * now -- maybe more in the future).\n     *\n     * Note that you may pass a Response instance itself to this constructor.\n     */\n    constructor({ ok, status, statusText, type, url, headers, contentType }) {\n        const message = `Fetch ${url} status: ${status} ${statusText}`;\n        super(message);\n        this.name = 'FetchError';\n        this.ok = ok;\n        this.status = status;\n        this.statusText = statusText;\n        this.type = type;\n        this.url = url;\n        this.contentType = contentType;\n        if (headers && headers.get) {\n            try {\n                this.contentType = headers.get('Content-Type');\n            } catch (e) {\n            }\n        }\n    }\n\n    serialize() {\n        return JSON.stringify({\n            _error_class_name: this.name,\n            ok: this.ok,\n            status: this.status,\n            statusText: this.statusText,\n            type: this.type,\n            url: this.url,\n            contentType: this.contentType,\n        });\n    }\n\n}\n\n/*\n * This error class is intended to represent cases in which a `fetch` promise\n * resolved, but returned a Response object whose `ok` property was `false`.\n *\n * On both Chrome and Firefox, this will be the case when we successfully\n * received a response, but it had an HTTP status outside the 200-299 range.\n */\nclass FetchResolvedNotOkError extends FetchError {\n\n    constructor({ ok, status, statusText, type, url }) {\n        super({ ok, status, statusText, type, url });\n        this.name = 'FetchResolvedNotOkError';\n    }\n\n}\n\n/*\n * This error class is intended to represent cases in which a `fetch` promise rejected.\n *\n * For example, on both Chrome and Firefox, this will be the case when we attempt to make a\n * cross-origin fetch, but CORS fails due to absence of Access-Control-Allow-Origin header.\n */\nclass FetchRejectedError extends FetchError {\n\n    constructor({ ok, status, statusText, type, url }) {\n        super({ ok, status, statusText, type, url });\n        this.name = 'FetchRejectedError';\n        this.message = 'Fetch rejected. ' + this.message;\n    }\n\n}\n\n/*\n * Represents cases in which a `fetch` resolved with `ok` but with an unexpected\n * Content-Type header.\n */\nclass FetchWrongContentTypeError extends FetchError {\n\n    constructor({ ok, status, statusText, type, url, headers, contentType }) {\n        super({ ok, status, statusText, type, url, headers, contentType });\n        this.name = 'FetchWrongContentTypeError';\n        this.message = `Fetch ${url} received unexpected Content-Type: ${contentType}`;\n    }\n\n}\n\n// ---------------------------------------------------------------------------\n// Reconstitution\n\nconst KNOWN_ERROR_CLASSES = new Map()\n    .set(\"FetchResolvedNotOkError\", FetchResolvedNotOkError)\n    .set(\"FetchRejectedError\", FetchRejectedError)\n    .set(\"NoGroupError\", NoGroupError)\n    .set(\"ExtensionUnavailableError\", ExtensionUnavailableError)\n    .set(\"LackingHostPermissionError\", LackingHostPermissionError)\n    .set(\"FetchWrongContentTypeError\", FetchWrongContentTypeError)\n    .set(\"UnknownPeerError\", UnknownPeerError)\n;\n\n/* Attempt to reconstitute a special error class instance from a generic Error.\n * We look at the message of the given Error. If it appears to be the serialization\n * of one of our special error classes, then we rebuild an instance based on this.\n * Otherwise we just return the given Error.\n *\n * param error: an Error instance\n * return: the reconstituted error, or the given one.\n */\nfunction reconstituteError(error) {\n    let d = null;\n    try {\n        d = JSON.parse(error.message);\n    } catch {}\n    if (d && KNOWN_ERROR_CLASSES.has(d._error_class_name)) {\n        const ClassConstructor = KNOWN_ERROR_CLASSES.get(d._error_class_name);\n        return new ClassConstructor(d);\n    }\n    return error;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvZXJyb3JzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZnNjLWlzZS8uL25vZGVfbW9kdWxlcy9icm93c2VyLXBlZXJzL3NyYy9lcnJvcnMuanM/YzQxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgYnJvd3Nlci1wZWVycyB2MC4xLjAgfCBDb3B5cmlnaHQgKGMpIDIwMjAtMjAyMiBTdGV2ZSBLaWVmZmVyIHwgTUlUIGxpY2Vuc2UgKi9cbi8qIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQgKi9cblxuLypcbiAqIEhlcmUgd2UgZGVmaW5lIHNwZWNpYWwgZXJyb3IgY2xhc3NlcyB0aGF0IGFyZSBkZXNpZ25lZCB0byBiZSBzZXJpYWxpemFibGUuXG4gKiBUaGlzIGlzIHNvIHRoYXQgdGhleSBjYW4gYmUgY29tbXVuaWNhdGVkIHZpYSB2YXJpb3VzIG1lc3NhZ2luZyBzeXN0ZW1zLFxuICogYW5kIHRoZW4gcmVjb25zdHJ1Y3RlZCBvbiB0aGUgb3RoZXIgc2lkZS5cbiAqXG4gKiBBbGwgZXJyb3IgY2xhc3NlcyBkZWZpbmVkIGhlcmUgTVVTVDpcbiAqXG4gKiAgICogaGF2ZSBhIGNvbnN0cnVjdG9yIHRoYXQgYWNjZXB0cyBhbiBvYmplY3RcbiAqXG4gKiAgICogZGVmaW5lIGB0aGlzLm5hbWVgIGVxdWFsIHRvIHRoZWlyIG93biBjbGFzcyBuYW1lIChhcyBzdHJpbmchKVxuICpcbiAqICAgKiBiZSByZWdpc3RlcmVkIGluIGBLTk9XTl9FUlJPUl9DTEFTU0VTYCAoc2VlIGJlbG93KSB1bmRlciB0aGVpciBjbGFzcyBuYW1lXG4gKlxuICogICAqIGhhdmUgYSBgc2VyaWFsaXplKClgIG1ldGhvZCB0aGF0IHJldHVybnMgdGhlIEpTT04uc3RyaW5naWZ5IG9mIGFuXG4gKiAgICAgb2JqZWN0IHRoYXQ6XG4gKiAgICAgICAtIGNhbiBiZSBwYXNzZWQgdG8gdGhlIGNsYXNzJ3MgY29uc3RydWN0b3IsIGFuZFxuICogICAgICAgLSBpbmNsdWRlcyBgX2Vycm9yX2NsYXNzX25hbWU6IHRoaXMubmFtZWBcbiAqXG4gKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTcGVjaWFsIGVycm9yIGNsYXNzZXNcblxuLypcbiAqIFRoaXMgZXJyb3IgY2xhc3MgcmVwcmVzZW50cyBjYXNlcyBpbiB3aGljaCB3ZSBhcmUgdHJ5aW5nIHRvIGRvIHNvbWV0aGluZ1xuICogdGhhdCBpbnZvbHZlcyBiZWxvbmdpbmcgdG8gYSBncm91cCwgYnV0IHdlIGRvIG5vdCAoeWV0KSBiZWxvbmcgdG8gb25lLlxuICovXG5leHBvcnQgY2xhc3MgTm9Hcm91cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0pIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTm9Hcm91cEVycm9yXCI7XG4gICAgfVxuXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgX2Vycm9yX2NsYXNzX25hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG5cbi8qXG4gKiBUaGlzIGVycm9yIGNsYXNzIGlzIGludGVuZGVkIHRvIHJlcHJlc2VudCBjYXNlcyBpbiB3aGljaCB0aGUgZXh0ZW5zaW9uIGhhc1xuICogYmVjb21lIHVuYXZhaWxhYmxlLiBVc3VhbGx5IChhY3R1YWxseSB0aGUgb25seSBjYXNlIEknbSBjdXJyZW50bHkgYXdhcmUgb2YpXG4gKiB0aGlzIGlzIGJlY2F1c2UgdGhlIGV4dGVuc2lvbiB3YXMgdW5pbnN0YWxsZWQgYWZ0ZXIgdGhhdCBwYWdlIHdhcyBsb2FkZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHRlbnNpb25VbmF2YWlsYWJsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0pIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRXh0ZW5zaW9uVW5hdmFpbGFibGVFcnJvclwiO1xuICAgIH1cblxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIF9lcnJvcl9jbGFzc19uYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG4vKiBSZXByZXNlbnRzIGNhc2VzIGluIHdoaWNoIGEgUGVlciBpcyBhdHRlbXB0aW5nIHRvIGxvb2sgdXAgYW5vdGhlclxuICogUGVlciwgYnV0IGNhbm5vdCBmaW5kIGl0LlxuICovXG5leHBvcnQgY2xhc3MgVW5rbm93blBlZXJFcnJvciBleHRlbmRzIEVycm9yIHtcblxuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlVua25vd25QZWVyRXJyb3JcIjtcbiAgICB9XG5cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBfZXJyb3JfY2xhc3NfbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuLypcbiAqIFRoaXMgcmVwcmVzZW50cyBjYXNlcyBpbiB3aGljaCB0aGUgZXh0ZW5zaW9uIGlzIGxhY2tpbmcgaG9zdCBwZXJtaXNzaW9uXG4gKiBmb3IgYSBnaXZlbiBVUkwuXG4gKi9cbmV4cG9ydCBjbGFzcyBMYWNraW5nSG9zdFBlcm1pc3Npb25FcnJvciBleHRlbmRzIEVycm9yIHtcblxuICAgIGNvbnN0cnVjdG9yKHsgdXJsIH0pIHtcbiAgICAgICAgc3VwZXIoYEV4dGVuc2lvbiBsYWNrcyBob3N0IHBlcm1pc3Npb24gZm9yICR7dXJsfS5gKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJMYWNraW5nSG9zdFBlcm1pc3Npb25FcnJvclwiO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICB9XG5cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBfZXJyb3JfY2xhc3NfbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKlxuICogU3VwZXJjbGFzcyBvZiBtb3JlIHNwZWNpZmljIGZldGNoIGVycm9yIHR5cGVzIGRlZmluZWQgYmVsb3cuXG4gKiBGb3Igbm93LCBub3QgZXhwb3J0ZWQsIHNpbmNlIEkgdGhpbmsgdXNlcnMgb25seSBuZWVkIHRoZSBtb3JlIHNwZWNpZmljIHR5cGVzLlxuICovXG5jbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgLyogV2UgcmVjb3JkIHRob3NlIGF0dHJpYnV0ZXMgb2YgYSBmZXRjaCBSZXNwb25zZSBvYmplY3RcbiAgICAgKiAoc2VlIDxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVzcG9uc2U+KVxuICAgICAqIHRoYXQgd2UgdGhpbmsgd2lsbCBiZSB1c2VmdWwgKGFuZCB0aGF0IHdlIHdhbnQgdG8gYm90aGVyIHdpdGggcmlnaHRcbiAgICAgKiBub3cgLS0gbWF5YmUgbW9yZSBpbiB0aGUgZnV0dXJlKS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB5b3UgbWF5IHBhc3MgYSBSZXNwb25zZSBpbnN0YW5jZSBpdHNlbGYgdG8gdGhpcyBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG9rLCBzdGF0dXMsIHN0YXR1c1RleHQsIHR5cGUsIHVybCwgaGVhZGVycywgY29udGVudFR5cGUgfSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZldGNoICR7dXJsfSBzdGF0dXM6ICR7c3RhdHVzfSAke3N0YXR1c1RleHR9YDtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdGZXRjaEVycm9yJztcbiAgICAgICAgdGhpcy5vayA9IG9rO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZTtcbiAgICAgICAgaWYgKGhlYWRlcnMgJiYgaGVhZGVycy5nZXQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIF9lcnJvcl9jbGFzc19uYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBvazogdGhpcy5vayxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IHRoaXMuY29udGVudFR5cGUsXG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG4vKlxuICogVGhpcyBlcnJvciBjbGFzcyBpcyBpbnRlbmRlZCB0byByZXByZXNlbnQgY2FzZXMgaW4gd2hpY2ggYSBgZmV0Y2hgIHByb21pc2VcbiAqIHJlc29sdmVkLCBidXQgcmV0dXJuZWQgYSBSZXNwb25zZSBvYmplY3Qgd2hvc2UgYG9rYCBwcm9wZXJ0eSB3YXMgYGZhbHNlYC5cbiAqXG4gKiBPbiBib3RoIENocm9tZSBhbmQgRmlyZWZveCwgdGhpcyB3aWxsIGJlIHRoZSBjYXNlIHdoZW4gd2Ugc3VjY2Vzc2Z1bGx5XG4gKiByZWNlaXZlZCBhIHJlc3BvbnNlLCBidXQgaXQgaGFkIGFuIEhUVFAgc3RhdHVzIG91dHNpZGUgdGhlIDIwMC0yOTkgcmFuZ2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaFJlc29sdmVkTm90T2tFcnJvciBleHRlbmRzIEZldGNoRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IoeyBvaywgc3RhdHVzLCBzdGF0dXNUZXh0LCB0eXBlLCB1cmwgfSkge1xuICAgICAgICBzdXBlcih7IG9rLCBzdGF0dXMsIHN0YXR1c1RleHQsIHR5cGUsIHVybCB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ZldGNoUmVzb2x2ZWROb3RPa0Vycm9yJztcbiAgICB9XG5cbn1cblxuLypcbiAqIFRoaXMgZXJyb3IgY2xhc3MgaXMgaW50ZW5kZWQgdG8gcmVwcmVzZW50IGNhc2VzIGluIHdoaWNoIGEgYGZldGNoYCBwcm9taXNlIHJlamVjdGVkLlxuICpcbiAqIEZvciBleGFtcGxlLCBvbiBib3RoIENocm9tZSBhbmQgRmlyZWZveCwgdGhpcyB3aWxsIGJlIHRoZSBjYXNlIHdoZW4gd2UgYXR0ZW1wdCB0byBtYWtlIGFcbiAqIGNyb3NzLW9yaWdpbiBmZXRjaCwgYnV0IENPUlMgZmFpbHMgZHVlIHRvIGFic2VuY2Ugb2YgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luIGhlYWRlci5cbiAqL1xuZXhwb3J0IGNsYXNzIEZldGNoUmVqZWN0ZWRFcnJvciBleHRlbmRzIEZldGNoRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IoeyBvaywgc3RhdHVzLCBzdGF0dXNUZXh0LCB0eXBlLCB1cmwgfSkge1xuICAgICAgICBzdXBlcih7IG9rLCBzdGF0dXMsIHN0YXR1c1RleHQsIHR5cGUsIHVybCB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ZldGNoUmVqZWN0ZWRFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9ICdGZXRjaCByZWplY3RlZC4gJyArIHRoaXMubWVzc2FnZTtcbiAgICB9XG5cbn1cblxuLypcbiAqIFJlcHJlc2VudHMgY2FzZXMgaW4gd2hpY2ggYSBgZmV0Y2hgIHJlc29sdmVkIHdpdGggYG9rYCBidXQgd2l0aCBhbiB1bmV4cGVjdGVkXG4gKiBDb250ZW50LVR5cGUgaGVhZGVyLlxuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hXcm9uZ0NvbnRlbnRUeXBlRXJyb3IgZXh0ZW5kcyBGZXRjaEVycm9yIHtcblxuICAgIGNvbnN0cnVjdG9yKHsgb2ssIHN0YXR1cywgc3RhdHVzVGV4dCwgdHlwZSwgdXJsLCBoZWFkZXJzLCBjb250ZW50VHlwZSB9KSB7XG4gICAgICAgIHN1cGVyKHsgb2ssIHN0YXR1cywgc3RhdHVzVGV4dCwgdHlwZSwgdXJsLCBoZWFkZXJzLCBjb250ZW50VHlwZSB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ZldGNoV3JvbmdDb250ZW50VHlwZUVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYEZldGNoICR7dXJsfSByZWNlaXZlZCB1bmV4cGVjdGVkIENvbnRlbnQtVHlwZTogJHtjb250ZW50VHlwZX1gO1xuICAgIH1cblxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlY29uc3RpdHV0aW9uXG5cbmNvbnN0IEtOT1dOX0VSUk9SX0NMQVNTRVMgPSBuZXcgTWFwKClcbiAgICAuc2V0KFwiRmV0Y2hSZXNvbHZlZE5vdE9rRXJyb3JcIiwgRmV0Y2hSZXNvbHZlZE5vdE9rRXJyb3IpXG4gICAgLnNldChcIkZldGNoUmVqZWN0ZWRFcnJvclwiLCBGZXRjaFJlamVjdGVkRXJyb3IpXG4gICAgLnNldChcIk5vR3JvdXBFcnJvclwiLCBOb0dyb3VwRXJyb3IpXG4gICAgLnNldChcIkV4dGVuc2lvblVuYXZhaWxhYmxlRXJyb3JcIiwgRXh0ZW5zaW9uVW5hdmFpbGFibGVFcnJvcilcbiAgICAuc2V0KFwiTGFja2luZ0hvc3RQZXJtaXNzaW9uRXJyb3JcIiwgTGFja2luZ0hvc3RQZXJtaXNzaW9uRXJyb3IpXG4gICAgLnNldChcIkZldGNoV3JvbmdDb250ZW50VHlwZUVycm9yXCIsIEZldGNoV3JvbmdDb250ZW50VHlwZUVycm9yKVxuICAgIC5zZXQoXCJVbmtub3duUGVlckVycm9yXCIsIFVua25vd25QZWVyRXJyb3IpXG47XG5cbi8qIEF0dGVtcHQgdG8gcmVjb25zdGl0dXRlIGEgc3BlY2lhbCBlcnJvciBjbGFzcyBpbnN0YW5jZSBmcm9tIGEgZ2VuZXJpYyBFcnJvci5cbiAqIFdlIGxvb2sgYXQgdGhlIG1lc3NhZ2Ugb2YgdGhlIGdpdmVuIEVycm9yLiBJZiBpdCBhcHBlYXJzIHRvIGJlIHRoZSBzZXJpYWxpemF0aW9uXG4gKiBvZiBvbmUgb2Ygb3VyIHNwZWNpYWwgZXJyb3IgY2xhc3NlcywgdGhlbiB3ZSByZWJ1aWxkIGFuIGluc3RhbmNlIGJhc2VkIG9uIHRoaXMuXG4gKiBPdGhlcndpc2Ugd2UganVzdCByZXR1cm4gdGhlIGdpdmVuIEVycm9yLlxuICpcbiAqIHBhcmFtIGVycm9yOiBhbiBFcnJvciBpbnN0YW5jZVxuICogcmV0dXJuOiB0aGUgcmVjb25zdGl0dXRlZCBlcnJvciwgb3IgdGhlIGdpdmVuIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY29uc3RpdHV0ZUVycm9yKGVycm9yKSB7XG4gICAgbGV0IGQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGQgPSBKU09OLnBhcnNlKGVycm9yLm1lc3NhZ2UpO1xuICAgIH0gY2F0Y2gge31cbiAgICBpZiAoZCAmJiBLTk9XTl9FUlJPUl9DTEFTU0VTLmhhcyhkLl9lcnJvcl9jbGFzc19uYW1lKSkge1xuICAgICAgICBjb25zdCBDbGFzc0NvbnN0cnVjdG9yID0gS05PV05fRVJST1JfQ0xBU1NFUy5nZXQoZC5fZXJyb3JfY2xhc3NfbmFtZSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2xhc3NDb25zdHJ1Y3RvcihkKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/browser-peers/src/errors.js\n");

/***/ }),

/***/ "./node_modules/browser-peers/src/peer.js":
/*!************************************************!*\
  !*** ./node_modules/browser-peers/src/peer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Peer\": () => (/* binding */ Peer)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ \"./node_modules/browser-peers/src/errors.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./node_modules/browser-peers/src/util.js\");\n/*! browser-peers v0.1.0 | Copyright (c) 2020-2022 Steve Kieffer | MIT license */\n/* SPDX-License-Identifier: MIT */\n\n\n\n\n/* This is the abstract base class for all of our peer classes.\n * It implements everything to do with making and handling requests and responses.\n *\n * Subclasses are responsible for establishing connections between peers,\n * and for implementing the abstract `postMessageAsPeer` method defined by this\n * base class.\n *\n */\nclass Peer extends _util__WEBPACK_IMPORTED_MODULE_1__.Listenable {\n\n    /*\n     * @param name {string} a unique name for this peer, to tell it apart\n     *   from all others.\n     */\n    constructor(name) {\n        super({});\n\n        // For development and testing in settings like browser extensions under\n        // Manifest V3 (where background scripts are repeatedly terminated and\n        // restarted) it can be helpful to print debugging output in which we see\n        // the time at which a given peer was constructed.\n        this.constructionTime = (new Date()).toLocaleTimeString();\n\n        this.name = name;\n        this.handlers = new Map();\n        this.nextSeqNum = 0;\n        this.requestsBySeqNum = new Map();\n\n        this.reconstituteErrors = false;\n\n        this.readyResolve = null;\n        const self = this;\n        this.readyPromise = new Promise(resolve => {\n            self.readyResolve = resolve;\n        });\n\n        this.builtInHandlers = new Map()\n            .set('ready', this.ready.bind(this))\n        ;\n        for (let [name, handler] of this.builtInHandlers) {\n            this._addHandler(name, handler);\n        }\n    }\n\n    fromAddress() {\n        return this.name;\n    }\n\n    copyMessage(msg) {\n        return JSON.parse(JSON.stringify(msg));\n    }\n\n    // ------------------------------------------------------------------------\n    // Message handling\n\n    /* Subclasses should pass incoming request/response wrapper messages to this method.\n     *\n     * wrapper format: {\n     *   type {string} 'request' or 'response'\n     * }\n     *\n     * Furthermore, the wrapper must conform to the required format of `this.handleRequest`\n     * or `this.handleResponse`, according to the value of `wrapper.type`.\n     *\n     */\n    handleMessage(wrapper) {\n        if (wrapper.type === 'request') {\n            this.handleRequest(wrapper);\n        } else {\n            this.handleResponse(wrapper);\n        }\n    }\n\n    /*\n     * wrapper format: {\n     *   from {string} the name of the peer that sent the message,\n     *   seqNum {int} sequence number that will be used to associate response with request,\n     *   handlerDescrip {string} should be a valid descriptor string pointing to a handler\n     *     that has been registered with this peer,\n     *   args {any} will be passed to the handler\n     * }\n     */\n    handleRequest(wrapper) {\n        const peerName = wrapper.from;\n        const seqNum = wrapper.seqNum;\n        const handlerDescrip = wrapper.handlerDescrip;\n        const args = wrapper.args;\n        let handler;\n        try {\n            handler = this.lookupHandler(handlerDescrip);\n        } catch (e) {\n            this.returnRejection(peerName, seqNum, e);\n            return;\n        }\n        // Call the handler inside `Promise.resolve` so we can work with it asynchronously,\n        // even if the handler returns synchronously.\n        // We pass the whole wrapper as a second argument (which the handler may choose\n        // to ignore), in case the handler needs the \"meta\" information (such as the peer name).\n        Promise.resolve(handler(args, wrapper)).then(result => {\n            this.returnResponse(peerName, seqNum, result);\n        }).catch(reason => {\n            reason = this.checkHandlingError(reason, wrapper);\n            this.returnRejection(peerName, seqNum, reason);\n        });\n    }\n\n    /*\n     * @param peerName {string}\n     * @param seqNum {int}\n     * @param result {any}\n     */\n    returnResponse(peerName, seqNum, result) {\n        const wrapper = {\n            type: 'response',\n            from: this.fromAddress(),\n            seqNum: seqNum,\n            result: result,\n        };\n        this.postMessageAsPeer(peerName, wrapper);\n    }\n\n    /*\n     * @param peerName {string}\n     * @param seqNum {int}\n     * @param reason: {Error}\n     */\n    returnRejection(peerName, seqNum, reason) {\n        const wrapper = {\n            type: 'response',\n            from: this.fromAddress(),\n            seqNum: seqNum,\n            rejection_reason: reason.message,\n        };\n        this.postMessageAsPeer(peerName, wrapper);\n    }\n\n    consumeRequestData(seqNum) {\n        const data = this.requestsBySeqNum.get(seqNum);\n        if (data) window.clearTimeout(data.timeoutHandle);  // fails gracefully if timeout already cleared or handle is null\n        this.requestsBySeqNum.delete(seqNum);\n        return data;\n    }\n\n    /*\n     * wrapper format: {\n     *   REQUIRED:\n     *      from {string} the name of the peer that sent the message,\n     *      seqNum {int} sequence number that will be used to associate response with request,\n     *   EITHER/OR:\n     *      result {any} if the call was successful, this is the result to be returned.\n     *      rejection_reason {string} if the call failed, this is an indication of the reason.\n     * }\n     */\n    handleResponse(wrapper) {\n        const data = this.consumeRequestData(wrapper.seqNum);\n        if (!data) {\n            // Should only happen if request data already consumed due to timeout.\n            // In that case, caller already has their answer. So just do nothing.\n            return;\n        }\n        if (wrapper.rejection_reason) {\n            let e = new Error(wrapper.rejection_reason);\n            if (this.reconstituteErrors) {\n                e = (0,_errors__WEBPACK_IMPORTED_MODULE_0__.reconstituteError)(e);\n            }\n            data.reject(e);\n        } else {\n            data.resolve(wrapper.result);\n        }\n    }\n\n    // ------------------------------------------------------------------------\n    // Readiness\n    //\n    //   To be clear: this means readiness to handle requests, not to accept connections.\n    //   A peer instance is immediately ready to accept connections after construction.\n\n    /* Call this when you've finished adding handlers, in order to declare that this\n     * peer is ready to handle requests.\n     */\n    setReady() {\n        this.readyResolve();\n    }\n\n    /* This is our built-in handler for the 'ready' handler description.\n     *\n     * It returns a promise that other peers can use to wait until this peer is ready\n     * to accept connections.\n     */\n    ready() {\n        return this.readyPromise;\n    }\n\n    /* Convenience method to check the readiness of a connected peer.\n     */\n    checkReady(peerName) {\n        return this.makeRequest(peerName, 'ready', {}, false);\n    }\n\n    // ------------------------------------------------------------------------\n    // Request handlers\n\n    /* Add a handler function or handler object.\n     *\n     * Handler functions will be passed two arguments: `args` and `meta`. The first is an\n     * object passed by the client and presumably containing all the arguments required by\n     * the handler; the second is an object containing meta information about the request,\n     * such as the name of the client (which is under `meta.from`).\n     *\n     * Handlers may return a value synchronously, or may return a Promise. Either is acceptable.\n     *\n     * You may not register a handler under a reserved name, i.e. the names of any of our\n     * built-in handlers. These are defined in the constructor.\n     *\n     * @return: this instance, to support chaining.\n     */\n    addHandler(name, handler) {\n        if (this.builtInHandlers.has(name)) {\n            throw new Error(`Cannot register handler under reserved name: ${name}`);\n        }\n        this._addHandler(name, handler);\n        return this;\n    }\n\n    _addHandler(name, handler) {\n        this.handlers.set(name, handler);\n    }\n\n    /* Add a \"built-in handler,\" which really means a handler such that an error\n     * will be thrown if anyone tries to add a handler by the same name using the\n     * usual `addHandler` method.\n     *\n     * If the language supported it, we would make this a protected method, i.e.\n     * usable only by subclasses. So don't use it unless you should!\n     */\n    _addBuiltInHandler(name, handler) {\n        this.builtInHandlers.set(name, handler);\n        this._addHandler(name, handler);\n    }\n\n    /* Look up a handler, by its description.\n     *\n     * A handler description should be a string naming something that has been added as a\n     * handler for this server, or an attribute thereof, recursively.\n     *\n     * For example, if `myFunc` is a function, then after\n     *      server.addHandler('f', myFunc)\n     * 'f' is a valid description.\n     *\n     * If `myInstance` is an instance of a class that has a `doSomething` method, then\n     * after\n     *      server.addHandler('foo', myInstance)\n     * 'foo.doSomething' is a valid description.\n     *\n     * @param descrip {string} the description of the handler.\n     * @return: the handler. If the description was dotted, then the returned handler function\n     *   has the previous object in the chain bound as `this`.\n     * @throws: Error if the description does not resolve to anything, or if it does but that\n     *   thing is not a function.\n     */\n    lookupHandler(descrip) {\n        const parts = descrip.split('.');\n        let first = true;\n        let handler;\n        let prev;\n        for (let part of parts) {\n            if (first) {\n                first = false;\n                handler = this.handlers.get(part);\n            } else if (handler) {\n                prev = handler;\n                handler = handler[part];\n            } else {\n                break;\n            }\n        }\n        if (!handler) {\n            throw new Error(`Unknown handler: ${descrip}`);\n        }\n        if (typeof handler !== \"function\") {\n            throw new Error(`Handler \"${descrip}\" is not a function`);\n        }\n        if (prev) {\n            handler = handler.bind(prev);\n        }\n        return handler;\n    }\n\n    /* If you are on the same side as a peer, you can use this method to call\n     * one of its handlers directly, instead of within a request/response pair.\n     */\n    callHandler(handlerDescrip, args) {\n        const handler = this.lookupHandler(handlerDescrip);\n        return handler(args);\n    }\n\n    // ------------------------------------------------------------------------\n    // Making requests\n\n    takeNextSeqNum() {\n        const n = this.nextSeqNum;\n        this.nextSeqNum = n + 1;\n        return n;\n    }\n\n    /* Send a request to a single peer.\n     *\n     * @param peerName {string} The name of the peer to which the request should be sent.\n     * @param handlerDescrip {string} A description indicating the desired handler for the\n     *   request on the other side.\n     * @param args {obj} the arguments object to be passed to the handler on the other side.\n     *\n     * @param options: {\n     *   doReadyCheck {bool} optional, default false. Set true if you want to precede\n     *     the request with a ready check.\n     *   timeout {int} optional, default 0. Set positive if you want the request to timeout\n     *     after this many milliseconds. If 0 (or negative), will wait indefinitely.\n     *     In case of timeout, the returned promise rejects.\n     * }\n     *\n     * @return {Promise} promise that resolves with the response to the request, or rejects\n     *   with an error.\n     *\n     * See also: `broadcastRequest`.\n     */\n    makeRequest(peerName, handlerDescrip, args, options) {\n        const {\n            doReadyCheck = false,\n            timeout = 0,\n        } = options || {};\n        const seqNum = this.takeNextSeqNum();\n        const wrapper = {\n            type: 'request',\n            from: this.fromAddress(),\n            seqNum: seqNum,\n            handlerDescrip: handlerDescrip,\n            args: args,\n        };\n        const check = doReadyCheck ? this.checkReady(peerName) : Promise.resolve();\n        return check.then(() => {\n            return new Promise((resolve, reject) => {\n                const timeoutHandle = timeout < 1 ? null : window.setTimeout(() => {\n                    const data = this.consumeRequestData(seqNum);\n                    if (!data) return; // Request was already handled.\n                    reject(new Error('Peer request timed out.'));\n                }, timeout);\n                this.requestsBySeqNum.set(seqNum, {\n                    resolve: resolve,\n                    reject: reject,\n                    timeoutHandle: timeoutHandle,\n                });\n                this.postMessageAsPeer(peerName, wrapper);\n            });\n        });\n    }\n\n    /* Broadcast a request to all connected peers (or a subset, by filtering).\n     *\n     * This just performs multiple requests. Particular subclasses may have more\n     * efficient ways of broadcasting that they may prefer to use instead.\n     *\n     * @param handlerDescrip {string} A description indicating the desired handler for the\n     *   request on the other side.\n     * @param args {obj} the arguments object to be passed to the handler on the other side.\n     *\n     * @param options: {\n     *   excludeSelf {bool} If true, do not send the request to self. This is relevant for\n     *     some peer types that keep their own name in their set of peers; for those that\n     *     do not, it can be ignored.\n     *   filter {function} optional function mapping peer names to booleans. Allows to\n     *     broadcast to a subset of all connected peers, namely those mapping to `true`.\n     *     If `excludeSelf` is true, that exclusion happens first, and the given filter\n     *     is applied to what remains.\n     *   skipReadyChecks {bool} optional, default false. If false we will precede each\n     *     request with a readiness check. Set true to skip.\n     * }\n     *\n     * @return {Array[Promise]} array of the promises returned by our `makeRequest` method,\n     *   one for each peer to which a request was sent.\n     *\n     * See also: `makeRequest`.\n     *\n     * Note: While in the `makeRequest` method the ready check is skipped by default, here the\n     *   behavior is the opposite, and the ready checks are performed by default. It is felt that,\n     *   rather than being confusing, this caters to normal usage patterns. It will be normal to\n     *   be broadcasting to a collection of peers for which we are _not_ carefully maintaining state;\n     *   whereas when requesting from a single peer, we are more likely to have already performed an\n     *   initial (one-time) ready check ourselves.\n     */\n    broadcastRequest(handlerDescrip, args, options) {\n        const {\n            excludeSelf = false,\n            filter = (() => true),\n            skipReadyChecks = false\n        } = options || {};\n        const peerNames = this.getAllPeerNames().filter(name => (!excludeSelf) || name !== this.name).filter(filter);\n        const responsePromises = [];\n        for (let peerName of peerNames) {\n            responsePromises.push(this.makeRequest(peerName, handlerDescrip, args, {\n                doReadyCheck: !skipReadyChecks,\n            }));\n        }\n        return responsePromises;\n    }\n\n    // ------------------------------------------------------------------------\n    // Abstract methods subclasses MAY override\n\n    /* Subclasses should override this method if they want to use this\n     * base class's `broadcastRequest` method.\n     *\n     * @return {Array[string]} an Array of the names of all connected peers.\n     */\n    getAllPeerNames() {\n        return [];\n    }\n\n    /* This gives a chance to examine and modify a handler error, and possibly\n     * have side effects, before the error is returned.\n     *\n     * @param reason: Error thrown by request handler.\n     * @param wrapper: the wrapper message that was being handled.\n     * @return: Error instance. May be the same as the given reason, or different.\n     */\n    checkHandlingError(reason, wrapper) {\n        return reason;\n    }\n\n    // ------------------------------------------------------------------------\n    // Abstract methods subclasses MUST override\n\n    /* This is where subclasses must use their transport-specific method of getting\n     * a serializable message from one peer to another.\n     *\n     * Specifically, the message to be communicated here is one of the \"wrapper\"\n     * messages we use to represent requests and responses. The intention therefore\n     * is that it be delivered to the `handleMessage` method of the peer (which should\n     * _not_ be overridden, but should be inherited from this base class).\n     *\n     * @param peerName {string} the name of a connected peer\n     * @param wrapper {obj} the wrapper message to be posted to that peer. Format: {\n     *   type {string} equal to either 'request' or 'response', appropriately.\n     * }\n     */\n    postMessageAsPeer(peerName, wrapper) {\n        //\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvcGVlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGZzYy1pc2UvLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvcGVlci5qcz84NjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBicm93c2VyLXBlZXJzIHYwLjEuMCB8IENvcHlyaWdodCAoYykgMjAyMC0yMDIyIFN0ZXZlIEtpZWZmZXIgfCBNSVQgbGljZW5zZSAqL1xuLyogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVCAqL1xuXG5pbXBvcnQgeyByZWNvbnN0aXR1dGVFcnJvciB9IGZyb20gXCIuL2Vycm9yc1wiO1xuaW1wb3J0IHsgTGlzdGVuYWJsZSB9IGZyb20gXCIuL3V0aWxcIjtcblxuLyogVGhpcyBpcyB0aGUgYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIG9mIG91ciBwZWVyIGNsYXNzZXMuXG4gKiBJdCBpbXBsZW1lbnRzIGV2ZXJ5dGhpbmcgdG8gZG8gd2l0aCBtYWtpbmcgYW5kIGhhbmRsaW5nIHJlcXVlc3RzIGFuZCByZXNwb25zZXMuXG4gKlxuICogU3ViY2xhc3NlcyBhcmUgcmVzcG9uc2libGUgZm9yIGVzdGFibGlzaGluZyBjb25uZWN0aW9ucyBiZXR3ZWVuIHBlZXJzLFxuICogYW5kIGZvciBpbXBsZW1lbnRpbmcgdGhlIGFic3RyYWN0IGBwb3N0TWVzc2FnZUFzUGVlcmAgbWV0aG9kIGRlZmluZWQgYnkgdGhpc1xuICogYmFzZSBjbGFzcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBQZWVyIGV4dGVuZHMgTGlzdGVuYWJsZSB7XG5cbiAgICAvKlxuICAgICAqIEBwYXJhbSBuYW1lIHtzdHJpbmd9IGEgdW5pcXVlIG5hbWUgZm9yIHRoaXMgcGVlciwgdG8gdGVsbCBpdCBhcGFydFxuICAgICAqICAgZnJvbSBhbGwgb3RoZXJzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoe30pO1xuXG4gICAgICAgIC8vIEZvciBkZXZlbG9wbWVudCBhbmQgdGVzdGluZyBpbiBzZXR0aW5ncyBsaWtlIGJyb3dzZXIgZXh0ZW5zaW9ucyB1bmRlclxuICAgICAgICAvLyBNYW5pZmVzdCBWMyAod2hlcmUgYmFja2dyb3VuZCBzY3JpcHRzIGFyZSByZXBlYXRlZGx5IHRlcm1pbmF0ZWQgYW5kXG4gICAgICAgIC8vIHJlc3RhcnRlZCkgaXQgY2FuIGJlIGhlbHBmdWwgdG8gcHJpbnQgZGVidWdnaW5nIG91dHB1dCBpbiB3aGljaCB3ZSBzZWVcbiAgICAgICAgLy8gdGhlIHRpbWUgYXQgd2hpY2ggYSBnaXZlbiBwZWVyIHdhcyBjb25zdHJ1Y3RlZC5cbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rpb25UaW1lID0gKG5ldyBEYXRlKCkpLnRvTG9jYWxlVGltZVN0cmluZygpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmV4dFNlcU51bSA9IDA7XG4gICAgICAgIHRoaXMucmVxdWVzdHNCeVNlcU51bSA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLnJlY29uc3RpdHV0ZUVycm9ycyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucmVhZHlSZXNvbHZlID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBzZWxmLnJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYnVpbHRJbkhhbmRsZXJzID0gbmV3IE1hcCgpXG4gICAgICAgICAgICAuc2V0KCdyZWFkeScsIHRoaXMucmVhZHkuYmluZCh0aGlzKSlcbiAgICAgICAgO1xuICAgICAgICBmb3IgKGxldCBbbmFtZSwgaGFuZGxlcl0gb2YgdGhpcy5idWlsdEluSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEhhbmRsZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmcm9tQWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG5cbiAgICBjb3B5TWVzc2FnZShtc2cpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobXNnKSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTWVzc2FnZSBoYW5kbGluZ1xuXG4gICAgLyogU3ViY2xhc3NlcyBzaG91bGQgcGFzcyBpbmNvbWluZyByZXF1ZXN0L3Jlc3BvbnNlIHdyYXBwZXIgbWVzc2FnZXMgdG8gdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiB3cmFwcGVyIGZvcm1hdDoge1xuICAgICAqICAgdHlwZSB7c3RyaW5nfSAncmVxdWVzdCcgb3IgJ3Jlc3BvbnNlJ1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZ1cnRoZXJtb3JlLCB0aGUgd3JhcHBlciBtdXN0IGNvbmZvcm0gdG8gdGhlIHJlcXVpcmVkIGZvcm1hdCBvZiBgdGhpcy5oYW5kbGVSZXF1ZXN0YFxuICAgICAqIG9yIGB0aGlzLmhhbmRsZVJlc3BvbnNlYCwgYWNjb3JkaW5nIHRvIHRoZSB2YWx1ZSBvZiBgd3JhcHBlci50eXBlYC5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhbmRsZU1lc3NhZ2Uod3JhcHBlcikge1xuICAgICAgICBpZiAod3JhcHBlci50eXBlID09PSAncmVxdWVzdCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVxdWVzdCh3cmFwcGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzcG9uc2Uod3JhcHBlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIHdyYXBwZXIgZm9ybWF0OiB7XG4gICAgICogICBmcm9tIHtzdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBwZWVyIHRoYXQgc2VudCB0aGUgbWVzc2FnZSxcbiAgICAgKiAgIHNlcU51bSB7aW50fSBzZXF1ZW5jZSBudW1iZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gYXNzb2NpYXRlIHJlc3BvbnNlIHdpdGggcmVxdWVzdCxcbiAgICAgKiAgIGhhbmRsZXJEZXNjcmlwIHtzdHJpbmd9IHNob3VsZCBiZSBhIHZhbGlkIGRlc2NyaXB0b3Igc3RyaW5nIHBvaW50aW5nIHRvIGEgaGFuZGxlclxuICAgICAqICAgICB0aGF0IGhhcyBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIHBlZXIsXG4gICAgICogICBhcmdzIHthbnl9IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBoYW5kbGVyXG4gICAgICogfVxuICAgICAqL1xuICAgIGhhbmRsZVJlcXVlc3Qod3JhcHBlcikge1xuICAgICAgICBjb25zdCBwZWVyTmFtZSA9IHdyYXBwZXIuZnJvbTtcbiAgICAgICAgY29uc3Qgc2VxTnVtID0gd3JhcHBlci5zZXFOdW07XG4gICAgICAgIGNvbnN0IGhhbmRsZXJEZXNjcmlwID0gd3JhcHBlci5oYW5kbGVyRGVzY3JpcDtcbiAgICAgICAgY29uc3QgYXJncyA9IHdyYXBwZXIuYXJncztcbiAgICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5sb29rdXBIYW5kbGVyKGhhbmRsZXJEZXNjcmlwKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5SZWplY3Rpb24ocGVlck5hbWUsIHNlcU51bSwgZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCB0aGUgaGFuZGxlciBpbnNpZGUgYFByb21pc2UucmVzb2x2ZWAgc28gd2UgY2FuIHdvcmsgd2l0aCBpdCBhc3luY2hyb25vdXNseSxcbiAgICAgICAgLy8gZXZlbiBpZiB0aGUgaGFuZGxlciByZXR1cm5zIHN5bmNocm9ub3VzbHkuXG4gICAgICAgIC8vIFdlIHBhc3MgdGhlIHdob2xlIHdyYXBwZXIgYXMgYSBzZWNvbmQgYXJndW1lbnQgKHdoaWNoIHRoZSBoYW5kbGVyIG1heSBjaG9vc2VcbiAgICAgICAgLy8gdG8gaWdub3JlKSwgaW4gY2FzZSB0aGUgaGFuZGxlciBuZWVkcyB0aGUgXCJtZXRhXCIgaW5mb3JtYXRpb24gKHN1Y2ggYXMgdGhlIHBlZXIgbmFtZSkuXG4gICAgICAgIFByb21pc2UucmVzb2x2ZShoYW5kbGVyKGFyZ3MsIHdyYXBwZXIpKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICB0aGlzLnJldHVyblJlc3BvbnNlKHBlZXJOYW1lLCBzZXFOdW0sIHJlc3VsdCk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICByZWFzb24gPSB0aGlzLmNoZWNrSGFuZGxpbmdFcnJvcihyZWFzb24sIHdyYXBwZXIpO1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5SZWplY3Rpb24ocGVlck5hbWUsIHNlcU51bSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBAcGFyYW0gcGVlck5hbWUge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gc2VxTnVtIHtpbnR9XG4gICAgICogQHBhcmFtIHJlc3VsdCB7YW55fVxuICAgICAqL1xuICAgIHJldHVyblJlc3BvbnNlKHBlZXJOYW1lLCBzZXFOdW0sIHJlc3VsdCkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0ge1xuICAgICAgICAgICAgdHlwZTogJ3Jlc3BvbnNlJyxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbUFkZHJlc3MoKSxcbiAgICAgICAgICAgIHNlcU51bTogc2VxTnVtLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2VBc1BlZXIocGVlck5hbWUsIHdyYXBwZXIpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQHBhcmFtIHBlZXJOYW1lIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHNlcU51bSB7aW50fVxuICAgICAqIEBwYXJhbSByZWFzb246IHtFcnJvcn1cbiAgICAgKi9cbiAgICByZXR1cm5SZWplY3Rpb24ocGVlck5hbWUsIHNlcU51bSwgcmVhc29uKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB7XG4gICAgICAgICAgICB0eXBlOiAncmVzcG9uc2UnLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tQWRkcmVzcygpLFxuICAgICAgICAgICAgc2VxTnVtOiBzZXFOdW0sXG4gICAgICAgICAgICByZWplY3Rpb25fcmVhc29uOiByZWFzb24ubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wb3N0TWVzc2FnZUFzUGVlcihwZWVyTmFtZSwgd3JhcHBlcik7XG4gICAgfVxuXG4gICAgY29uc3VtZVJlcXVlc3REYXRhKHNlcU51bSkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5yZXF1ZXN0c0J5U2VxTnVtLmdldChzZXFOdW0pO1xuICAgICAgICBpZiAoZGF0YSkgd2luZG93LmNsZWFyVGltZW91dChkYXRhLnRpbWVvdXRIYW5kbGUpOyAgLy8gZmFpbHMgZ3JhY2VmdWxseSBpZiB0aW1lb3V0IGFscmVhZHkgY2xlYXJlZCBvciBoYW5kbGUgaXMgbnVsbFxuICAgICAgICB0aGlzLnJlcXVlc3RzQnlTZXFOdW0uZGVsZXRlKHNlcU51bSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogd3JhcHBlciBmb3JtYXQ6IHtcbiAgICAgKiAgIFJFUVVJUkVEOlxuICAgICAqICAgICAgZnJvbSB7c3RyaW5nfSB0aGUgbmFtZSBvZiB0aGUgcGVlciB0aGF0IHNlbnQgdGhlIG1lc3NhZ2UsXG4gICAgICogICAgICBzZXFOdW0ge2ludH0gc2VxdWVuY2UgbnVtYmVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFzc29jaWF0ZSByZXNwb25zZSB3aXRoIHJlcXVlc3QsXG4gICAgICogICBFSVRIRVIvT1I6XG4gICAgICogICAgICByZXN1bHQge2FueX0gaWYgdGhlIGNhbGwgd2FzIHN1Y2Nlc3NmdWwsIHRoaXMgaXMgdGhlIHJlc3VsdCB0byBiZSByZXR1cm5lZC5cbiAgICAgKiAgICAgIHJlamVjdGlvbl9yZWFzb24ge3N0cmluZ30gaWYgdGhlIGNhbGwgZmFpbGVkLCB0aGlzIGlzIGFuIGluZGljYXRpb24gb2YgdGhlIHJlYXNvbi5cbiAgICAgKiB9XG4gICAgICovXG4gICAgaGFuZGxlUmVzcG9uc2Uod3JhcHBlcikge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5jb25zdW1lUmVxdWVzdERhdGEod3JhcHBlci5zZXFOdW0pO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIC8vIFNob3VsZCBvbmx5IGhhcHBlbiBpZiByZXF1ZXN0IGRhdGEgYWxyZWFkeSBjb25zdW1lZCBkdWUgdG8gdGltZW91dC5cbiAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgY2FsbGVyIGFscmVhZHkgaGFzIHRoZWlyIGFuc3dlci4gU28ganVzdCBkbyBub3RoaW5nLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwcGVyLnJlamVjdGlvbl9yZWFzb24pIHtcbiAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKHdyYXBwZXIucmVqZWN0aW9uX3JlYXNvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWNvbnN0aXR1dGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBlID0gcmVjb25zdGl0dXRlRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLnJlamVjdChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEucmVzb2x2ZSh3cmFwcGVyLnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSZWFkaW5lc3NcbiAgICAvL1xuICAgIC8vICAgVG8gYmUgY2xlYXI6IHRoaXMgbWVhbnMgcmVhZGluZXNzIHRvIGhhbmRsZSByZXF1ZXN0cywgbm90IHRvIGFjY2VwdCBjb25uZWN0aW9ucy5cbiAgICAvLyAgIEEgcGVlciBpbnN0YW5jZSBpcyBpbW1lZGlhdGVseSByZWFkeSB0byBhY2NlcHQgY29ubmVjdGlvbnMgYWZ0ZXIgY29uc3RydWN0aW9uLlxuXG4gICAgLyogQ2FsbCB0aGlzIHdoZW4geW91J3ZlIGZpbmlzaGVkIGFkZGluZyBoYW5kbGVycywgaW4gb3JkZXIgdG8gZGVjbGFyZSB0aGF0IHRoaXNcbiAgICAgKiBwZWVyIGlzIHJlYWR5IHRvIGhhbmRsZSByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBzZXRSZWFkeSgpIHtcbiAgICAgICAgdGhpcy5yZWFkeVJlc29sdmUoKTtcbiAgICB9XG5cbiAgICAvKiBUaGlzIGlzIG91ciBidWlsdC1pbiBoYW5kbGVyIGZvciB0aGUgJ3JlYWR5JyBoYW5kbGVyIGRlc2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogSXQgcmV0dXJucyBhIHByb21pc2UgdGhhdCBvdGhlciBwZWVycyBjYW4gdXNlIHRvIHdhaXQgdW50aWwgdGhpcyBwZWVyIGlzIHJlYWR5XG4gICAgICogdG8gYWNjZXB0IGNvbm5lY3Rpb25zLlxuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeVByb21pc2U7XG4gICAgfVxuXG4gICAgLyogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGNoZWNrIHRoZSByZWFkaW5lc3Mgb2YgYSBjb25uZWN0ZWQgcGVlci5cbiAgICAgKi9cbiAgICBjaGVja1JlYWR5KHBlZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KHBlZXJOYW1lLCAncmVhZHknLCB7fSwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJlcXVlc3QgaGFuZGxlcnNcblxuICAgIC8qIEFkZCBhIGhhbmRsZXIgZnVuY3Rpb24gb3IgaGFuZGxlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBIYW5kbGVyIGZ1bmN0aW9ucyB3aWxsIGJlIHBhc3NlZCB0d28gYXJndW1lbnRzOiBgYXJnc2AgYW5kIGBtZXRhYC4gVGhlIGZpcnN0IGlzIGFuXG4gICAgICogb2JqZWN0IHBhc3NlZCBieSB0aGUgY2xpZW50IGFuZCBwcmVzdW1hYmx5IGNvbnRhaW5pbmcgYWxsIHRoZSBhcmd1bWVudHMgcmVxdWlyZWQgYnlcbiAgICAgKiB0aGUgaGFuZGxlcjsgdGhlIHNlY29uZCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXF1ZXN0LFxuICAgICAqIHN1Y2ggYXMgdGhlIG5hbWUgb2YgdGhlIGNsaWVudCAod2hpY2ggaXMgdW5kZXIgYG1ldGEuZnJvbWApLlxuICAgICAqXG4gICAgICogSGFuZGxlcnMgbWF5IHJldHVybiBhIHZhbHVlIHN5bmNocm9ub3VzbHksIG9yIG1heSByZXR1cm4gYSBQcm9taXNlLiBFaXRoZXIgaXMgYWNjZXB0YWJsZS5cbiAgICAgKlxuICAgICAqIFlvdSBtYXkgbm90IHJlZ2lzdGVyIGEgaGFuZGxlciB1bmRlciBhIHJlc2VydmVkIG5hbWUsIGkuZS4gdGhlIG5hbWVzIG9mIGFueSBvZiBvdXJcbiAgICAgKiBidWlsdC1pbiBoYW5kbGVycy4gVGhlc2UgYXJlIGRlZmluZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybjogdGhpcyBpbnN0YW5jZSwgdG8gc3VwcG9ydCBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBhZGRIYW5kbGVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVpbHRJbkhhbmRsZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVnaXN0ZXIgaGFuZGxlciB1bmRlciByZXNlcnZlZCBuYW1lOiAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWRkSGFuZGxlcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX2FkZEhhbmRsZXIobmFtZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnNldChuYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKiBBZGQgYSBcImJ1aWx0LWluIGhhbmRsZXIsXCIgd2hpY2ggcmVhbGx5IG1lYW5zIGEgaGFuZGxlciBzdWNoIHRoYXQgYW4gZXJyb3JcbiAgICAgKiB3aWxsIGJlIHRocm93biBpZiBhbnlvbmUgdHJpZXMgdG8gYWRkIGEgaGFuZGxlciBieSB0aGUgc2FtZSBuYW1lIHVzaW5nIHRoZVxuICAgICAqIHVzdWFsIGBhZGRIYW5kbGVyYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgbGFuZ3VhZ2Ugc3VwcG9ydGVkIGl0LCB3ZSB3b3VsZCBtYWtlIHRoaXMgYSBwcm90ZWN0ZWQgbWV0aG9kLCBpLmUuXG4gICAgICogdXNhYmxlIG9ubHkgYnkgc3ViY2xhc3Nlcy4gU28gZG9uJ3QgdXNlIGl0IHVubGVzcyB5b3Ugc2hvdWxkIVxuICAgICAqL1xuICAgIF9hZGRCdWlsdEluSGFuZGxlcihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuYnVpbHRJbkhhbmRsZXJzLnNldChuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fYWRkSGFuZGxlcihuYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKiBMb29rIHVwIGEgaGFuZGxlciwgYnkgaXRzIGRlc2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQSBoYW5kbGVyIGRlc2NyaXB0aW9uIHNob3VsZCBiZSBhIHN0cmluZyBuYW1pbmcgc29tZXRoaW5nIHRoYXQgaGFzIGJlZW4gYWRkZWQgYXMgYVxuICAgICAqIGhhbmRsZXIgZm9yIHRoaXMgc2VydmVyLCBvciBhbiBhdHRyaWJ1dGUgdGhlcmVvZiwgcmVjdXJzaXZlbHkuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgYG15RnVuY2AgaXMgYSBmdW5jdGlvbiwgdGhlbiBhZnRlclxuICAgICAqICAgICAgc2VydmVyLmFkZEhhbmRsZXIoJ2YnLCBteUZ1bmMpXG4gICAgICogJ2YnIGlzIGEgdmFsaWQgZGVzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBJZiBgbXlJbnN0YW5jZWAgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyB0aGF0IGhhcyBhIGBkb1NvbWV0aGluZ2AgbWV0aG9kLCB0aGVuXG4gICAgICogYWZ0ZXJcbiAgICAgKiAgICAgIHNlcnZlci5hZGRIYW5kbGVyKCdmb28nLCBteUluc3RhbmNlKVxuICAgICAqICdmb28uZG9Tb21ldGhpbmcnIGlzIGEgdmFsaWQgZGVzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVzY3JpcCB7c3RyaW5nfSB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGhhbmRsZXIuXG4gICAgICogQHJldHVybjogdGhlIGhhbmRsZXIuIElmIHRoZSBkZXNjcmlwdGlvbiB3YXMgZG90dGVkLCB0aGVuIHRoZSByZXR1cm5lZCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogICBoYXMgdGhlIHByZXZpb3VzIG9iamVjdCBpbiB0aGUgY2hhaW4gYm91bmQgYXMgYHRoaXNgLlxuICAgICAqIEB0aHJvd3M6IEVycm9yIGlmIHRoZSBkZXNjcmlwdGlvbiBkb2VzIG5vdCByZXNvbHZlIHRvIGFueXRoaW5nLCBvciBpZiBpdCBkb2VzIGJ1dCB0aGF0XG4gICAgICogICB0aGluZyBpcyBub3QgYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBsb29rdXBIYW5kbGVyKGRlc2NyaXApIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBkZXNjcmlwLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgIGxldCBoYW5kbGVyO1xuICAgICAgICBsZXQgcHJldjtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5oYW5kbGVycy5nZXQocGFydCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gaGFuZGxlcjtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gaGFuZGxlcltwYXJ0XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaGFuZGxlcjogJHtkZXNjcmlwfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhhbmRsZXIgXCIke2Rlc2NyaXB9XCIgaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuYmluZChwcmV2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG5cbiAgICAvKiBJZiB5b3UgYXJlIG9uIHRoZSBzYW1lIHNpZGUgYXMgYSBwZWVyLCB5b3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBjYWxsXG4gICAgICogb25lIG9mIGl0cyBoYW5kbGVycyBkaXJlY3RseSwgaW5zdGVhZCBvZiB3aXRoaW4gYSByZXF1ZXN0L3Jlc3BvbnNlIHBhaXIuXG4gICAgICovXG4gICAgY2FsbEhhbmRsZXIoaGFuZGxlckRlc2NyaXAsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMubG9va3VwSGFuZGxlcihoYW5kbGVyRGVzY3JpcCk7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1ha2luZyByZXF1ZXN0c1xuXG4gICAgdGFrZU5leHRTZXFOdW0oKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLm5leHRTZXFOdW07XG4gICAgICAgIHRoaXMubmV4dFNlcU51bSA9IG4gKyAxO1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvKiBTZW5kIGEgcmVxdWVzdCB0byBhIHNpbmdsZSBwZWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBlZXJOYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBwZWVyIHRvIHdoaWNoIHRoZSByZXF1ZXN0IHNob3VsZCBiZSBzZW50LlxuICAgICAqIEBwYXJhbSBoYW5kbGVyRGVzY3JpcCB7c3RyaW5nfSBBIGRlc2NyaXB0aW9uIGluZGljYXRpbmcgdGhlIGRlc2lyZWQgaGFuZGxlciBmb3IgdGhlXG4gICAgICogICByZXF1ZXN0IG9uIHRoZSBvdGhlciBzaWRlLlxuICAgICAqIEBwYXJhbSBhcmdzIHtvYmp9IHRoZSBhcmd1bWVudHMgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byB0aGUgaGFuZGxlciBvbiB0aGUgb3RoZXIgc2lkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zOiB7XG4gICAgICogICBkb1JlYWR5Q2hlY2sge2Jvb2x9IG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLiBTZXQgdHJ1ZSBpZiB5b3Ugd2FudCB0byBwcmVjZWRlXG4gICAgICogICAgIHRoZSByZXF1ZXN0IHdpdGggYSByZWFkeSBjaGVjay5cbiAgICAgKiAgIHRpbWVvdXQge2ludH0gb3B0aW9uYWwsIGRlZmF1bHQgMC4gU2V0IHBvc2l0aXZlIGlmIHlvdSB3YW50IHRoZSByZXF1ZXN0IHRvIHRpbWVvdXRcbiAgICAgKiAgICAgYWZ0ZXIgdGhpcyBtYW55IG1pbGxpc2Vjb25kcy4gSWYgMCAob3IgbmVnYXRpdmUpLCB3aWxsIHdhaXQgaW5kZWZpbml0ZWx5LlxuICAgICAqICAgICBJbiBjYXNlIG9mIHRpbWVvdXQsIHRoZSByZXR1cm5lZCBwcm9taXNlIHJlamVjdHMuXG4gICAgICogfVxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0LCBvciByZWplY3RzXG4gICAgICogICB3aXRoIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogU2VlIGFsc286IGBicm9hZGNhc3RSZXF1ZXN0YC5cbiAgICAgKi9cbiAgICBtYWtlUmVxdWVzdChwZWVyTmFtZSwgaGFuZGxlckRlc2NyaXAsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZG9SZWFkeUNoZWNrID0gZmFsc2UsXG4gICAgICAgICAgICB0aW1lb3V0ID0gMCxcbiAgICAgICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IHNlcU51bSA9IHRoaXMudGFrZU5leHRTZXFOdW0oKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdyZXF1ZXN0JyxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbUFkZHJlc3MoKSxcbiAgICAgICAgICAgIHNlcU51bTogc2VxTnVtLFxuICAgICAgICAgICAgaGFuZGxlckRlc2NyaXA6IGhhbmRsZXJEZXNjcmlwLFxuICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hlY2sgPSBkb1JlYWR5Q2hlY2sgPyB0aGlzLmNoZWNrUmVhZHkocGVlck5hbWUpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiBjaGVjay50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHRpbWVvdXQgPCAxID8gbnVsbCA6IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuY29uc3VtZVJlcXVlc3REYXRhKHNlcU51bSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkgcmV0dXJuOyAvLyBSZXF1ZXN0IHdhcyBhbHJlYWR5IGhhbmRsZWQuXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1BlZXIgcmVxdWVzdCB0aW1lZCBvdXQuJykpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHNCeVNlcU51bS5zZXQoc2VxTnVtLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SGFuZGxlOiB0aW1lb3V0SGFuZGxlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zdE1lc3NhZ2VBc1BlZXIocGVlck5hbWUsIHdyYXBwZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qIEJyb2FkY2FzdCBhIHJlcXVlc3QgdG8gYWxsIGNvbm5lY3RlZCBwZWVycyAob3IgYSBzdWJzZXQsIGJ5IGZpbHRlcmluZykuXG4gICAgICpcbiAgICAgKiBUaGlzIGp1c3QgcGVyZm9ybXMgbXVsdGlwbGUgcmVxdWVzdHMuIFBhcnRpY3VsYXIgc3ViY2xhc3NlcyBtYXkgaGF2ZSBtb3JlXG4gICAgICogZWZmaWNpZW50IHdheXMgb2YgYnJvYWRjYXN0aW5nIHRoYXQgdGhleSBtYXkgcHJlZmVyIHRvIHVzZSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZXJEZXNjcmlwIHtzdHJpbmd9IEEgZGVzY3JpcHRpb24gaW5kaWNhdGluZyB0aGUgZGVzaXJlZCBoYW5kbGVyIGZvciB0aGVcbiAgICAgKiAgIHJlcXVlc3Qgb24gdGhlIG90aGVyIHNpZGUuXG4gICAgICogQHBhcmFtIGFyZ3Mge29ian0gdGhlIGFyZ3VtZW50cyBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIHRoZSBoYW5kbGVyIG9uIHRoZSBvdGhlciBzaWRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnM6IHtcbiAgICAgKiAgIGV4Y2x1ZGVTZWxmIHtib29sfSBJZiB0cnVlLCBkbyBub3Qgc2VuZCB0aGUgcmVxdWVzdCB0byBzZWxmLiBUaGlzIGlzIHJlbGV2YW50IGZvclxuICAgICAqICAgICBzb21lIHBlZXIgdHlwZXMgdGhhdCBrZWVwIHRoZWlyIG93biBuYW1lIGluIHRoZWlyIHNldCBvZiBwZWVyczsgZm9yIHRob3NlIHRoYXRcbiAgICAgKiAgICAgZG8gbm90LCBpdCBjYW4gYmUgaWdub3JlZC5cbiAgICAgKiAgIGZpbHRlciB7ZnVuY3Rpb259IG9wdGlvbmFsIGZ1bmN0aW9uIG1hcHBpbmcgcGVlciBuYW1lcyB0byBib29sZWFucy4gQWxsb3dzIHRvXG4gICAgICogICAgIGJyb2FkY2FzdCB0byBhIHN1YnNldCBvZiBhbGwgY29ubmVjdGVkIHBlZXJzLCBuYW1lbHkgdGhvc2UgbWFwcGluZyB0byBgdHJ1ZWAuXG4gICAgICogICAgIElmIGBleGNsdWRlU2VsZmAgaXMgdHJ1ZSwgdGhhdCBleGNsdXNpb24gaGFwcGVucyBmaXJzdCwgYW5kIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICAgKiAgICAgaXMgYXBwbGllZCB0byB3aGF0IHJlbWFpbnMuXG4gICAgICogICBza2lwUmVhZHlDaGVja3Mge2Jvb2x9IG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlLiBJZiBmYWxzZSB3ZSB3aWxsIHByZWNlZGUgZWFjaFxuICAgICAqICAgICByZXF1ZXN0IHdpdGggYSByZWFkaW5lc3MgY2hlY2suIFNldCB0cnVlIHRvIHNraXAuXG4gICAgICogfVxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXlbUHJvbWlzZV19IGFycmF5IG9mIHRoZSBwcm9taXNlcyByZXR1cm5lZCBieSBvdXIgYG1ha2VSZXF1ZXN0YCBtZXRob2QsXG4gICAgICogICBvbmUgZm9yIGVhY2ggcGVlciB0byB3aGljaCBhIHJlcXVlc3Qgd2FzIHNlbnQuXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbzogYG1ha2VSZXF1ZXN0YC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFdoaWxlIGluIHRoZSBgbWFrZVJlcXVlc3RgIG1ldGhvZCB0aGUgcmVhZHkgY2hlY2sgaXMgc2tpcHBlZCBieSBkZWZhdWx0LCBoZXJlIHRoZVxuICAgICAqICAgYmVoYXZpb3IgaXMgdGhlIG9wcG9zaXRlLCBhbmQgdGhlIHJlYWR5IGNoZWNrcyBhcmUgcGVyZm9ybWVkIGJ5IGRlZmF1bHQuIEl0IGlzIGZlbHQgdGhhdCxcbiAgICAgKiAgIHJhdGhlciB0aGFuIGJlaW5nIGNvbmZ1c2luZywgdGhpcyBjYXRlcnMgdG8gbm9ybWFsIHVzYWdlIHBhdHRlcm5zLiBJdCB3aWxsIGJlIG5vcm1hbCB0b1xuICAgICAqICAgYmUgYnJvYWRjYXN0aW5nIHRvIGEgY29sbGVjdGlvbiBvZiBwZWVycyBmb3Igd2hpY2ggd2UgYXJlIF9ub3RfIGNhcmVmdWxseSBtYWludGFpbmluZyBzdGF0ZTtcbiAgICAgKiAgIHdoZXJlYXMgd2hlbiByZXF1ZXN0aW5nIGZyb20gYSBzaW5nbGUgcGVlciwgd2UgYXJlIG1vcmUgbGlrZWx5IHRvIGhhdmUgYWxyZWFkeSBwZXJmb3JtZWQgYW5cbiAgICAgKiAgIGluaXRpYWwgKG9uZS10aW1lKSByZWFkeSBjaGVjayBvdXJzZWx2ZXMuXG4gICAgICovXG4gICAgYnJvYWRjYXN0UmVxdWVzdChoYW5kbGVyRGVzY3JpcCwgYXJncywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBleGNsdWRlU2VsZiA9IGZhbHNlLFxuICAgICAgICAgICAgZmlsdGVyID0gKCgpID0+IHRydWUpLFxuICAgICAgICAgICAgc2tpcFJlYWR5Q2hlY2tzID0gZmFsc2VcbiAgICAgICAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IHBlZXJOYW1lcyA9IHRoaXMuZ2V0QWxsUGVlck5hbWVzKCkuZmlsdGVyKG5hbWUgPT4gKCFleGNsdWRlU2VsZikgfHwgbmFtZSAhPT0gdGhpcy5uYW1lKS5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwZWVyTmFtZSBvZiBwZWVyTmFtZXMpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZXMucHVzaCh0aGlzLm1ha2VSZXF1ZXN0KHBlZXJOYW1lLCBoYW5kbGVyRGVzY3JpcCwgYXJncywge1xuICAgICAgICAgICAgICAgIGRvUmVhZHlDaGVjazogIXNraXBSZWFkeUNoZWNrcyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlcztcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBBYnN0cmFjdCBtZXRob2RzIHN1YmNsYXNzZXMgTUFZIG92ZXJyaWRlXG5cbiAgICAvKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IHdhbnQgdG8gdXNlIHRoaXNcbiAgICAgKiBiYXNlIGNsYXNzJ3MgYGJyb2FkY2FzdFJlcXVlc3RgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5W3N0cmluZ119IGFuIEFycmF5IG9mIHRoZSBuYW1lcyBvZiBhbGwgY29ubmVjdGVkIHBlZXJzLlxuICAgICAqL1xuICAgIGdldEFsbFBlZXJOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qIFRoaXMgZ2l2ZXMgYSBjaGFuY2UgdG8gZXhhbWluZSBhbmQgbW9kaWZ5IGEgaGFuZGxlciBlcnJvciwgYW5kIHBvc3NpYmx5XG4gICAgICogaGF2ZSBzaWRlIGVmZmVjdHMsIGJlZm9yZSB0aGUgZXJyb3IgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVhc29uOiBFcnJvciB0aHJvd24gYnkgcmVxdWVzdCBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSB3cmFwcGVyOiB0aGUgd3JhcHBlciBtZXNzYWdlIHRoYXQgd2FzIGJlaW5nIGhhbmRsZWQuXG4gICAgICogQHJldHVybjogRXJyb3IgaW5zdGFuY2UuIE1heSBiZSB0aGUgc2FtZSBhcyB0aGUgZ2l2ZW4gcmVhc29uLCBvciBkaWZmZXJlbnQuXG4gICAgICovXG4gICAgY2hlY2tIYW5kbGluZ0Vycm9yKHJlYXNvbiwgd3JhcHBlcikge1xuICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFic3RyYWN0IG1ldGhvZHMgc3ViY2xhc3NlcyBNVVNUIG92ZXJyaWRlXG5cbiAgICAvKiBUaGlzIGlzIHdoZXJlIHN1YmNsYXNzZXMgbXVzdCB1c2UgdGhlaXIgdHJhbnNwb3J0LXNwZWNpZmljIG1ldGhvZCBvZiBnZXR0aW5nXG4gICAgICogYSBzZXJpYWxpemFibGUgbWVzc2FnZSBmcm9tIG9uZSBwZWVyIHRvIGFub3RoZXIuXG4gICAgICpcbiAgICAgKiBTcGVjaWZpY2FsbHksIHRoZSBtZXNzYWdlIHRvIGJlIGNvbW11bmljYXRlZCBoZXJlIGlzIG9uZSBvZiB0aGUgXCJ3cmFwcGVyXCJcbiAgICAgKiBtZXNzYWdlcyB3ZSB1c2UgdG8gcmVwcmVzZW50IHJlcXVlc3RzIGFuZCByZXNwb25zZXMuIFRoZSBpbnRlbnRpb24gdGhlcmVmb3JlXG4gICAgICogaXMgdGhhdCBpdCBiZSBkZWxpdmVyZWQgdG8gdGhlIGBoYW5kbGVNZXNzYWdlYCBtZXRob2Qgb2YgdGhlIHBlZXIgKHdoaWNoIHNob3VsZFxuICAgICAqIF9ub3RfIGJlIG92ZXJyaWRkZW4sIGJ1dCBzaG91bGQgYmUgaW5oZXJpdGVkIGZyb20gdGhpcyBiYXNlIGNsYXNzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwZWVyTmFtZSB7c3RyaW5nfSB0aGUgbmFtZSBvZiBhIGNvbm5lY3RlZCBwZWVyXG4gICAgICogQHBhcmFtIHdyYXBwZXIge29ian0gdGhlIHdyYXBwZXIgbWVzc2FnZSB0byBiZSBwb3N0ZWQgdG8gdGhhdCBwZWVyLiBGb3JtYXQ6IHtcbiAgICAgKiAgIHR5cGUge3N0cmluZ30gZXF1YWwgdG8gZWl0aGVyICdyZXF1ZXN0JyBvciAncmVzcG9uc2UnLCBhcHByb3ByaWF0ZWx5LlxuICAgICAqIH1cbiAgICAgKi9cbiAgICBwb3N0TWVzc2FnZUFzUGVlcihwZWVyTmFtZSwgd3JhcHBlcikge1xuICAgICAgICAvL1xuICAgIH1cblxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/browser-peers/src/peer.js\n");

/***/ }),

/***/ "./node_modules/browser-peers/src/util.js":
/*!************************************************!*\
  !*** ./node_modules/browser-peers/src/util.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"xhr\": () => (/* binding */ xhr),\n/* harmony export */   \"enrichXhrParams\": () => (/* binding */ enrichXhrParams),\n/* harmony export */   \"Listenable\": () => (/* binding */ Listenable)\n/* harmony export */ });\n/*! browser-peers v0.1.0 | Copyright (c) 2020-2022 Steve Kieffer | MIT license */\n/* SPDX-License-Identifier: MIT */\n\n/* Simple XMLHttpRequest utility\n *\n * param url: the url to be accessed\n * optional params object:\n *      method: \"GET\", \"POST\" etc. Defaults to \"GET\"\n *      query: pass an object defining key-value pairs that you want added\n *          as a query string on the end of the URL\n *      form: pass an object defining key-value pairs that you want to be\n *          sent in form-encoded format in the body of the request\n *      handleAs: 'text', 'json', or 'blob'. Defaults to 'text'\n *\n * return: promise that resolves with the response from the request\n */\nfunction xhr(url, params) {\n    if (params.query) {\n        url += \"?\"+(new URLSearchParams(params.query)).toString();\n    }\n    const init = {\n        method: params.method || \"GET\"\n    };\n    if (params.form) {\n        init.body = new URLSearchParams(params.form);\n    }\n    const handleAs = params.handleAs || 'text';\n    return fetch(url, init).then(resp => {\n        if (!resp.ok) {\n            throw new Error(`HTTP error! status: ${resp.status}`);\n        }\n        if (handleAs === 'json') {\n            return resp.json();\n        } else if (handleAs === 'blob') {\n            return resp.blob();\n        } else {\n            return resp.text();\n        }\n    });\n}\n\n/* Add extra key-value arguments to an XHR.\n *\n * @param givenParams: a `params` arg which would have been passed to the\n *   `xhr` function defined in this module.\n * @param extraPairs: an object defining extra key-value args that you want to\n *   add to the request.\n * @return: a _new_ params object. The given one is not modified.\n *   The extra pairs are placed in `params.query` if `query` was defined in the\n *   givenParams, else in `params.form` if that was defined. If neither was defined,\n *   then we define `params.query` and put the extra pairs in there.\n */\nfunction enrichXhrParams(givenParams, extraPairs) {\n    const params = {};\n    Object.assign(params, givenParams || {});\n    if (params.query) {\n        Object.assign(params.query, extraPairs);\n    } else if (params.form) {\n        Object.assign(params.form, extraPairs);\n    } else {\n        params.query = {};\n        Object.assign(params.query, extraPairs);\n    }\n    return params;\n}\n\nclass Listenable {\n\n    constructor(listeners) {\n        this.listeners = listeners;\n    }\n\n    on(eventType, callback) {\n        const cbs = this.listeners[eventType] || [];\n        cbs.push(callback);\n        this.listeners[eventType] = cbs;\n    }\n\n    off(eventType, callback) {\n        const cbs = this.listeners[eventType] || [];\n        const i0 = cbs.indexOf(callback);\n        if (i0 >= 0) {\n            cbs.splice(i0, 1);\n            this.listeners[eventType] = cbs;\n        }\n    }\n\n    dispatch(event) {\n        /* Subtle point: In general, we are always careful not to modify an\n         * iterable while we are in the process of iterating over it. Here, we don't\n         * know whether a callback might `off` itself as a part of its process,\n         * thereby modifying our array of listeners while we are iterating over it!\n         * Therefore, to be safe, we have to iterate over a _copy_ of our array of\n         * registered listeners. */\n        const cbs = (this.listeners[event.type] || []).slice();\n        for (let cb of cbs) {\n            cb(event);\n        }\n    }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvdXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGZzYy1pc2UvLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1wZWVycy9zcmMvdXRpbC5qcz8xYWI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBicm93c2VyLXBlZXJzIHYwLjEuMCB8IENvcHlyaWdodCAoYykgMjAyMC0yMDIyIFN0ZXZlIEtpZWZmZXIgfCBNSVQgbGljZW5zZSAqL1xuLyogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVCAqL1xuXG4vKiBTaW1wbGUgWE1MSHR0cFJlcXVlc3QgdXRpbGl0eVxuICpcbiAqIHBhcmFtIHVybDogdGhlIHVybCB0byBiZSBhY2Nlc3NlZFxuICogb3B0aW9uYWwgcGFyYW1zIG9iamVjdDpcbiAqICAgICAgbWV0aG9kOiBcIkdFVFwiLCBcIlBPU1RcIiBldGMuIERlZmF1bHRzIHRvIFwiR0VUXCJcbiAqICAgICAgcXVlcnk6IHBhc3MgYW4gb2JqZWN0IGRlZmluaW5nIGtleS12YWx1ZSBwYWlycyB0aGF0IHlvdSB3YW50IGFkZGVkXG4gKiAgICAgICAgICBhcyBhIHF1ZXJ5IHN0cmluZyBvbiB0aGUgZW5kIG9mIHRoZSBVUkxcbiAqICAgICAgZm9ybTogcGFzcyBhbiBvYmplY3QgZGVmaW5pbmcga2V5LXZhbHVlIHBhaXJzIHRoYXQgeW91IHdhbnQgdG8gYmVcbiAqICAgICAgICAgIHNlbnQgaW4gZm9ybS1lbmNvZGVkIGZvcm1hdCBpbiB0aGUgYm9keSBvZiB0aGUgcmVxdWVzdFxuICogICAgICBoYW5kbGVBczogJ3RleHQnLCAnanNvbicsIG9yICdibG9iJy4gRGVmYXVsdHMgdG8gJ3RleHQnXG4gKlxuICogcmV0dXJuOiBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgcmVxdWVzdFxuICovXG5leHBvcnQgZnVuY3Rpb24geGhyKHVybCwgcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5xdWVyeSkge1xuICAgICAgICB1cmwgKz0gXCI/XCIrKG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zLnF1ZXJ5KSkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdCA9IHtcbiAgICAgICAgbWV0aG9kOiBwYXJhbXMubWV0aG9kIHx8IFwiR0VUXCJcbiAgICB9O1xuICAgIGlmIChwYXJhbXMuZm9ybSkge1xuICAgICAgICBpbml0LmJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcy5mb3JtKTtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlQXMgPSBwYXJhbXMuaGFuZGxlQXMgfHwgJ3RleHQnO1xuICAgIHJldHVybiBmZXRjaCh1cmwsIGluaXQpLnRoZW4ocmVzcCA9PiB7XG4gICAgICAgIGlmICghcmVzcC5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcC5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZUFzID09PSAnanNvbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwLmpzb24oKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYW5kbGVBcyA9PT0gJ2Jsb2InKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcC5ibG9iKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcC50ZXh0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyogQWRkIGV4dHJhIGtleS12YWx1ZSBhcmd1bWVudHMgdG8gYW4gWEhSLlxuICpcbiAqIEBwYXJhbSBnaXZlblBhcmFtczogYSBgcGFyYW1zYCBhcmcgd2hpY2ggd291bGQgaGF2ZSBiZWVuIHBhc3NlZCB0byB0aGVcbiAqICAgYHhocmAgZnVuY3Rpb24gZGVmaW5lZCBpbiB0aGlzIG1vZHVsZS5cbiAqIEBwYXJhbSBleHRyYVBhaXJzOiBhbiBvYmplY3QgZGVmaW5pbmcgZXh0cmEga2V5LXZhbHVlIGFyZ3MgdGhhdCB5b3Ugd2FudCB0b1xuICogICBhZGQgdG8gdGhlIHJlcXVlc3QuXG4gKiBAcmV0dXJuOiBhIF9uZXdfIHBhcmFtcyBvYmplY3QuIFRoZSBnaXZlbiBvbmUgaXMgbm90IG1vZGlmaWVkLlxuICogICBUaGUgZXh0cmEgcGFpcnMgYXJlIHBsYWNlZCBpbiBgcGFyYW1zLnF1ZXJ5YCBpZiBgcXVlcnlgIHdhcyBkZWZpbmVkIGluIHRoZVxuICogICBnaXZlblBhcmFtcywgZWxzZSBpbiBgcGFyYW1zLmZvcm1gIGlmIHRoYXQgd2FzIGRlZmluZWQuIElmIG5laXRoZXIgd2FzIGRlZmluZWQsXG4gKiAgIHRoZW4gd2UgZGVmaW5lIGBwYXJhbXMucXVlcnlgIGFuZCBwdXQgdGhlIGV4dHJhIHBhaXJzIGluIHRoZXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5yaWNoWGhyUGFyYW1zKGdpdmVuUGFyYW1zLCBleHRyYVBhaXJzKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGdpdmVuUGFyYW1zIHx8IHt9KTtcbiAgICBpZiAocGFyYW1zLnF1ZXJ5KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLnF1ZXJ5LCBleHRyYVBhaXJzKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5mb3JtKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLmZvcm0sIGV4dHJhUGFpcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5xdWVyeSA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHBhcmFtcy5xdWVyeSwgZXh0cmFQYWlycyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG5cbmV4cG9ydCBjbGFzcyBMaXN0ZW5hYmxlIHtcblxuICAgIGNvbnN0cnVjdG9yKGxpc3RlbmVycykge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB9XG5cbiAgICBvbihldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNicyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV0gfHwgW107XG4gICAgICAgIGNicy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGNicztcbiAgICB9XG5cbiAgICBvZmYoZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudFR5cGVdIHx8IFtdO1xuICAgICAgICBjb25zdCBpMCA9IGNicy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGkwID49IDApIHtcbiAgICAgICAgICAgIGNicy5zcGxpY2UoaTAsIDEpO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGNicztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc3BhdGNoKGV2ZW50KSB7XG4gICAgICAgIC8qIFN1YnRsZSBwb2ludDogSW4gZ2VuZXJhbCwgd2UgYXJlIGFsd2F5cyBjYXJlZnVsIG5vdCB0byBtb2RpZnkgYW5cbiAgICAgICAgICogaXRlcmFibGUgd2hpbGUgd2UgYXJlIGluIHRoZSBwcm9jZXNzIG9mIGl0ZXJhdGluZyBvdmVyIGl0LiBIZXJlLCB3ZSBkb24ndFxuICAgICAgICAgKiBrbm93IHdoZXRoZXIgYSBjYWxsYmFjayBtaWdodCBgb2ZmYCBpdHNlbGYgYXMgYSBwYXJ0IG9mIGl0cyBwcm9jZXNzLFxuICAgICAgICAgKiB0aGVyZWJ5IG1vZGlmeWluZyBvdXIgYXJyYXkgb2YgbGlzdGVuZXJzIHdoaWxlIHdlIGFyZSBpdGVyYXRpbmcgb3ZlciBpdCFcbiAgICAgICAgICogVGhlcmVmb3JlLCB0byBiZSBzYWZlLCB3ZSBoYXZlIHRvIGl0ZXJhdGUgb3ZlciBhIF9jb3B5XyBvZiBvdXIgYXJyYXkgb2ZcbiAgICAgICAgICogcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuICovXG4gICAgICAgIGNvbnN0IGNicyA9ICh0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXSB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgZm9yIChsZXQgY2Igb2YgY2JzKSB7XG4gICAgICAgICAgICBjYihldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/browser-peers/src/util.js\n");

/***/ }),

/***/ "./src/mathworker.js":
/*!***************************!*\
  !*** ./src/mathworker.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var browser_peers_src_dedworkerpeer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! browser-peers/src/dedworkerpeer */ \"./node_modules/browser-peers/src/dedworkerpeer.js\");\n/* ------------------------------------------------------------------------- *\n *  Proofscape Integrated Study Environment (PISE)                           *\n *                                                                           *\n *  Copyright (c) 2018-2022 Proofscape contributors                          *\n *                                                                           *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");          *\n *  you may not use this file except in compliance with the License.         *\n *  You may obtain a copy of the License at                                  *\n *                                                                           *\n *      http://www.apache.org/licenses/LICENSE-2.0                           *\n *                                                                           *\n *  Unless required by applicable law or agreed to in writing, software      *\n *  distributed under the License is distributed on an \"AS IS\" BASIS,        *\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *\n *  See the License for the specific language governing permissions and      *\n *  limitations under the License.                                           *\n * ------------------------------------------------------------------------- */\n\n\n\n\n\nconst pyodidePackages = [\n    \"micropip\",\n    \"Jinja2\",\n    \"mpmath\",\n];\n\n\nconst pyodideImports = [\n    'import pfsc_examp',\n];\n\n\nfunction echo(args, meta) {\n    console.log('echo', args, meta);\n    return 'echoed';\n}\n\n\nfunction ping(args) {\n    return 'pong';\n}\n\n\nfunction startup(args) {\n    self.pfscExampConfig = args.pfscExampConfig;\n    let indexURL = args.pyodideIndexURL;\n    if (!indexURL.endsWith('/')) {\n        indexURL += '/';\n    }\n    const pyodideJsURL = indexURL + 'pyodide.js';\n    importScripts(pyodideJsURL);\n\n    let code = 'import micropip\\n';\n\n    const noDeps = args.micropipNoDeps ? ', deps=False' : '';\n    code += `await micropip.install(${JSON.stringify(args.micropipInstallTargetsArray)}${noDeps})\\n`;\n\n    for (let imp of pyodideImports) {\n        code += `${imp}\\n`;\n    }\n\n    // Final expression makes the return value.\n    // (See https://pyodide.org/en/stable/usage/api/js-api.html#pyodide.runPythonAsync)\n    // We grab info about the installed packages.\n    code += '{k:vars(v) for k, v in micropip.list().items()}\\n';\n\n    console.debug(code);\n\n    self.pyoReady = new Promise(resolve => {\n        loadPyodide({indexURL: indexURL}).then(pyodide => {\n            self.pyodide = pyodide;\n            pyodide.loadPackage(pyodidePackages).then(() => {\n                pyodide.runPythonAsync(code).then(pkginfoProxy => {\n                    const pkginfo = pkginfoProxy.toJs();\n                    pkginfoProxy.destroy();\n                    resolve({\n                        status: 0,\n                        message: 'loaded Pyodide and all packages',\n                        // Up to v0.21.2, it's pyodide.version. In v0.21.3, it's pyodide.default.\n                        pyodideVersion: pyodide.default || pyodide.version,\n                        // pkginfo is a Map, in which package names point to Maps, in which\n                        // the keys are 'name', 'version', and 'source'.\n                        pkginfo: pkginfo,\n                    });\n                });\n            });\n        });\n    });\n    return self.pyoReady;\n}\n\n\n/* Make a new PyProxy for a widget.\n *\n * args: {\n *   info: the info object that defines the widget,\n *   paneId: the id of the pane where this representative is to be active.\n * }\n *\n * return: promise that resolves with new total number of proxies for this widget\n */\nasync function makePyProxy(args) {\n    await self.pyoReady;\n    const info = args.info;\n    const paneId = args.paneId;\n    const uid = info['uid'];\n    const w = self.pfscisehub.notesManager.ensureWidget(uid);\n    const makeObject = self.pyodide.globals.get('pfsc_examp').make_examp_generator_obj_from_js;\n    const obj = makeObject(info, paneId);\n    makeObject.destroy();  // destroy proxy of factory func to avoid memory leak\n    w.addPyProxy(paneId, obj);\n    return w.getNumProxies();\n}\n\n\n/* Destroy a single PyProxy for a widget. If this was the widget's\n * last proxy, also delete the widget from the NotesManager.\n *\n * args: {\n *   uid: the uid of the widget that wants to destroy a PyProxy\n *   paneId: the id of the pane whose proxy should be destroyed\n * }\n *\n * return: the new total number of proxies for this widget\n */\nfunction destroyPyProxy(args) {\n    const nm = self.pfscisehub.notesManager;\n    const uid = args.uid;\n    const paneId = args.paneId;\n    const w = nm.getWidget(uid);\n    if (w) {\n        w.destroyProxy(paneId);\n        const n = w.getNumProxies();\n        if (n === 0) {\n            nm.deleteWidget(uid);\n        }\n        return n;\n    } else {\n        return 0;\n    }\n}\n\n/* Rebuild an examp widget.\n *\n * args: {\n *   uid: the widget uid,\n *   paneId: the id of the pane where we want to rebuild\n *   value: optional, new raw value to pass to this widget's `build` method\n *   writeHtml: bool, optional, default false: if true, ask the widget to\n *     generate its (new) HTML\n * }\n *\n * return: promise that resolves with the response from the `rebuild_examp_generator_from_js()`\n *   function in the pfsc-examp python package. This is a formatted object, which contains\n *   an error level, error message, and result value if successful.\n */\nasync function rebuild(args) {\n    await self.pyoReady;\n    const {\n        uid,\n        paneId,\n        value = null,\n        writeHtml = false,\n    } = args;\n    const nm = self.pfscisehub.notesManager;\n    const w = nm.getWidget(uid);\n    const obj = w.getPyProxyCopy(paneId);\n    const rebuildFunc = self.pyodide.globals.get('pfsc_examp').rebuild_examp_generator_from_js;\n    const response = rebuildFunc.callKwargs(obj, {value: value, write_html: writeHtml});\n    // Destroy PyProxy of `rebuild` to avoid memory leak.\n    // `response` object does not need to be destroyed, since it was converted with `to_js()`\n    // on the python side.\n    rebuildFunc.destroy();\n    // `response` is a Map. Convert to an Object.\n    const respObj = Object.fromEntries(response);\n    return respObj;\n}\n\n\nclass NotesManager {\n\n    constructor() {\n        this.widgets = new Map();\n    }\n\n    getWidget(uid) {\n        return this.widgets.get(uid);\n    }\n\n    ensureWidget(uid) {\n        if (this.widgets.has(uid)) {\n            return this.widgets.get(uid);\n        } else {\n            const w = new Widget(uid);\n            this.widgets.set(uid, w);\n            return w;\n        }\n    }\n\n    deleteWidget(uid) {\n        this.widgets.delete(uid);\n    }\n\n}\n\n\nclass Widget {\n\n    constructor(uid) {\n        this.uid = uid;\n        this.pyProxiesByPaneId = new Map();\n    }\n\n    addPyProxy(paneId, proxy) {\n        this.pyProxiesByPaneId.set(paneId, proxy);\n    }\n\n    /* This method is intended for use by Python code running in Pyodide.\n     * The reason for returning a *copy* of the PyProxy object we have stored\n     * is that this prevents the PyProxy from being destroyed as a result of\n     * being passed back to the Py side.\n     * See:\n     *   https://pyodide.org/en/stable/usage/type-conversions.html#calling-javascript-functions-from-python\n     */\n    getPyProxyCopy(paneId) {\n        const proxy = this.pyProxiesByPaneId.get(paneId);\n        return proxy.copy();\n    }\n\n    getNumProxies() {\n        return this.pyProxiesByPaneId.size;\n    }\n\n    destroyProxy(paneId) {\n        const p = this.pyProxiesByPaneId.get(paneId);\n        if (p) {\n            p.destroy();\n            this.pyProxiesByPaneId.delete(paneId);\n        }\n    }\n\n}\n\n\n/* We build a dummy environment so that the same code that was designed to\n * work with Pyodide running in the main page can also work here.\n */\nself.pfscisehub = {\n    notesManager: new NotesManager(),\n};\n\n\nconst peer = new browser_peers_src_dedworkerpeer__WEBPACK_IMPORTED_MODULE_0__.DedicatedWorkerPeer(self);\npeer.addHandler('echo', echo);\npeer.addHandler('ping', ping);\npeer.addHandler('startup', startup);\npeer.addHandler('makePyProxy', makePyProxy);\npeer.addHandler('destroyPyProxy', destroyPyProxy);\npeer.addHandler('rebuild', rebuild);\npeer.setReady();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWF0aHdvcmtlci5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGZzYy1pc2UvLi9zcmMvbWF0aHdvcmtlci5qcz84NTRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogIFByb29mc2NhcGUgSW50ZWdyYXRlZCBTdHVkeSBFbnZpcm9ubWVudCAoUElTRSkgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTgtMjAyMiBQcm9vZnNjYXBlIGNvbnRyaWJ1dG9ycyAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgICAgICAgICAgKlxuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gICAgICAgICAqXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlICAgICAgKlxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgICAgICAgICpcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gKlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgICAgICAqXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXG5pbXBvcnQgeyBEZWRpY2F0ZWRXb3JrZXJQZWVyIH0gZnJvbSBcImJyb3dzZXItcGVlcnMvc3JjL2RlZHdvcmtlcnBlZXJcIjtcblxuXG5jb25zdCBweW9kaWRlUGFja2FnZXMgPSBbXG4gICAgXCJtaWNyb3BpcFwiLFxuICAgIFwiSmluamEyXCIsXG4gICAgXCJtcG1hdGhcIixcbl07XG5cblxuY29uc3QgcHlvZGlkZUltcG9ydHMgPSBbXG4gICAgJ2ltcG9ydCBwZnNjX2V4YW1wJyxcbl07XG5cblxuZnVuY3Rpb24gZWNobyhhcmdzLCBtZXRhKSB7XG4gICAgY29uc29sZS5sb2coJ2VjaG8nLCBhcmdzLCBtZXRhKTtcbiAgICByZXR1cm4gJ2VjaG9lZCc7XG59XG5cblxuZnVuY3Rpb24gcGluZyhhcmdzKSB7XG4gICAgcmV0dXJuICdwb25nJztcbn1cblxuXG5mdW5jdGlvbiBzdGFydHVwKGFyZ3MpIHtcbiAgICBzZWxmLnBmc2NFeGFtcENvbmZpZyA9IGFyZ3MucGZzY0V4YW1wQ29uZmlnO1xuICAgIGxldCBpbmRleFVSTCA9IGFyZ3MucHlvZGlkZUluZGV4VVJMO1xuICAgIGlmICghaW5kZXhVUkwuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICBpbmRleFVSTCArPSAnLyc7XG4gICAgfVxuICAgIGNvbnN0IHB5b2RpZGVKc1VSTCA9IGluZGV4VVJMICsgJ3B5b2RpZGUuanMnO1xuICAgIGltcG9ydFNjcmlwdHMocHlvZGlkZUpzVVJMKTtcblxuICAgIGxldCBjb2RlID0gJ2ltcG9ydCBtaWNyb3BpcFxcbic7XG5cbiAgICBjb25zdCBub0RlcHMgPSBhcmdzLm1pY3JvcGlwTm9EZXBzID8gJywgZGVwcz1GYWxzZScgOiAnJztcbiAgICBjb2RlICs9IGBhd2FpdCBtaWNyb3BpcC5pbnN0YWxsKCR7SlNPTi5zdHJpbmdpZnkoYXJncy5taWNyb3BpcEluc3RhbGxUYXJnZXRzQXJyYXkpfSR7bm9EZXBzfSlcXG5gO1xuXG4gICAgZm9yIChsZXQgaW1wIG9mIHB5b2RpZGVJbXBvcnRzKSB7XG4gICAgICAgIGNvZGUgKz0gYCR7aW1wfVxcbmA7XG4gICAgfVxuXG4gICAgLy8gRmluYWwgZXhwcmVzc2lvbiBtYWtlcyB0aGUgcmV0dXJuIHZhbHVlLlxuICAgIC8vIChTZWUgaHR0cHM6Ly9weW9kaWRlLm9yZy9lbi9zdGFibGUvdXNhZ2UvYXBpL2pzLWFwaS5odG1sI3B5b2RpZGUucnVuUHl0aG9uQXN5bmMpXG4gICAgLy8gV2UgZ3JhYiBpbmZvIGFib3V0IHRoZSBpbnN0YWxsZWQgcGFja2FnZXMuXG4gICAgY29kZSArPSAne2s6dmFycyh2KSBmb3IgaywgdiBpbiBtaWNyb3BpcC5saXN0KCkuaXRlbXMoKX1cXG4nO1xuXG4gICAgY29uc29sZS5kZWJ1Zyhjb2RlKTtcblxuICAgIHNlbGYucHlvUmVhZHkgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgbG9hZFB5b2RpZGUoe2luZGV4VVJMOiBpbmRleFVSTH0pLnRoZW4ocHlvZGlkZSA9PiB7XG4gICAgICAgICAgICBzZWxmLnB5b2RpZGUgPSBweW9kaWRlO1xuICAgICAgICAgICAgcHlvZGlkZS5sb2FkUGFja2FnZShweW9kaWRlUGFja2FnZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHB5b2RpZGUucnVuUHl0aG9uQXN5bmMoY29kZSkudGhlbihwa2dpbmZvUHJveHkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwa2dpbmZvID0gcGtnaW5mb1Byb3h5LnRvSnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcGtnaW5mb1Byb3h5LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbG9hZGVkIFB5b2RpZGUgYW5kIGFsbCBwYWNrYWdlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcCB0byB2MC4yMS4yLCBpdCdzIHB5b2RpZGUudmVyc2lvbi4gSW4gdjAuMjEuMywgaXQncyBweW9kaWRlLmRlZmF1bHQuXG4gICAgICAgICAgICAgICAgICAgICAgICBweW9kaWRlVmVyc2lvbjogcHlvZGlkZS5kZWZhdWx0IHx8IHB5b2RpZGUudmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBrZ2luZm8gaXMgYSBNYXAsIGluIHdoaWNoIHBhY2thZ2UgbmFtZXMgcG9pbnQgdG8gTWFwcywgaW4gd2hpY2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBrZXlzIGFyZSAnbmFtZScsICd2ZXJzaW9uJywgYW5kICdzb3VyY2UnLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGtnaW5mbzogcGtnaW5mbyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGYucHlvUmVhZHk7XG59XG5cblxuLyogTWFrZSBhIG5ldyBQeVByb3h5IGZvciBhIHdpZGdldC5cbiAqXG4gKiBhcmdzOiB7XG4gKiAgIGluZm86IHRoZSBpbmZvIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIHdpZGdldCxcbiAqICAgcGFuZUlkOiB0aGUgaWQgb2YgdGhlIHBhbmUgd2hlcmUgdGhpcyByZXByZXNlbnRhdGl2ZSBpcyB0byBiZSBhY3RpdmUuXG4gKiB9XG4gKlxuICogcmV0dXJuOiBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBuZXcgdG90YWwgbnVtYmVyIG9mIHByb3hpZXMgZm9yIHRoaXMgd2lkZ2V0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1ha2VQeVByb3h5KGFyZ3MpIHtcbiAgICBhd2FpdCBzZWxmLnB5b1JlYWR5O1xuICAgIGNvbnN0IGluZm8gPSBhcmdzLmluZm87XG4gICAgY29uc3QgcGFuZUlkID0gYXJncy5wYW5lSWQ7XG4gICAgY29uc3QgdWlkID0gaW5mb1sndWlkJ107XG4gICAgY29uc3QgdyA9IHNlbGYucGZzY2lzZWh1Yi5ub3Rlc01hbmFnZXIuZW5zdXJlV2lkZ2V0KHVpZCk7XG4gICAgY29uc3QgbWFrZU9iamVjdCA9IHNlbGYucHlvZGlkZS5nbG9iYWxzLmdldCgncGZzY19leGFtcCcpLm1ha2VfZXhhbXBfZ2VuZXJhdG9yX29ial9mcm9tX2pzO1xuICAgIGNvbnN0IG9iaiA9IG1ha2VPYmplY3QoaW5mbywgcGFuZUlkKTtcbiAgICBtYWtlT2JqZWN0LmRlc3Ryb3koKTsgIC8vIGRlc3Ryb3kgcHJveHkgb2YgZmFjdG9yeSBmdW5jIHRvIGF2b2lkIG1lbW9yeSBsZWFrXG4gICAgdy5hZGRQeVByb3h5KHBhbmVJZCwgb2JqKTtcbiAgICByZXR1cm4gdy5nZXROdW1Qcm94aWVzKCk7XG59XG5cblxuLyogRGVzdHJveSBhIHNpbmdsZSBQeVByb3h5IGZvciBhIHdpZGdldC4gSWYgdGhpcyB3YXMgdGhlIHdpZGdldCdzXG4gKiBsYXN0IHByb3h5LCBhbHNvIGRlbGV0ZSB0aGUgd2lkZ2V0IGZyb20gdGhlIE5vdGVzTWFuYWdlci5cbiAqXG4gKiBhcmdzOiB7XG4gKiAgIHVpZDogdGhlIHVpZCBvZiB0aGUgd2lkZ2V0IHRoYXQgd2FudHMgdG8gZGVzdHJveSBhIFB5UHJveHlcbiAqICAgcGFuZUlkOiB0aGUgaWQgb2YgdGhlIHBhbmUgd2hvc2UgcHJveHkgc2hvdWxkIGJlIGRlc3Ryb3llZFxuICogfVxuICpcbiAqIHJldHVybjogdGhlIG5ldyB0b3RhbCBudW1iZXIgb2YgcHJveGllcyBmb3IgdGhpcyB3aWRnZXRcbiAqL1xuZnVuY3Rpb24gZGVzdHJveVB5UHJveHkoYXJncykge1xuICAgIGNvbnN0IG5tID0gc2VsZi5wZnNjaXNlaHViLm5vdGVzTWFuYWdlcjtcbiAgICBjb25zdCB1aWQgPSBhcmdzLnVpZDtcbiAgICBjb25zdCBwYW5lSWQgPSBhcmdzLnBhbmVJZDtcbiAgICBjb25zdCB3ID0gbm0uZ2V0V2lkZ2V0KHVpZCk7XG4gICAgaWYgKHcpIHtcbiAgICAgICAgdy5kZXN0cm95UHJveHkocGFuZUlkKTtcbiAgICAgICAgY29uc3QgbiA9IHcuZ2V0TnVtUHJveGllcygpO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgbm0uZGVsZXRlV2lkZ2V0KHVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuXG4vKiBSZWJ1aWxkIGFuIGV4YW1wIHdpZGdldC5cbiAqXG4gKiBhcmdzOiB7XG4gKiAgIHVpZDogdGhlIHdpZGdldCB1aWQsXG4gKiAgIHBhbmVJZDogdGhlIGlkIG9mIHRoZSBwYW5lIHdoZXJlIHdlIHdhbnQgdG8gcmVidWlsZFxuICogICB2YWx1ZTogb3B0aW9uYWwsIG5ldyByYXcgdmFsdWUgdG8gcGFzcyB0byB0aGlzIHdpZGdldCdzIGBidWlsZGAgbWV0aG9kXG4gKiAgIHdyaXRlSHRtbDogYm9vbCwgb3B0aW9uYWwsIGRlZmF1bHQgZmFsc2U6IGlmIHRydWUsIGFzayB0aGUgd2lkZ2V0IHRvXG4gKiAgICAgZ2VuZXJhdGUgaXRzIChuZXcpIEhUTUxcbiAqIH1cbiAqXG4gKiByZXR1cm46IHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSBmcm9tIHRoZSBgcmVidWlsZF9leGFtcF9nZW5lcmF0b3JfZnJvbV9qcygpYFxuICogICBmdW5jdGlvbiBpbiB0aGUgcGZzYy1leGFtcCBweXRob24gcGFja2FnZS4gVGhpcyBpcyBhIGZvcm1hdHRlZCBvYmplY3QsIHdoaWNoIGNvbnRhaW5zXG4gKiAgIGFuIGVycm9yIGxldmVsLCBlcnJvciBtZXNzYWdlLCBhbmQgcmVzdWx0IHZhbHVlIGlmIHN1Y2Nlc3NmdWwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYnVpbGQoYXJncykge1xuICAgIGF3YWl0IHNlbGYucHlvUmVhZHk7XG4gICAgY29uc3Qge1xuICAgICAgICB1aWQsXG4gICAgICAgIHBhbmVJZCxcbiAgICAgICAgdmFsdWUgPSBudWxsLFxuICAgICAgICB3cml0ZUh0bWwgPSBmYWxzZSxcbiAgICB9ID0gYXJncztcbiAgICBjb25zdCBubSA9IHNlbGYucGZzY2lzZWh1Yi5ub3Rlc01hbmFnZXI7XG4gICAgY29uc3QgdyA9IG5tLmdldFdpZGdldCh1aWQpO1xuICAgIGNvbnN0IG9iaiA9IHcuZ2V0UHlQcm94eUNvcHkocGFuZUlkKTtcbiAgICBjb25zdCByZWJ1aWxkRnVuYyA9IHNlbGYucHlvZGlkZS5nbG9iYWxzLmdldCgncGZzY19leGFtcCcpLnJlYnVpbGRfZXhhbXBfZ2VuZXJhdG9yX2Zyb21fanM7XG4gICAgY29uc3QgcmVzcG9uc2UgPSByZWJ1aWxkRnVuYy5jYWxsS3dhcmdzKG9iaiwge3ZhbHVlOiB2YWx1ZSwgd3JpdGVfaHRtbDogd3JpdGVIdG1sfSk7XG4gICAgLy8gRGVzdHJveSBQeVByb3h5IG9mIGByZWJ1aWxkYCB0byBhdm9pZCBtZW1vcnkgbGVhay5cbiAgICAvLyBgcmVzcG9uc2VgIG9iamVjdCBkb2VzIG5vdCBuZWVkIHRvIGJlIGRlc3Ryb3llZCwgc2luY2UgaXQgd2FzIGNvbnZlcnRlZCB3aXRoIGB0b19qcygpYFxuICAgIC8vIG9uIHRoZSBweXRob24gc2lkZS5cbiAgICByZWJ1aWxkRnVuYy5kZXN0cm95KCk7XG4gICAgLy8gYHJlc3BvbnNlYCBpcyBhIE1hcC4gQ29udmVydCB0byBhbiBPYmplY3QuXG4gICAgY29uc3QgcmVzcE9iaiA9IE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BPYmo7XG59XG5cblxuY2xhc3MgTm90ZXNNYW5hZ2VyIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLndpZGdldHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgZ2V0V2lkZ2V0KHVpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXRzLmdldCh1aWQpO1xuICAgIH1cblxuICAgIGVuc3VyZVdpZGdldCh1aWQpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkZ2V0cy5oYXModWlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0cy5nZXQodWlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBuZXcgV2lkZ2V0KHVpZCk7XG4gICAgICAgICAgICB0aGlzLndpZGdldHMuc2V0KHVpZCwgdyk7XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZVdpZGdldCh1aWQpIHtcbiAgICAgICAgdGhpcy53aWRnZXRzLmRlbGV0ZSh1aWQpO1xuICAgIH1cblxufVxuXG5cbmNsYXNzIFdpZGdldCB7XG5cbiAgICBjb25zdHJ1Y3Rvcih1aWQpIHtcbiAgICAgICAgdGhpcy51aWQgPSB1aWQ7XG4gICAgICAgIHRoaXMucHlQcm94aWVzQnlQYW5lSWQgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgYWRkUHlQcm94eShwYW5lSWQsIHByb3h5KSB7XG4gICAgICAgIHRoaXMucHlQcm94aWVzQnlQYW5lSWQuc2V0KHBhbmVJZCwgcHJveHkpO1xuICAgIH1cblxuICAgIC8qIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciB1c2UgYnkgUHl0aG9uIGNvZGUgcnVubmluZyBpbiBQeW9kaWRlLlxuICAgICAqIFRoZSByZWFzb24gZm9yIHJldHVybmluZyBhICpjb3B5KiBvZiB0aGUgUHlQcm94eSBvYmplY3Qgd2UgaGF2ZSBzdG9yZWRcbiAgICAgKiBpcyB0aGF0IHRoaXMgcHJldmVudHMgdGhlIFB5UHJveHkgZnJvbSBiZWluZyBkZXN0cm95ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICAgKiBiZWluZyBwYXNzZWQgYmFjayB0byB0aGUgUHkgc2lkZS5cbiAgICAgKiBTZWU6XG4gICAgICogICBodHRwczovL3B5b2RpZGUub3JnL2VuL3N0YWJsZS91c2FnZS90eXBlLWNvbnZlcnNpb25zLmh0bWwjY2FsbGluZy1qYXZhc2NyaXB0LWZ1bmN0aW9ucy1mcm9tLXB5dGhvblxuICAgICAqL1xuICAgIGdldFB5UHJveHlDb3B5KHBhbmVJZCkge1xuICAgICAgICBjb25zdCBwcm94eSA9IHRoaXMucHlQcm94aWVzQnlQYW5lSWQuZ2V0KHBhbmVJZCk7XG4gICAgICAgIHJldHVybiBwcm94eS5jb3B5KCk7XG4gICAgfVxuXG4gICAgZ2V0TnVtUHJveGllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHlQcm94aWVzQnlQYW5lSWQuc2l6ZTtcbiAgICB9XG5cbiAgICBkZXN0cm95UHJveHkocGFuZUlkKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnB5UHJveGllc0J5UGFuZUlkLmdldChwYW5lSWQpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgcC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnB5UHJveGllc0J5UGFuZUlkLmRlbGV0ZShwYW5lSWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cblxuLyogV2UgYnVpbGQgYSBkdW1teSBlbnZpcm9ubWVudCBzbyB0aGF0IHRoZSBzYW1lIGNvZGUgdGhhdCB3YXMgZGVzaWduZWQgdG9cbiAqIHdvcmsgd2l0aCBQeW9kaWRlIHJ1bm5pbmcgaW4gdGhlIG1haW4gcGFnZSBjYW4gYWxzbyB3b3JrIGhlcmUuXG4gKi9cbnNlbGYucGZzY2lzZWh1YiA9IHtcbiAgICBub3Rlc01hbmFnZXI6IG5ldyBOb3Rlc01hbmFnZXIoKSxcbn07XG5cblxuY29uc3QgcGVlciA9IG5ldyBEZWRpY2F0ZWRXb3JrZXJQZWVyKHNlbGYpO1xucGVlci5hZGRIYW5kbGVyKCdlY2hvJywgZWNobyk7XG5wZWVyLmFkZEhhbmRsZXIoJ3BpbmcnLCBwaW5nKTtcbnBlZXIuYWRkSGFuZGxlcignc3RhcnR1cCcsIHN0YXJ0dXApO1xucGVlci5hZGRIYW5kbGVyKCdtYWtlUHlQcm94eScsIG1ha2VQeVByb3h5KTtcbnBlZXIuYWRkSGFuZGxlcignZGVzdHJveVB5UHJveHknLCBkZXN0cm95UHlQcm94eSk7XG5wZWVyLmFkZEhhbmRsZXIoJ3JlYnVpbGQnLCByZWJ1aWxkKTtcbnBlZXIuc2V0UmVhZHkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/mathworker.js\n");

/***/ }),

/***/ "../../../../../../private/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-4709JUkgfnxUB4Gi/dojo/dojo.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../../../../private/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-4709JUkgfnxUB4Gi/dojo/dojo.js ***!
  \*******************************************************************************************************************/
/***/ ((module) => {

eval("module.exports = function(userConfig, defaultConfig, global, window) { this.loaderVersion = \"1.16.4\"; (function(\n\tuserConfig,\n\tdefaultConfig\n){\n\t// summary:\n\t//\t\tThis is the \"source loader\" and is the entry point for Dojo during development. You may also load Dojo with\n\t//\t\tany AMD-compliant loader via the package main module dojo/main.\n\t// description:\n\t//\t\tThis is the \"source loader\" for Dojo. It provides an AMD-compliant loader that can be configured\n\t//\t\tto operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded\n\t//\t\tIAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package\n\t//\t\tvia the package main module dojo/main and this loader is not required; see dojo/package.json for details.\n\t//\n\t//\t\tIn order to keep compatibility with the v1.x line, this loader includes additional machinery that enables\n\t//\t\tthe dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed\n\t//\t\tvia the has.js API and statically removed via the build system.\n\t//\n\t//\t\tThis loader includes sniffing machinery to determine the environment; the following environments are supported:\n\t//\n\t//\t\t- browser\n\t//\t\t- node.js\n\t//\t\t- rhino\n\t//\n\t//\t\tThis is the so-called \"source loader\". As such, it includes many optional features that may be discarded by\n\t//\t\tbuilding a customized version with the build system.\n\n\t// Design and Implementation Notes\n\t//\n\t// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.\n\t//\n\t// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)\n\t// loader that can be configured to operate in either synchronous or asynchronous modes.\n\t//\n\t// Since this machinery implements a loader, it does not have the luxury of using a load system and/or\n\t// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:\n\t//\n\t//\t 1. Small library for use implementing the loader.\n\t//\t 2. Define the has.js API; this is used throughout the loader to bracket features.\n\t//\t 3. Define the node.js and rhino sniffs and sniff.\n\t//\t 4. Define the loader's data.\n\t//\t 5. Define the configuration machinery.\n\t//\t 6. Define the script element sniffing machinery and sniff for configuration data.\n\t//\t 7. Configure the loader IAW the provided user, default, and sniffing data.\n\t//\t 8. Define the global require function.\n\t//\t 9. Define the module resolution machinery.\n\t//\t10. Define the module and plugin module definition machinery\n\t//\t11. Define the script injection machinery.\n\t//\t12. Define the window load detection.\n\t//\t13. Define the logging API.\n\t//\t14. Define the tracing API.\n\t//\t16. Define the AMD define function.\n\t//\t17. Define the dojo v1.x provide/require machinery--so called \"legacy\" modes.\n\t//\t18. Publish global variables.\n\t//\n\t// Language and Acronyms and Idioms\n\t//\n\t// moduleId: a CJS module identifier, (used for public APIs)\n\t// mid: moduleId (used internally)\n\t// packageId: a package identifier (used for public APIs)\n\t// pid: packageId (used internally); the implied system or default package has pid===\"\"\n\t// pack: package is used internally to reference a package object (since javascript has reserved words including \"package\")\n\t// prid: plugin resource identifier\n\t// The integer constant 1 is used in place of true and 0 in place of false.\n\t//\n\t// The \"foreign-loader\" has condition is defined if another loader is being used (e.g. webpack) and this code is only\n\t// needed for resolving module identifiers based on the config.  In this case, only the functions require.toUrl and \n\t// require.toAbsMid are supported.  The require and define functions are not supported.\n\n\t// define global\n\tvar globalObject = (function(){\n\t\tif (typeof global !== 'undefined' && typeof global !== 'function') {\n\t\t\t// global spec defines a reference to the global object called 'global'\n\t\t\t// https://github.com/tc39/proposal-global\n\t\t\t// `global` is also defined in NodeJS\n\t\t\treturn global;\n\t\t}\n\t\telse if (typeof window !== 'undefined') {\n\t\t\t// window is defined in browsers\n\t\t\treturn window;\n\t\t}\n\t\telse if (typeof self !== 'undefined') {\n\t\t\t// self is defined in WebWorkers\n\t\t\treturn self;\n\t\t}\n\t\treturn this;\n\t})();\n\n\t// define a minimal library to help build the loader\n\tvar noop = function(){\n\t\t},\n\n\t\tisEmpty = function(it){\n\t\t\tfor(var p in it){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t},\n\n\t\ttoString = {}.toString,\n\n\t\tisFunction = function(it){\n\t\t\treturn toString.call(it) == \"[object Function]\";\n\t\t},\n\n\t\tisString = function(it){\n\t\t\treturn toString.call(it) == \"[object String]\";\n\t\t},\n\n\t\tisArray = function(it){\n\t\t\treturn toString.call(it) == \"[object Array]\";\n\t\t},\n\n\t\tforEach = function(vector, callback){\n\t\t\tif(vector){\n\t\t\t\tfor(var i = 0; i < vector.length;){\n\t\t\t\t\tcallback(vector[i++]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmix = function(dest, src){\n\t\t\tfor(var p in src){\n\t\t\t\tdest[p] = src[p];\n\t\t\t}\n\t\t\treturn dest;\n\t\t},\n\n\t\tmakeError = function(error, info){\n\t\t\treturn mix(new Error(error), {src:\"dojoLoader\", info:info});\n\t\t},\n\n\t\tuidSeed = 1,\n\n\t\tuid = function(){\n\t\t\t// Returns a unique identifier (within the lifetime of the document) of the form /_d+/.\n\t\t\treturn \"_\" + uidSeed++;\n\t\t},\n\n\t\t// FIXME: how to doc window.require() api\n\n\t\t// this will be the global require function; define it immediately so we can start hanging things off of it\n\t\treq = function(\n\t\t\tconfig,\t\t  //(object, optional) hash of configuration properties\n\t\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback\n\t\t\tcallback\t  //(function, optional) lambda expression to apply to module values implied by dependencies\n\t\t){\n\t\t\treturn contextRequire(config, dependencies, callback, 0, req);\n\t\t},\n\n\t\t// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout\n\t\tglobal = globalObject,\n\n\t\tdoc = global.document,\n\n\t\telement = doc && doc.createElement(\"DiV\"),\n\n\t\thas = req.has = function(name){\n\t\t\treturn isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];\n\t\t},\n\n\t\thasCache = has.cache = defaultConfig.hasCache;\n\n\tif (isFunction(userConfig)) {\n\t\tuserConfig = userConfig(globalObject);\n\t}\n\n\thas.add = function(name, test, now, force){\n\t\t(hasCache[name]===undefined || force) && (hasCache[name] = test);\n\t\treturn now && has(name);\n\t};\n\n\t 0 && 0;\n\tif( false ){}\n\n\t 0 && 0;\n\tif( false ){ var baseUrl, arg, rhinoArgs, i; }\n\n\t 0 && 0;\n\tif( false ){}\n\n\t// userConfig has tests override defaultConfig has tests; do this after the environment detection because\n\t// the environment detection usually sets some has feature values in the hasCache.\n\tfor(var p in userConfig.has){\n\t\thas.add(p, userConfig.has[p], 0, 1);\n\t}\n\n\t//\n\t// define the loader data\n\t//\n\n\t// the loader will use these like symbols if the loader has the traceApi; otherwise\n\t// define magic numbers so that modules can be provided as part of defaultConfig\n\tvar requested = 1,\n\t\tarrived = 2,\n\t\tnonmodule = 3,\n\t\texecuting = 4,\n\t\texecuted = 5;\n\n\tif( false ){}\n\n\tvar legacyMode = 0,\n\t\tsync = \"sync\",\n\t\txd = \"xd\",\n\t\tsyncExecStack = [],\n\t\tdojoRequirePlugin = 0,\n\t\tcheckDojoRequirePlugin = noop,\n\t\ttransformToAmd = noop,\n\t\tgetXhr;\n\tif( false ){ var XMLHTTP_PROGIDS, progid, i, locationProtocol, locationHost; }else{\n\t\treq.async = 1;\n\t}\n\n\t//\n\t// loader eval\n\t//\n\tvar eval_ =    true  ?\n\t\t// noop eval if there are csp restrictions\n\t\tfunction(){} :\n\t\t// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution\n\t\t0;\n\n\treq.eval =\n\t\tfunction(text, hint){\n\t\t\treturn eval_(text + \"\\r\\n//# sourceURL=\" + hint);\n\t\t};\n\n\t//\n\t// loader micro events API\n\t//\n\tvar listenerQueues = {},\n\t\terror = \"error\",\n\t\tsignal = req.signal = function(type, args){\n\t\t\tvar queue = listenerQueues[type];\n\t\t\t// notice we run a copy of the queue; this allows listeners to add/remove\n\t\t\t// other listeners without affecting this particular signal\n\t\t\tforEach(queue && queue.slice(0), function(listener){\n\t\t\t\tlistener.apply(null, isArray(args) ? args : [args]);\n\t\t\t});\n\t\t},\n\t\ton = req.on = function(type, listener){\n\t\t\t// notice a queue is not created until a client actually connects\n\t\t\tvar queue = listenerQueues[type] || (listenerQueues[type] = []);\n\t\t\tqueue.push(listener);\n\t\t\treturn {\n\t\t\t\tremove:function(){\n\t\t\t\t\tfor(var i = 0; i<queue.length; i++){\n\t\t\t\t\t\tif(queue[i]===listener){\n\t\t\t\t\t\t\tqueue.splice(i, 1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded\n\t// lexical variables hold key loader data structures to help with minification; these may be completely,\n\t// one-time initialized by defaultConfig for optimized/built versions\n\tvar\n\t\taliases\n\t\t\t// a vector of pairs of [regexs or string, replacement] => (alias, actual)\n\t\t\t= [],\n\n\t\tpaths\n\t\t\t// CommonJS paths\n\t\t\t= {},\n\n\t\tpathsMapProg\n\t\t\t// list of (from-path, to-path, regex, length) derived from paths;\n\t\t\t// a \"program\" to apply paths; see computeMapProg\n\t\t\t= [],\n\n\t\tpacks\n\t\t\t// a map from packageId to package configuration object; see fixupPackageInfo\n\t\t\t= {},\n\n\t\tmap = req.map\n\t\t\t// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map\n\t\t\t= {},\n\n\t\tmapProgs\n\t\t\t// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value\n\t\t\t= [],\n\n\t\tmodules\n\t\t\t// A hash:(mid) --> (module-object) the module namespace\n\t\t\t//\n\t\t\t// pid: the package identifier to which the module belongs (e.g., \"dojo\"); \"\" indicates the system or default package\n\t\t\t// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., \"dojo/io/script\")\n\t\t\t// url: the URL from which the module was retrieved\n\t\t\t// pack: the package object of the package to which the module belongs\n\t\t\t// executed: 0 => not executed; executing => in the process of traversing deps and running factory; executed => factory has been executed\n\t\t\t// deps: the dependency vector for this module (vector of modules objects)\n\t\t\t// def: the factory for this module\n\t\t\t// result: the result of the running the factory for this module\n\t\t\t// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define\n\t\t\t// load: plugin load function; applicable only for plugins\n\t\t\t//\n\t\t\t// Modules go through several phases in creation:\n\t\t\t//\n\t\t\t// 1. Requested: some other module's definition or a require application contained the requested module in\n\t\t\t//\t  its dependency vector or executing code explicitly demands a module via req.require.\n\t\t\t//\n\t\t\t// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL\n\t\t\t//\n\t\t\t// 3. Loaded: the resource injected in [2] has been evaluated.\n\t\t\t//\n\t\t\t// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some\n\t\t\t//\t  resources may just contain a bundle of code and never formally define a module via define\n\t\t\t//\n\t\t\t// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.\n\t\t\t= {},\n\n\t\tcacheBust\n\t\t\t// query string to append to module URLs to bust browser cache\n\t\t\t= \"\",\n\n\t\tcache\n\t\t\t// hash:(mid | url)-->(function | string)\n\t\t\t//\n\t\t\t// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --> function or\n\t\t\t// url --> string. The url key is distinguished from the mid key by always containing the prefix \"url:\". url keys as provided\n\t\t\t// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided\n\t\t\t// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.\n\t\t\t//\n\t\t\t// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given\n\t\t\t// by any mappings *iff* the config.cache was received as part of a module resource request.\n\t\t\t//\n\t\t\t// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules\n\t\t\t// to retrieve cached items that may have arrived consequent to another namespace.\n\t\t\t//\n\t\t\t = {},\n\n\t\turlKeyPrefix\n\t\t\t// the prefix to prepend to a URL key in the cache.\n\t\t\t= \"url:\",\n\n\t\tpendingCacheInsert\n\t\t\t// hash:(mid)-->(function)\n\t\t\t//\n\t\t\t// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are\n\t\t\t// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another\n\t\t\t// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending\n\t\t\t// cache for the local configuration, possibly relocating modules.\n\t\t\t = {},\n\n\t\tdojoSniffConfig\n\t\t\t// map of configuration variables\n\t\t\t// give the data-dojo-config as sniffed from the document (if any)\n\t\t\t= {},\n\n\t\tinsertPointSibling\n\t\t\t// the nodes used to locate where scripts are injected into the document\n\t\t\t= 0;\n\n\tif( true ){\n\t\tif (false ) { var consumePendingCacheInsert; }\n\t\tvar escapeString = function(s){\n\t\t\t\treturn s.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, function(c){ return \"\\\\\" + c; });\n\t\t\t},\n\n\t\t\tcomputeMapProg = function(map, dest){\n\t\t\t\t// This routine takes a map as represented by a JavaScript object and initializes dest, a vector of\n\t\t\t\t// quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-\n\t\t\t\t// of-map-key. The regex looks for the map-key followed by either \"/\" or end-of-string at the beginning\n\t\t\t\t// of a the search source. Notice the map-value is irrelevant to the algorithm\n\t\t\t\tdest.splice(0, dest.length);\n\t\t\t\tfor(var p in map){\n\t\t\t\t\tdest.push([\n\t\t\t\t\t\tp,\n\t\t\t\t\t\tmap[p],\n\t\t\t\t\t\tnew RegExp(\"^\" + escapeString(p) + \"(\\/|$)\"),\n\t\t\t\t\t\tp.length]);\n\t\t\t\t}\n\t\t\t\tdest.sort(function(lhs, rhs){ return rhs[3] - lhs[3]; });\n\t\t\t\treturn dest;\n\t\t\t},\n\n\t\t\tcomputeAliases = function(config, dest){\n\t\t\t\tforEach(config, function(pair){\n\t\t\t\t\t// take a fixed-up copy...\n\t\t\t\t\tdest.push([isString(pair[0]) ? new RegExp(\"^\" + escapeString(pair[0]) + \"$\") : pair[0], pair[1]]);\n\t\t\t\t});\n\t\t\t},\n\n\n\t\t\tfixupPackageInfo = function(packageInfo){\n\t\t\t\t// calculate the precise (name, location, main, mappings) for a package\n\t\t\t\tvar name = packageInfo.name;\n\t\t\t\tif(!name){\n\t\t\t\t\t// packageInfo must be a string that gives the name\n\t\t\t\t\tname = packageInfo;\n\t\t\t\t\tpackageInfo = {name:name};\n\t\t\t\t}\n\t\t\t\tpackageInfo = mix({main:\"main\"}, packageInfo);\n\t\t\t\tpackageInfo.location = packageInfo.location ? packageInfo.location : name;\n\n\t\t\t\t// packageMap is deprecated in favor of AMD map\n\t\t\t\tif(packageInfo.packageMap){\n\t\t\t\t\tmap[name] = packageInfo.packageMap;\n\t\t\t\t}\n\n\t\t\t\tif(!packageInfo.main.indexOf(\"./\")){\n\t\t\t\t\tpackageInfo.main = packageInfo.main.substring(2);\n\t\t\t\t}\n\n\t\t\t\t// now that we've got a fully-resolved package object, push it into the configuration\n\t\t\t\tpacks[name] = packageInfo;\n\t\t\t},\n\n\t\t\tdelayedModuleConfig\n\t\t\t\t// module config cannot be consumed until the loader is completely initialized; therefore, all\n\t\t\t\t// module config detected during booting is memorized and applied at the end of loader initialization\n\t\t\t\t// TODO: this is a bit of a kludge; all config should be moved to end of loader initialization, but\n\t\t\t\t// we'll delay this chore and do it with a final loader 1.x cleanup after the 2.x loader prototyping is complete\n\t\t\t\t= [],\n\n\n\t\t\tconfig = function(config, booting, referenceModule){\n\t\t\t\tfor(var p in config){\n\t\t\t\t\tif(p==\"waitSeconds\"){\n\t\t\t\t\t\treq.waitms = (config[p] || 0) * 1000;\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"cacheBust\"){\n\t\t\t\t\t\tcacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + \"\") : \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"baseUrl\" || p==\"combo\"){\n\t\t\t\t\t\treq[p] = config[p];\n\t\t\t\t\t}\n\t\t\t\t\tif( false){ var mode; }\n\t\t\t\t\tif(config[p]!==hasCache){\n\t\t\t\t\t\t// accumulate raw config info for client apps which can use this to pass their own config\n\t\t\t\t\t\treq.rawConfig[p] = config[p];\n\t\t\t\t\t\tp!=\"has\" && has.add(\"config-\"+p, config[p], 0, booting);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// make sure baseUrl exists\n\t\t\t\tif(!req.baseUrl){\n\t\t\t\t\treq.baseUrl = \"./\";\n\t\t\t\t}\n\t\t\t\t// make sure baseUrl ends with a slash\n\t\t\t\tif(!/\\/$/.test(req.baseUrl)){\n\t\t\t\t\treq.baseUrl += \"/\";\n\t\t\t\t}\n\n\t\t\t\t// now do the special work for has, packages, packagePaths, paths, aliases, and cache\n\n\t\t\t\tfor(p in config.has){\n\t\t\t\t\thas.add(p, config.has[p], 0, booting);\n\t\t\t\t}\n\n\t\t\t\t// for each package found in any packages config item, augment the packs map owned by the loader\n\t\t\t\tforEach(config.packages, fixupPackageInfo);\n\n\t\t\t\t// for each packagePath found in any packagePaths config item, augment the packageConfig\n\t\t\t\t// packagePaths is deprecated; remove in 2.0\n\t\t\t\tfor(var baseUrl in config.packagePaths){\n\t\t\t\t\tforEach(config.packagePaths[baseUrl], function(packageInfo){\n\t\t\t\t\t\tvar location = baseUrl + \"/\" + packageInfo;\n\t\t\t\t\t\tif(isString(packageInfo)){\n\t\t\t\t\t\t\tpackageInfo = {name:packageInfo};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpackageInfo.location = location;\n\t\t\t\t\t\tfixupPackageInfo(packageInfo);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// notice that computeMapProg treats the dest as a reference; therefore, if/when that variable\n\t\t\t\t// is published (see dojo-publish-privates), the published variable will always hold a valid value.\n\n\t\t\t\t// this must come after all package processing since package processing may mutate map\n\t\t\t\tcomputeMapProg(mix(map, config.map), mapProgs);\n\t\t\t\tforEach(mapProgs, function(item){\n\t\t\t\t\titem[1] = computeMapProg(item[1], []);\n\t\t\t\t\tif(item[0]==\"*\"){\n\t\t\t\t\t\tmapProgs.star = item;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// push in any paths and recompute the internal pathmap\n\t\t\t\tcomputeMapProg(mix(paths, config.paths), pathsMapProg);\n\n\t\t\t\t// aliases\n\t\t\t\tcomputeAliases(config.aliases, aliases);\n\n\t\t\t\tif (false ) { var module; }\n\t\t\t\tsignal(\"config\", [config, req.rawConfig]);\n\t\t\t};\n\n\t\t//\n\t\t// execute the various sniffs; userConfig can override and value\n\t\t//\n\n\t\tif( false ){ var scripts, i, script, dojoDir, src, match; }\n\n\t\tif( false ){ var doh; }\n\n\t\t// configure the loader; let the user override defaults\n\t\treq.rawConfig = {};\n\t\tconfig(defaultConfig, 1);\n\n\t\t// do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides\n\t\tif( false ){}\n\n\t\tconfig(userConfig, 1);\n\t\tconfig(dojoSniffConfig, 1);\n\n\t}else{}\n\n\n\tif (false ) { var injectDependencies, contextRequire, createRequire, execQ, defQ, waiting, setRequested, setArrived, execComplete, comboPending, combosPending, comboPendingTimer; }\n\n\tvar runMapProg = function(targetMid, map){\n\t\t\t// search for targetMid in map; return the map item if found; falsy otherwise\n\t\t\tif(map){\n\t\t\tfor(var i = 0; i < map.length; i++){\n\t\t\t\tif(map[i][2].test(targetMid)){\n\t\t\t\t\treturn map[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\tcompactPath = function(path){\n\t\t\tvar result = [],\n\t\t\t\tsegment, lastSegment;\n\t\t\tpath = path.replace(/\\\\/g, '/').split('/');\n\t\t\twhile(path.length){\n\t\t\t\tsegment = path.shift();\n\t\t\t\tif(segment==\"..\" && result.length && lastSegment!=\"..\"){\n\t\t\t\t\tresult.pop();\n\t\t\t\t\tlastSegment = result[result.length - 1];\n\t\t\t\t}else if(segment!=\".\"){\n\t\t\t\t\tresult.push(lastSegment= segment);\n\t\t\t\t} // else ignore \".\"\n\t\t\t}\n\t\t\treturn result.join(\"/\");\n\t\t},\n\n\t\tmakeModuleInfo = function(pid, mid, pack, url){\n\t\t\tif( false ){ var xd; }else{\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};\n\t\t\t}\n\t\t},\n\n\t\tgetModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate, fromPendingCache){\n\t\t\t// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)\n\t\t\t// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader\n\t\t\tvar pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;\n\t\t\trequestedMid = mid;\n\t\t\tisRelative = /^\\./.test(mid);\n\t\t\tif(/(^\\/)|(\\:)|(\\.js$)/.test(mid) || (isRelative && !referenceModule)){\n\t\t\t\t// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page\n\t\t\t\t// whatever it is, it's not a module but just a URL of some sort\n\t\t\t\t// note: pid===0 indicates the routine is returning an unmodified mid\n\n\t\t\t\treturn makeModuleInfo(0, mid, 0, mid);\n\t\t\t}else{\n\t\t\t\t// relative module ids are relative to the referenceModule; get rid of any dots\n\t\t\t\tmid = compactPath(isRelative ? (referenceModule.mid + \"/../\" + mid) : mid);\n\t\t\t\tif(/^\\./.test(mid)){\n\t\t\t\t\tthrow makeError(\"irrationalPath\", mid);\n\t\t\t\t}\n\t\t\t\t// at this point, mid is an absolute mid\n\n\t\t\t\t// map the mid\n\t\t\t\tif(!fromPendingCache && !isRelative && mapProgs.star){\n\t\t\t\t\tmapItem = runMapProg(mid, mapProgs.star[1]);\n\t\t\t\t}\n\t\t\t\tif(!mapItem && referenceModule){\n\t\t\t\t\tmapItem = runMapProg(referenceModule.mid, mapProgs);\n\t\t\t\t\tmapItem = mapItem && runMapProg(mid, mapItem[1]);\n\t\t\t\t}\n\n\t\t\t\tif(mapItem){\n\t\t\t\t\tmid = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t\t\t}\n\n\t\t\t\tmatch = mid.match(/^([^\\/]+)(\\/(.+))?$/);\n\t\t\t\tpid = match ? match[1] : \"\";\n\t\t\t\tif((pack = packs[pid])){\n\t\t\t\t\tmid = pid + \"/\" + (midInPackage = (match[3] || pack.main));\n\t\t\t\t}else{\n\t\t\t\t\tpid = \"\";\n\t\t\t\t}\n\n\t\t\t\t// search aliases\n\t\t\t\tvar candidateLength = 0,\n\t\t\t\t\tcandidate = 0;\n\t\t\t\tforEach(aliases, function(pair){\n\t\t\t\t\tvar match = mid.match(pair[0]);\n\t\t\t\t\tif(match && match.length>candidateLength){\n\t\t\t\t\t\tcandidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(candidate){\n\t\t\t\t\treturn getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);\n\t\t\t\t}\n\n\t\t\t\tresult = modules[mid];\n\t\t\t\tif(result){\n\t\t\t\t\treturn alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the\n\t\t\t// fully resolved (i.e., all relative indicators and package mapping resolved) module id\n\n\t\t\t// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid\n\t\t\tmapItem = runMapProg(mid, pathsMapProg);\n\t\t\tif(mapItem){\n\t\t\t\turl = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t}else if(pid){\n\t\t\t\turl = (pack.location.slice(-1) === '/' ? pack.location.slice(0, -1) : pack.location) + \"/\" + midInPackage;\n\t\t\t}else if( false ){}else{\n\t\t\t\turl = mid;\n\t\t\t}\n\t\t\t// if result is not absolute, add baseUrl\n\t\t\tif(!(/(^\\/)|(\\:)/.test(url))){\n\t\t\t\turl = baseUrl + url;\n\t\t\t}\n\t\t\turl += \".js\";\n\t\t\treturn makeModuleInfo(pid, mid, pack, compactPath(url));\n\t\t},\n\n\t\tgetModuleInfo = function(mid, referenceModule, fromPendingCache){\n\t\t\treturn getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, mapProgs, pathsMapProg, aliases, undefined, fromPendingCache);\n\t\t};\n\n\tif (false ) { var resolvePluginResourceId, dynamicPluginUidGenerator, getModule; }\n\n\tvar toAbsMid = req.toAbsMid = function(mid, referenceModule){\n\t\t\treturn getModuleInfo(mid, referenceModule).mid;\n\t\t},\n\n\t\ttoUrl = req.toUrl = function(name, referenceModule){\n\t\t\tvar moduleInfo = getModuleInfo(name+\"/x\", referenceModule),\n\t\t\t\turl= moduleInfo.url;\n\t\t\treturn fixupUrl(moduleInfo.pid===0 ?\n\t\t\t\t// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases\n\t\t\t\tname :\n\t\t\t\t// \"/x.js\" since getModuleInfo automatically appends \".js\" and we appended \"/x\" to make name look like a module id\n\t\t\t\turl.substring(0, url.length-5)\n\t\t\t);\n\t\t};\n\n\tif (false ) { var nonModuleProps, makeCjs, cjsRequireModule, cjsExportsModule, cjsModuleModule, runFactory, abortExec, defOrder, promoteModuleToPlugin, resolvePluginLoadQ, finishExec, circleTrace, execModule, checkCompleteGuard, guardCheckComplete, checkComplete; }\n\n\tvar fixupUrl= typeof userConfig.fixupUrl == \"function\" ? userConfig.fixupUrl : function(url){\n\t\t\turl += \"\"; // make sure url is a Javascript string (some paths may be a Java string)\n\t\t\treturn url + (cacheBust ? ((/\\?/.test(url) ? \"&\" : \"?\") + cacheBust) : \"\");\n\t\t};\n\n\n\n\tif( false ){}\n\n\tif( false ){ var injectPlugin, cached, injectingModule, injectingCachedModule, evalModuleText, injectModule, defineModule, runDefQ; }\n\n\tvar timerId = 0,\n\t\tclearTimer = noop,\n\t\tstartTimer = noop;\n\tif( false ){}\n\n\tif ( false ) {}\n\n\tif( false){ var scripts, i, script, domOn, windowOnLoadListener; }\n\n\tif( false ){}else{\n\t\treq.log = noop;\n\t}\n\n\tif( false ){ var trace; }else{\n\t\treq.trace = noop;\n\t}\n\tif (false ) { var def; } else {\n\t\tvar def = noop;\n\t}\n\t// allow config to override default implementation of named functions; this is useful for\n\t// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.\n\t// also useful for testing and monkey patching loader\n\tmix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);\n\n\t// now that req is fully initialized and won't change, we can hook it up to the error signal\n\ton(error, function(arg){\n\t\ttry{\n\t\t\tconsole.error(arg);\n\t\t\tif(arg instanceof Error){\n\t\t\t\tfor(var p in arg){\n\t\t\t\t\tconsole.log(p + \":\", arg[p]);\n\t\t\t\t}\n\t\t\t\tconsole.log(\".\");\n\t\t\t}\n\t\t}catch(e){}\n\t});\n\n\t// always publish these\n\tmix(req, {\n\t\tuid:uid,\n\t\tcache:cache,\n\t\tpacks:packs\n\t});\n\n\n\tif( false ){}\n\n\t// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are\n\t// *required* to define (as opposed to require, which is optional)\n\tif(global.define){\n\t\tif( false ){}\n\t\treturn;\n\t}else{\n\t\tglobal.define = def;\n\t\tglobal.require = req;\n\t\tif( false ){}\n\t}\n\n\tif( false){ var plugins, pluginName; }\n\n\tif( false ){ var bootDeps, bootCallback; }\n\tif(false ){}\n})\n.call(this, userConfig, defaultConfig);};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vLi4vLi4vcHJpdmF0ZS92YXIvZm9sZGVycy83Mi93NjN3YjZwNTMwemRycTQ1NWM1enhrcG0wMDAwZ24vVC90bXAtNDcwOUpVa2dmbnhVQjRHaS9kb2pvL2Rvam8uanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQU1BO0FBQ0E7QUFHQTtBQVlBO0FBQ0E7QUFDQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW9DQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBZ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBMFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFpQkE7QUFDQTtBQVVBO0FBQ0E7QUF1RUE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBeUNBO0FBQ0E7QUFDQTtBQTBGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQU1BO0FBSUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Bmc2MtaXNlLy4uLy4uLy4uLy4uLy4uLy4uL3ByaXZhdGUvdmFyL2ZvbGRlcnMvNzIvdzYzd2I2cDUzMHpkcnE0NTVjNXp4a3BtMDAwMGduL1QvdG1wLTQ3MDlKVWtnZm54VUI0R2kvZG9qby9kb2pvLmpzP2ZhNjIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VyQ29uZmlnLCBkZWZhdWx0Q29uZmlnLCBnbG9iYWwsIHdpbmRvdykgeyB0aGlzLmxvYWRlclZlcnNpb24gPSBcIjEuMTYuNFwiOyAoZnVuY3Rpb24oXG5cdHVzZXJDb25maWcsXG5cdGRlZmF1bHRDb25maWdcbil7XG5cdC8vIHN1bW1hcnk6XG5cdC8vXHRcdFRoaXMgaXMgdGhlIFwic291cmNlIGxvYWRlclwiIGFuZCBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIERvam8gZHVyaW5nIGRldmVsb3BtZW50LiBZb3UgbWF5IGFsc28gbG9hZCBEb2pvIHdpdGhcblx0Ly9cdFx0YW55IEFNRC1jb21wbGlhbnQgbG9hZGVyIHZpYSB0aGUgcGFja2FnZSBtYWluIG1vZHVsZSBkb2pvL21haW4uXG5cdC8vIGRlc2NyaXB0aW9uOlxuXHQvL1x0XHRUaGlzIGlzIHRoZSBcInNvdXJjZSBsb2FkZXJcIiBmb3IgRG9qby4gSXQgcHJvdmlkZXMgYW4gQU1ELWNvbXBsaWFudCBsb2FkZXIgdGhhdCBjYW4gYmUgY29uZmlndXJlZFxuXHQvL1x0XHR0byBvcGVyYXRlIGluIGVpdGhlciBzeW5jaHJvbm91cyBvciBhc3luY2hyb25vdXMgbW9kZXMuIEFmdGVyIHRoZSBsb2FkZXIgaXMgZGVmaW5lZCwgZG9qbyBpcyBsb2FkZWRcblx0Ly9cdFx0SUFXIHRoZSBwYWNrYWdlIG1haW4gbW9kdWxlIGRvam8vbWFpbi4gSW4gdGhlIGV2ZW50IHlvdSB3aXNoIHRvIHVzZSBhIGZvcmVpZ24gbG9hZGVyLCB5b3UgbWF5IGxvYWQgZG9qbyBhcyBhIHBhY2thZ2Vcblx0Ly9cdFx0dmlhIHRoZSBwYWNrYWdlIG1haW4gbW9kdWxlIGRvam8vbWFpbiBhbmQgdGhpcyBsb2FkZXIgaXMgbm90IHJlcXVpcmVkOyBzZWUgZG9qby9wYWNrYWdlLmpzb24gZm9yIGRldGFpbHMuXG5cdC8vXG5cdC8vXHRcdEluIG9yZGVyIHRvIGtlZXAgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSB2MS54IGxpbmUsIHRoaXMgbG9hZGVyIGluY2x1ZGVzIGFkZGl0aW9uYWwgbWFjaGluZXJ5IHRoYXQgZW5hYmxlc1xuXHQvL1x0XHR0aGUgZG9qby5wcm92aWRlLCBkb2pvLnJlcXVpcmUgZXQgYWwgQVBJLiBUaGlzIG1hY2hpbmVyeSBpcyBsb2FkZWQgYnkgZGVmYXVsdCwgYnV0IG1heSBiZSBkeW5hbWljYWxseSByZW1vdmVkXG5cdC8vXHRcdHZpYSB0aGUgaGFzLmpzIEFQSSBhbmQgc3RhdGljYWxseSByZW1vdmVkIHZpYSB0aGUgYnVpbGQgc3lzdGVtLlxuXHQvL1xuXHQvL1x0XHRUaGlzIGxvYWRlciBpbmNsdWRlcyBzbmlmZmluZyBtYWNoaW5lcnkgdG8gZGV0ZXJtaW5lIHRoZSBlbnZpcm9ubWVudDsgdGhlIGZvbGxvd2luZyBlbnZpcm9ubWVudHMgYXJlIHN1cHBvcnRlZDpcblx0Ly9cblx0Ly9cdFx0LSBicm93c2VyXG5cdC8vXHRcdC0gbm9kZS5qc1xuXHQvL1x0XHQtIHJoaW5vXG5cdC8vXG5cdC8vXHRcdFRoaXMgaXMgdGhlIHNvLWNhbGxlZCBcInNvdXJjZSBsb2FkZXJcIi4gQXMgc3VjaCwgaXQgaW5jbHVkZXMgbWFueSBvcHRpb25hbCBmZWF0dXJlcyB0aGF0IG1heSBiZSBkaXNjYXJkZWQgYnlcblx0Ly9cdFx0YnVpbGRpbmcgYSBjdXN0b21pemVkIHZlcnNpb24gd2l0aCB0aGUgYnVpbGQgc3lzdGVtLlxuXG5cdC8vIERlc2lnbiBhbmQgSW1wbGVtZW50YXRpb24gTm90ZXNcblx0Ly9cblx0Ly8gVGhpcyBpcyBhIGRvam8tc3BlY2lmaWMgYWRhcHRpb24gb2YgYmRMb2FkLCBkb25hdGVkIHRvIHRoZSBkb2pvIGZvdW5kYXRpb24gYnkgQWx0b3Zpc28gTExDLlxuXHQvL1xuXHQvLyBUaGlzIGZ1bmN0aW9uIGRlZmluZXMgYW4gQU1ELWNvbXBsaWFudCAoaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvTW9kdWxlcy9Bc3luY2hyb25vdXNEZWZpbml0aW9uKVxuXHQvLyBsb2FkZXIgdGhhdCBjYW4gYmUgY29uZmlndXJlZCB0byBvcGVyYXRlIGluIGVpdGhlciBzeW5jaHJvbm91cyBvciBhc3luY2hyb25vdXMgbW9kZXMuXG5cdC8vXG5cdC8vIFNpbmNlIHRoaXMgbWFjaGluZXJ5IGltcGxlbWVudHMgYSBsb2FkZXIsIGl0IGRvZXMgbm90IGhhdmUgdGhlIGx1eHVyeSBvZiB1c2luZyBhIGxvYWQgc3lzdGVtIGFuZC9vclxuXHQvLyBsZXZlcmFnaW5nIGEgdXRpbGl0eSBsaWJyYXJ5LiBUaGlzIHJlc3VsdHMgaW4gYW4gdW5wbGVhc2FudGx5IGxvbmcgZmlsZTsgaGVyZSBpcyBhIHJvYWQgbWFwIG9mIHRoZSBjb250ZW50czpcblx0Ly9cblx0Ly9cdCAxLiBTbWFsbCBsaWJyYXJ5IGZvciB1c2UgaW1wbGVtZW50aW5nIHRoZSBsb2FkZXIuXG5cdC8vXHQgMi4gRGVmaW5lIHRoZSBoYXMuanMgQVBJOyB0aGlzIGlzIHVzZWQgdGhyb3VnaG91dCB0aGUgbG9hZGVyIHRvIGJyYWNrZXQgZmVhdHVyZXMuXG5cdC8vXHQgMy4gRGVmaW5lIHRoZSBub2RlLmpzIGFuZCByaGlubyBzbmlmZnMgYW5kIHNuaWZmLlxuXHQvL1x0IDQuIERlZmluZSB0aGUgbG9hZGVyJ3MgZGF0YS5cblx0Ly9cdCA1LiBEZWZpbmUgdGhlIGNvbmZpZ3VyYXRpb24gbWFjaGluZXJ5LlxuXHQvL1x0IDYuIERlZmluZSB0aGUgc2NyaXB0IGVsZW1lbnQgc25pZmZpbmcgbWFjaGluZXJ5IGFuZCBzbmlmZiBmb3IgY29uZmlndXJhdGlvbiBkYXRhLlxuXHQvL1x0IDcuIENvbmZpZ3VyZSB0aGUgbG9hZGVyIElBVyB0aGUgcHJvdmlkZWQgdXNlciwgZGVmYXVsdCwgYW5kIHNuaWZmaW5nIGRhdGEuXG5cdC8vXHQgOC4gRGVmaW5lIHRoZSBnbG9iYWwgcmVxdWlyZSBmdW5jdGlvbi5cblx0Ly9cdCA5LiBEZWZpbmUgdGhlIG1vZHVsZSByZXNvbHV0aW9uIG1hY2hpbmVyeS5cblx0Ly9cdDEwLiBEZWZpbmUgdGhlIG1vZHVsZSBhbmQgcGx1Z2luIG1vZHVsZSBkZWZpbml0aW9uIG1hY2hpbmVyeVxuXHQvL1x0MTEuIERlZmluZSB0aGUgc2NyaXB0IGluamVjdGlvbiBtYWNoaW5lcnkuXG5cdC8vXHQxMi4gRGVmaW5lIHRoZSB3aW5kb3cgbG9hZCBkZXRlY3Rpb24uXG5cdC8vXHQxMy4gRGVmaW5lIHRoZSBsb2dnaW5nIEFQSS5cblx0Ly9cdDE0LiBEZWZpbmUgdGhlIHRyYWNpbmcgQVBJLlxuXHQvL1x0MTYuIERlZmluZSB0aGUgQU1EIGRlZmluZSBmdW5jdGlvbi5cblx0Ly9cdDE3LiBEZWZpbmUgdGhlIGRvam8gdjEueCBwcm92aWRlL3JlcXVpcmUgbWFjaGluZXJ5LS1zbyBjYWxsZWQgXCJsZWdhY3lcIiBtb2Rlcy5cblx0Ly9cdDE4LiBQdWJsaXNoIGdsb2JhbCB2YXJpYWJsZXMuXG5cdC8vXG5cdC8vIExhbmd1YWdlIGFuZCBBY3JvbnltcyBhbmQgSWRpb21zXG5cdC8vXG5cdC8vIG1vZHVsZUlkOiBhIENKUyBtb2R1bGUgaWRlbnRpZmllciwgKHVzZWQgZm9yIHB1YmxpYyBBUElzKVxuXHQvLyBtaWQ6IG1vZHVsZUlkICh1c2VkIGludGVybmFsbHkpXG5cdC8vIHBhY2thZ2VJZDogYSBwYWNrYWdlIGlkZW50aWZpZXIgKHVzZWQgZm9yIHB1YmxpYyBBUElzKVxuXHQvLyBwaWQ6IHBhY2thZ2VJZCAodXNlZCBpbnRlcm5hbGx5KTsgdGhlIGltcGxpZWQgc3lzdGVtIG9yIGRlZmF1bHQgcGFja2FnZSBoYXMgcGlkPT09XCJcIlxuXHQvLyBwYWNrOiBwYWNrYWdlIGlzIHVzZWQgaW50ZXJuYWxseSB0byByZWZlcmVuY2UgYSBwYWNrYWdlIG9iamVjdCAoc2luY2UgamF2YXNjcmlwdCBoYXMgcmVzZXJ2ZWQgd29yZHMgaW5jbHVkaW5nIFwicGFja2FnZVwiKVxuXHQvLyBwcmlkOiBwbHVnaW4gcmVzb3VyY2UgaWRlbnRpZmllclxuXHQvLyBUaGUgaW50ZWdlciBjb25zdGFudCAxIGlzIHVzZWQgaW4gcGxhY2Ugb2YgdHJ1ZSBhbmQgMCBpbiBwbGFjZSBvZiBmYWxzZS5cblx0Ly9cblx0Ly8gVGhlIFwiZm9yZWlnbi1sb2FkZXJcIiBoYXMgY29uZGl0aW9uIGlzIGRlZmluZWQgaWYgYW5vdGhlciBsb2FkZXIgaXMgYmVpbmcgdXNlZCAoZS5nLiB3ZWJwYWNrKSBhbmQgdGhpcyBjb2RlIGlzIG9ubHlcblx0Ly8gbmVlZGVkIGZvciByZXNvbHZpbmcgbW9kdWxlIGlkZW50aWZpZXJzIGJhc2VkIG9uIHRoZSBjb25maWcuICBJbiB0aGlzIGNhc2UsIG9ubHkgdGhlIGZ1bmN0aW9ucyByZXF1aXJlLnRvVXJsIGFuZCBcblx0Ly8gcmVxdWlyZS50b0Fic01pZCBhcmUgc3VwcG9ydGVkLiAgVGhlIHJlcXVpcmUgYW5kIGRlZmluZSBmdW5jdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQuXG5cblx0Ly8gZGVmaW5lIGdsb2JhbFxuXHR2YXIgZ2xvYmFsT2JqZWN0ID0gKGZ1bmN0aW9uKCl7XG5cdFx0aWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdC8vIGdsb2JhbCBzcGVjIGRlZmluZXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgY2FsbGVkICdnbG9iYWwnXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcblx0XHRcdC8vIGBnbG9iYWxgIGlzIGFsc28gZGVmaW5lZCBpbiBOb2RlSlNcblx0XHRcdHJldHVybiBnbG9iYWw7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHQvLyB3aW5kb3cgaXMgZGVmaW5lZCBpbiBicm93c2Vyc1xuXHRcdFx0cmV0dXJuIHdpbmRvdztcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHQvLyBzZWxmIGlzIGRlZmluZWQgaW4gV2ViV29ya2Vyc1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9KSgpO1xuXG5cdC8vIGRlZmluZSBhIG1pbmltYWwgbGlicmFyeSB0byBoZWxwIGJ1aWxkIHRoZSBsb2FkZXJcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpe1xuXHRcdH0sXG5cblx0XHRpc0VtcHR5ID0gZnVuY3Rpb24oaXQpe1xuXHRcdFx0Zm9yKHZhciBwIGluIGl0KXtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9LFxuXG5cdFx0dG9TdHJpbmcgPSB7fS50b1N0cmluZyxcblxuXHRcdGlzRnVuY3Rpb24gPSBmdW5jdGlvbihpdCl7XG5cdFx0XHRyZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkgPT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xuXHRcdH0sXG5cblx0XHRpc1N0cmluZyA9IGZ1bmN0aW9uKGl0KXtcblx0XHRcdHJldHVybiB0b1N0cmluZy5jYWxsKGl0KSA9PSBcIltvYmplY3QgU3RyaW5nXVwiO1xuXHRcdH0sXG5cblx0XHRpc0FycmF5ID0gZnVuY3Rpb24oaXQpe1xuXHRcdFx0cmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpID09IFwiW29iamVjdCBBcnJheV1cIjtcblx0XHR9LFxuXG5cdFx0Zm9yRWFjaCA9IGZ1bmN0aW9uKHZlY3RvciwgY2FsbGJhY2spe1xuXHRcdFx0aWYodmVjdG9yKXtcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHZlY3Rvci5sZW5ndGg7KXtcblx0XHRcdFx0XHRjYWxsYmFjayh2ZWN0b3JbaSsrXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0bWl4ID0gZnVuY3Rpb24oZGVzdCwgc3JjKXtcblx0XHRcdGZvcih2YXIgcCBpbiBzcmMpe1xuXHRcdFx0XHRkZXN0W3BdID0gc3JjW3BdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRlc3Q7XG5cdFx0fSxcblxuXHRcdG1ha2VFcnJvciA9IGZ1bmN0aW9uKGVycm9yLCBpbmZvKXtcblx0XHRcdHJldHVybiBtaXgobmV3IEVycm9yKGVycm9yKSwge3NyYzpcImRvam9Mb2FkZXJcIiwgaW5mbzppbmZvfSk7XG5cdFx0fSxcblxuXHRcdHVpZFNlZWQgPSAxLFxuXG5cdFx0dWlkID0gZnVuY3Rpb24oKXtcblx0XHRcdC8vIFJldHVybnMgYSB1bmlxdWUgaWRlbnRpZmllciAod2l0aGluIHRoZSBsaWZldGltZSBvZiB0aGUgZG9jdW1lbnQpIG9mIHRoZSBmb3JtIC9fZCsvLlxuXHRcdFx0cmV0dXJuIFwiX1wiICsgdWlkU2VlZCsrO1xuXHRcdH0sXG5cblx0XHQvLyBGSVhNRTogaG93IHRvIGRvYyB3aW5kb3cucmVxdWlyZSgpIGFwaVxuXG5cdFx0Ly8gdGhpcyB3aWxsIGJlIHRoZSBnbG9iYWwgcmVxdWlyZSBmdW5jdGlvbjsgZGVmaW5lIGl0IGltbWVkaWF0ZWx5IHNvIHdlIGNhbiBzdGFydCBoYW5naW5nIHRoaW5ncyBvZmYgb2YgaXRcblx0XHRyZXEgPSBmdW5jdGlvbihcblx0XHRcdGNvbmZpZyxcdFx0ICAvLyhvYmplY3QsIG9wdGlvbmFsKSBoYXNoIG9mIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllc1xuXHRcdFx0ZGVwZW5kZW5jaWVzLCAvLyhhcnJheSBvZiBjb21tb25qcy5tb2R1bGVJZCwgb3B0aW9uYWwpIGxpc3Qgb2YgbW9kdWxlcyB0byBiZSBsb2FkZWQgYmVmb3JlIGFwcGx5aW5nIGNhbGxiYWNrXG5cdFx0XHRjYWxsYmFja1x0ICAvLyhmdW5jdGlvbiwgb3B0aW9uYWwpIGxhbWJkYSBleHByZXNzaW9uIHRvIGFwcGx5IHRvIG1vZHVsZSB2YWx1ZXMgaW1wbGllZCBieSBkZXBlbmRlbmNpZXNcblx0XHQpe1xuXHRcdFx0cmV0dXJuIGNvbnRleHRSZXF1aXJlKGNvbmZpZywgZGVwZW5kZW5jaWVzLCBjYWxsYmFjaywgMCwgcmVxKTtcblx0XHR9LFxuXG5cdFx0Ly8gdGhlIGxvYWRlciB1c2VzIHRoZSBoYXMuanMgQVBJIHRvIGNvbnRyb2wgZmVhdHVyZSBpbmNsdXNpb24vZXhjbHVzaW9uOyBkZWZpbmUgdGhlbiB1c2UgdGhyb3VnaG91dFxuXHRcdGdsb2JhbCA9IGdsb2JhbE9iamVjdCxcblxuXHRcdGRvYyA9IGdsb2JhbC5kb2N1bWVudCxcblxuXHRcdGVsZW1lbnQgPSBkb2MgJiYgZG9jLmNyZWF0ZUVsZW1lbnQoXCJEaVZcIiksXG5cblx0XHRoYXMgPSByZXEuaGFzID0gZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRyZXR1cm4gaXNGdW5jdGlvbihoYXNDYWNoZVtuYW1lXSkgPyAoaGFzQ2FjaGVbbmFtZV0gPSBoYXNDYWNoZVtuYW1lXShnbG9iYWwsIGRvYywgZWxlbWVudCkpIDogaGFzQ2FjaGVbbmFtZV07XG5cdFx0fSxcblxuXHRcdGhhc0NhY2hlID0gaGFzLmNhY2hlID0gZGVmYXVsdENvbmZpZy5oYXNDYWNoZTtcblxuXHRpZiAoaXNGdW5jdGlvbih1c2VyQ29uZmlnKSkge1xuXHRcdHVzZXJDb25maWcgPSB1c2VyQ29uZmlnKGdsb2JhbE9iamVjdCk7XG5cdH1cblxuXHRoYXMuYWRkID0gZnVuY3Rpb24obmFtZSwgdGVzdCwgbm93LCBmb3JjZSl7XG5cdFx0KGhhc0NhY2hlW25hbWVdPT09dW5kZWZpbmVkIHx8IGZvcmNlKSAmJiAoaGFzQ2FjaGVbbmFtZV0gPSB0ZXN0KTtcblx0XHRyZXR1cm4gbm93ICYmIGhhcyhuYW1lKTtcblx0fTtcblxuXHQgMCAmJiBoYXMuYWRkKFwiaG9zdC1ub2RlXCIsIHVzZXJDb25maWcuaGFzICYmIFwiaG9zdC1ub2RlXCIgaW4gdXNlckNvbmZpZy5oYXMgP1xuXHRcdHVzZXJDb25maWcuaGFzW1wiaG9zdC1ub2RlXCJdIDpcblx0XHQodHlwZW9mIHByb2Nlc3MgPT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSAmJiBwcm9jZXNzLnZlcnNpb25zLnY4KSk7XG5cdGlmKCAwICl7XG5cdFx0Ly8gZml4dXAgdGhlIGRlZmF1bHQgY29uZmlnIGZvciBub2RlLmpzIGVudmlyb25tZW50XG5cdFx0cmVxdWlyZShcIi4vX2Jhc2UvY29uZmlnTm9kZS5qc1wiKS5jb25maWcoZGVmYXVsdENvbmZpZyk7XG5cdFx0Ly8gcmVtZW1iZXIgbm9kZSdzIHJlcXVpcmUgKHdpdGggcmVzcGVjdCB0byBiYXNlVXJsPT1kb2pvJ3Mgcm9vdClcblx0XHRkZWZhdWx0Q29uZmlnLmxvYWRlclBhdGNoLm5vZGVSZXF1aXJlID0gcmVxdWlyZTtcblx0fVxuXG5cdCAwICYmIGhhcy5hZGQoXCJob3N0LXJoaW5vXCIsIHVzZXJDb25maWcuaGFzICYmIFwiaG9zdC1yaGlub1wiIGluIHVzZXJDb25maWcuaGFzID9cblx0XHR1c2VyQ29uZmlnLmhhc1tcImhvc3Qtcmhpbm9cIl0gOlxuXHRcdCh0eXBlb2YgbG9hZCA9PSBcImZ1bmN0aW9uXCIgJiYgKHR5cGVvZiBQYWNrYWdlcyA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIFBhY2thZ2VzID09IFwib2JqZWN0XCIpKSk7XG5cdGlmKCAwICl7XG5cdFx0Ly8gb3dpbmcgdG8gcmhpbm8ncyBsYW1lIGZlYXR1cmUgdGhhdCBoaWRlcyB0aGUgc291cmNlIG9mIHRoZSBzY3JpcHQsIGdpdmUgdGhlIHVzZXIgYSB3YXkgdG8gc3BlY2lmeSB0aGUgYmFzZVVybC4uLlxuXHRcdGZvcih2YXIgYmFzZVVybCA9IHVzZXJDb25maWcuYmFzZVVybCB8fCBcIi5cIiwgYXJnLCByaGlub0FyZ3MgPSB0aGlzLmFyZ3VtZW50cywgaSA9IDA7IGkgPCByaGlub0FyZ3MubGVuZ3RoOyl7XG5cdFx0XHRhcmcgPSAocmhpbm9BcmdzW2krK10gKyBcIlwiKS5zcGxpdChcIj1cIik7XG5cdFx0XHRpZihhcmdbMF0gPT0gXCJiYXNlVXJsXCIpe1xuXHRcdFx0XHRiYXNlVXJsID0gYXJnWzFdO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0bG9hZChiYXNlVXJsICsgXCIvX2Jhc2UvY29uZmlnUmhpbm8uanNcIik7XG5cdFx0cmhpbm9Eb2pvQ29uZmlnKGRlZmF1bHRDb25maWcsIGJhc2VVcmwsIHJoaW5vQXJncyk7XG5cdH1cblxuXHQgMCAmJiBoYXMuYWRkKFwiaG9zdC13ZWJ3b3JrZXJcIiwgKCh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnKSAmJiAoc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSkpO1xuXHRpZiggMCApe1xuXHRcdG1peChkZWZhdWx0Q29uZmlnLmhhc0NhY2hlLCB7XG5cdFx0XHRcImhvc3QtYnJvd3NlclwiOiAwLFxuXHRcdFx0XCJkb21cIjogMCxcblx0XHRcdFwiZG9qby1kb20tcmVhZHktYXBpXCI6IDAsXG5cdFx0XHRcImRvam8tc25pZmZcIjogMCxcblx0XHRcdFwiZG9qby1pbmplY3QtYXBpXCI6IDEsXG5cdFx0XHRcImhvc3Qtd2Vid29ya2VyXCI6IDEsXG5cdFx0XHRcImRvam8tZ3VhcmFudGVlLWNvbnNvbGVcIjogMCAvLyBjb25zb2xlIGlzIGltbXV0YWJsZSBpbiBGRjMwKywgc2VlIGh0dHBzOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0LzE4MTAwXG5cdFx0fSk7XG5cblx0XHRkZWZhdWx0Q29uZmlnLmxvYWRlclBhdGNoID0ge1xuXHRcdFx0aW5qZWN0VXJsOiBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKXtcblx0XHRcdFx0Ly8gVE9ETzpcblx0XHRcdFx0Ly9cdFx0VGhpcyBpcyBub3QgYXN5bmMsIG5vciBjYW4gaXQgYmUgaW4gV2Vid29ya2Vycy4gIEl0IGNvdWxkIGJlIG1hZGUgYmV0dGVyIGJ5IHBhc3Npbmdcblx0XHRcdFx0Ly9cdFx0dGhlIGVudGlyZSByZXF1aXJlIGFycmF5IGludG8gaW1wb3J0U2NyaXB0cyBhdC4gIFRoaXMgd2F5IHRoZSBzY3JpcHRzIGFyZSBsb2FkZWQgaW5cblx0XHRcdFx0Ly9cdFx0YXN5bmMgbW9kZTsgZXZlbiBpZiB0aGUgY2FsbGJhY2tzIGFyZSByYW4gaW4gc3luYy4gIEl0IGlzIG5vdCBhIG1ham9yIGlzc3VlIGFzIHdlYndvcmtlcnNcblx0XHRcdFx0Ly9cdFx0dGVuZCB0byBiZSBsb25nIHJ1bm5pbmcgd2hlcmUgaW5pdGlhbCBzdGFydHVwIGlzIG5vdCBhIG1ham9yIGZhY3Rvci5cblxuXHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0aW1wb3J0U2NyaXB0cyh1cmwpO1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHRjb25zb2xlLmluZm8oXCJmYWlsZWQgdG8gbG9hZCByZXNvdXJjZSAoXCIgKyB1cmwgKyBcIilcIik7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyB1c2VyQ29uZmlnIGhhcyB0ZXN0cyBvdmVycmlkZSBkZWZhdWx0Q29uZmlnIGhhcyB0ZXN0czsgZG8gdGhpcyBhZnRlciB0aGUgZW52aXJvbm1lbnQgZGV0ZWN0aW9uIGJlY2F1c2Vcblx0Ly8gdGhlIGVudmlyb25tZW50IGRldGVjdGlvbiB1c3VhbGx5IHNldHMgc29tZSBoYXMgZmVhdHVyZSB2YWx1ZXMgaW4gdGhlIGhhc0NhY2hlLlxuXHRmb3IodmFyIHAgaW4gdXNlckNvbmZpZy5oYXMpe1xuXHRcdGhhcy5hZGQocCwgdXNlckNvbmZpZy5oYXNbcF0sIDAsIDEpO1xuXHR9XG5cblx0Ly9cblx0Ly8gZGVmaW5lIHRoZSBsb2FkZXIgZGF0YVxuXHQvL1xuXG5cdC8vIHRoZSBsb2FkZXIgd2lsbCB1c2UgdGhlc2UgbGlrZSBzeW1ib2xzIGlmIHRoZSBsb2FkZXIgaGFzIHRoZSB0cmFjZUFwaTsgb3RoZXJ3aXNlXG5cdC8vIGRlZmluZSBtYWdpYyBudW1iZXJzIHNvIHRoYXQgbW9kdWxlcyBjYW4gYmUgcHJvdmlkZWQgYXMgcGFydCBvZiBkZWZhdWx0Q29uZmlnXG5cdHZhciByZXF1ZXN0ZWQgPSAxLFxuXHRcdGFycml2ZWQgPSAyLFxuXHRcdG5vbm1vZHVsZSA9IDMsXG5cdFx0ZXhlY3V0aW5nID0gNCxcblx0XHRleGVjdXRlZCA9IDU7XG5cblx0aWYoIDAgKXtcblx0XHQvLyB0aGVzZSBtYWtlIGRlYnVnZ2luZyBuaWNlOyBidXQgdXNpbmcgc3RyaW5ncyBmb3Igc3ltYm9scyBpcyBhIGdyb3NzIHJvb2tpZSBlcnJvcjsgZG9uJ3QgZG8gaXQgZm9yIHByb2R1Y3Rpb24gY29kZVxuXHRcdHJlcXVlc3RlZCA9IFwicmVxdWVzdGVkXCI7XG5cdFx0YXJyaXZlZCA9IFwiYXJyaXZlZFwiO1xuXHRcdG5vbm1vZHVsZSA9IFwibm90LWEtbW9kdWxlXCI7XG5cdFx0ZXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcblx0XHRleGVjdXRlZCA9IFwiZXhlY3V0ZWRcIjtcblx0fVxuXG5cdHZhciBsZWdhY3lNb2RlID0gMCxcblx0XHRzeW5jID0gXCJzeW5jXCIsXG5cdFx0eGQgPSBcInhkXCIsXG5cdFx0c3luY0V4ZWNTdGFjayA9IFtdLFxuXHRcdGRvam9SZXF1aXJlUGx1Z2luID0gMCxcblx0XHRjaGVja0Rvam9SZXF1aXJlUGx1Z2luID0gbm9vcCxcblx0XHR0cmFuc2Zvcm1Ub0FtZCA9IG5vb3AsXG5cdFx0Z2V0WGhyO1xuXHRpZiggMCApe1xuXHRcdHJlcS5pc1hkVXJsID0gbm9vcDtcblxuXHRcdHJlcS5pbml0U3luY0xvYWRlciA9IGZ1bmN0aW9uKGRvam9SZXF1aXJlUGx1Z2luXywgY2hlY2tEb2pvUmVxdWlyZVBsdWdpbl8sIHRyYW5zZm9ybVRvQW1kXyl7XG5cdFx0XHQvLyB0aGUgZmlyc3QgZG9qby9fYmFzZS9sb2FkZXIgbG9hZGVkIGdldHMgdG8gZGVmaW5lIHRoZXNlIHZhcmlhYmxlczsgdGhleSBhcmUgZGVzaWduZWQgdG8gd29ya1xuXHRcdFx0Ly8gaW4gdGhlIHByZXNlbmNlIG9mIHplcm8gdG8gbWFueSBtYXBwZWQgZG9qby9fYmFzZS9sb2FkZXJzXG5cdFx0XHRpZighZG9qb1JlcXVpcmVQbHVnaW4pe1xuXHRcdFx0XHRkb2pvUmVxdWlyZVBsdWdpbiA9IGRvam9SZXF1aXJlUGx1Z2luXztcblx0XHRcdFx0Y2hlY2tEb2pvUmVxdWlyZVBsdWdpbiA9IGNoZWNrRG9qb1JlcXVpcmVQbHVnaW5fO1xuXHRcdFx0XHR0cmFuc2Zvcm1Ub0FtZCA9IHRyYW5zZm9ybVRvQW1kXztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c3luYzpzeW5jLFxuXHRcdFx0XHRyZXF1ZXN0ZWQ6cmVxdWVzdGVkLFxuXHRcdFx0XHRhcnJpdmVkOmFycml2ZWQsXG5cdFx0XHRcdG5vbm1vZHVsZTpub25tb2R1bGUsXG5cdFx0XHRcdGV4ZWN1dGluZzpleGVjdXRpbmcsXG5cdFx0XHRcdGV4ZWN1dGVkOmV4ZWN1dGVkLFxuXHRcdFx0XHRzeW5jRXhlY1N0YWNrOnN5bmNFeGVjU3RhY2ssXG5cdFx0XHRcdG1vZHVsZXM6bW9kdWxlcyxcblx0XHRcdFx0ZXhlY1E6ZXhlY1EsXG5cdFx0XHRcdGdldE1vZHVsZTpnZXRNb2R1bGUsXG5cdFx0XHRcdGluamVjdE1vZHVsZTppbmplY3RNb2R1bGUsXG5cdFx0XHRcdHNldEFycml2ZWQ6c2V0QXJyaXZlZCxcblx0XHRcdFx0c2lnbmFsOnNpZ25hbCxcblx0XHRcdFx0ZmluaXNoRXhlYzpmaW5pc2hFeGVjLFxuXHRcdFx0XHRleGVjTW9kdWxlOmV4ZWNNb2R1bGUsXG5cdFx0XHRcdGRvam9SZXF1aXJlUGx1Z2luOmRvam9SZXF1aXJlUGx1Z2luLFxuXHRcdFx0XHRnZXRMZWdhY3lNb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIGxlZ2FjeU1vZGU7fSxcblx0XHRcdFx0Z3VhcmRDaGVja0NvbXBsZXRlOmd1YXJkQ2hlY2tDb21wbGV0ZVxuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0aWYoIDAgIHx8ICAwICl7XG5cdFx0XHQvLyBpbiBsZWdhY3kgc3luYyBtb2RlLCB0aGUgbG9hZGVyIG5lZWRzIGEgbWluaW1hbCBYSFIgbGlicmFyeVxuXG5cdFx0XHR2YXIgbG9jYXRpb25Qcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sLFxuXHRcdFx0XHRsb2NhdGlvbkhvc3QgPSBsb2NhdGlvbi5ob3N0O1xuXHRcdFx0cmVxLmlzWGRVcmwgPSBmdW5jdGlvbih1cmwpe1xuXHRcdFx0XHRpZigvXlxcLi8udGVzdCh1cmwpKXtcblx0XHRcdFx0XHQvLyBiZWdpbnMgd2l0aCBhIGRvdCBpcyBhbHdheXMgcmVsYXRpdmUgdG8gcGFnZSBVUkw7IHRoZXJlZm9yZSBub3QgeGRvbWFpblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZigvXlxcL1xcLy8udGVzdCh1cmwpKXtcblx0XHRcdFx0XHQvLyBmb3IgdjEuNi0gYmFja2NvbXBhdCwgdXJsIHN0YXJ0aW5nIHdpdGggLy8gaW5kaWNhdGVzIHhkb21haW5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBnZXQgcHJvdG9jb2wgYW5kIGhvc3Rcblx0XHRcdFx0Ly8gXFwvKyB0YWtlcyBjYXJlIG9mIHRoZSB0eXBpY2FsIGZpbGUgcHJvdG9jb2wgdGhhdCBsb29rcyBsaWtlIGZpbGU6Ly8vZHJpdmUvcGF0aC90by9maWxlXG5cdFx0XHRcdC8vIGxvY2F0aW9uSG9zdCBpcyBmYWxzeSBpZiBmaWxlIHByb3RvY29sID0+IGlmIGxvY2F0aW9uUHJvdG9jb2wgbWF0Y2hlcyBhbmQgaXMgXCJmaWxlOlwiLCB8fCB3aWxsIHJldHVybiBmYWxzZVxuXHRcdFx0XHR2YXIgbWF0Y2ggPSB1cmwubWF0Y2goL14oW15cXC9cXDpdK1xcOilcXC8rKFteXFwvXSspLyk7XG5cdFx0XHRcdHJldHVybiBtYXRjaCAmJiAobWF0Y2hbMV0gIT0gbG9jYXRpb25Qcm90b2NvbCB8fCAobG9jYXRpb25Ib3N0ICYmIG1hdGNoWzJdICE9IGxvY2F0aW9uSG9zdCkpO1xuXHRcdFx0fTtcblxuXG5cdFx0XHQvLyBub3RlOiB0byBnZXQgdGhlIGZpbGU6Ly8gcHJvdG9jb2wgdG8gd29yayBpbiBGRiwgeW91IG11c3Qgc2V0IHNlY3VyaXR5LmZpbGV1cmkuc3RyaWN0X29yaWdpbl9wb2xpY3kgdG8gZmFsc2UgaW4gYWJvdXQ6Y29uZmlnXG5cdFx0XHQgMSB8fCBoYXMuYWRkKFwiZG9qby14aHItZmFjdG9yeVwiLCAxKTtcblx0XHRcdCAwICYmIGhhcy5hZGQoXCJkb2pvLWZvcmNlLWFjdGl2ZXgteGhyXCIsICAxICAmJiAhZG9jLmFkZEV2ZW50TGlzdGVuZXIgJiYgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09IFwiZmlsZTpcIik7XG5cdFx0XHRoYXMuYWRkKFwibmF0aXZlLXhoclwiLCB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT0gXCJ1bmRlZmluZWRcIik7XG5cdFx0XHRpZihoYXMoXCJuYXRpdmUteGhyXCIpICYmICEgMCApe1xuXHRcdFx0XHRnZXRYaHIgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRcdFx0fTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHQvLyBpZiBpbiB0aGUgYnJvd3NlciBhbiBvbGQgSUU7IGZpbmQgYW4geGhyXG5cdFx0XHRcdGZvcih2YXIgWE1MSFRUUF9QUk9HSURTID0gWydNc3htbDIuWE1MSFRUUCcsICdNaWNyb3NvZnQuWE1MSFRUUCcsICdNc3htbDIuWE1MSFRUUC40LjAnXSwgcHJvZ2lkLCBpID0gMDsgaSA8IDM7KXtcblx0XHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0XHRwcm9naWQgPSBYTUxIVFRQX1BST0dJRFNbaSsrXTtcblx0XHRcdFx0XHRcdGlmKG5ldyBBY3RpdmVYT2JqZWN0KHByb2dpZCkpe1xuXHRcdFx0XHRcdFx0XHQvLyB0aGlzIHByb2dpZCB3b3JrczsgdGhlcmVmb3JlLCB1c2UgaXQgZnJvbSBub3cgb25cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRcdFx0Ly8gc3F1ZWxjaDsgd2UncmUganVzdCB0cnlpbmcgdG8gZmluZCBhIGdvb2QgQWN0aXZlWCBwcm9naWRcblx0XHRcdFx0XHRcdC8vIGlmIHRoZXkgYWxsIGZhaWwsIHRoZW4gcHJvZ2lkIGVuZHMgdXAgYXMgdGhlIGxhc3QgYXR0ZW1wdCBhbmQgdGhhdCB3aWxsIHNpZ25hbCB0aGUgZXJyb3Jcblx0XHRcdFx0XHRcdC8vIHRoZSBmaXJzdCB0aW1lIHRoZSBjbGllbnQgYWN0dWFsbHkgdHJpZXMgdG8gZXhlYyBhbiB4aHJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Z2V0WGhyID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QocHJvZ2lkKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJlcS5nZXRYaHIgPSBnZXRYaHI7XG5cblx0XHRcdGhhcy5hZGQoXCJkb2pvLWdldHRleHQtYXBpXCIsIDEpO1xuXHRcdFx0cmVxLmdldFRleHQgPSBmdW5jdGlvbih1cmwsIGFzeW5jLCBvbkxvYWQpe1xuXHRcdFx0XHR2YXIgeGhyID0gZ2V0WGhyKCk7XG5cdFx0XHRcdHhoci5vcGVuKCdHRVQnLCBmaXh1cFVybCh1cmwpLCBmYWxzZSk7XG5cdFx0XHRcdHhoci5zZW5kKG51bGwpO1xuXHRcdFx0XHRpZih4aHIuc3RhdHVzID09IDIwMCB8fCAoIWxvY2F0aW9uLmhvc3QgJiYgIXhoci5zdGF0dXMpKXtcblx0XHRcdFx0XHRpZihvbkxvYWQpe1xuXHRcdFx0XHRcdFx0b25Mb2FkKHhoci5yZXNwb25zZVRleHQsIGFzeW5jKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHRocm93IG1ha2VFcnJvcihcInhockZhaWxlZFwiLCB4aHIuc3RhdHVzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcblx0XHRcdH07XG5cdFx0fVxuXHR9ZWxzZXtcblx0XHRyZXEuYXN5bmMgPSAxO1xuXHR9XG5cblx0Ly9cblx0Ly8gbG9hZGVyIGV2YWxcblx0Ly9cblx0dmFyIGV2YWxfID0gICAxICA/XG5cdFx0Ly8gbm9vcCBldmFsIGlmIHRoZXJlIGFyZSBjc3AgcmVzdHJpY3Rpb25zXG5cdFx0ZnVuY3Rpb24oKXt9IDpcblx0XHQvLyB1c2UgdGhlIGZ1bmN0aW9uIGNvbnN0cnVjdG9yIHNvIG91ciBldmFsIGlzIHNjb3BlZCBjbG9zZSB0byAoYnV0IG5vdCBpbikgaW4gdGhlIGdsb2JhbCBzcGFjZSB3aXRoIG1pbmltYWwgcG9sbHV0aW9uXG5cdFx0bmV3IEZ1bmN0aW9uKCdyZXR1cm4gZXZhbChhcmd1bWVudHNbMF0pOycpO1xuXG5cdHJlcS5ldmFsID1cblx0XHRmdW5jdGlvbih0ZXh0LCBoaW50KXtcblx0XHRcdHJldHVybiBldmFsXyh0ZXh0ICsgXCJcXHJcXG4vLyMgc291cmNlVVJMPVwiICsgaGludCk7XG5cdFx0fTtcblxuXHQvL1xuXHQvLyBsb2FkZXIgbWljcm8gZXZlbnRzIEFQSVxuXHQvL1xuXHR2YXIgbGlzdGVuZXJRdWV1ZXMgPSB7fSxcblx0XHRlcnJvciA9IFwiZXJyb3JcIixcblx0XHRzaWduYWwgPSByZXEuc2lnbmFsID0gZnVuY3Rpb24odHlwZSwgYXJncyl7XG5cdFx0XHR2YXIgcXVldWUgPSBsaXN0ZW5lclF1ZXVlc1t0eXBlXTtcblx0XHRcdC8vIG5vdGljZSB3ZSBydW4gYSBjb3B5IG9mIHRoZSBxdWV1ZTsgdGhpcyBhbGxvd3MgbGlzdGVuZXJzIHRvIGFkZC9yZW1vdmVcblx0XHRcdC8vIG90aGVyIGxpc3RlbmVycyB3aXRob3V0IGFmZmVjdGluZyB0aGlzIHBhcnRpY3VsYXIgc2lnbmFsXG5cdFx0XHRmb3JFYWNoKHF1ZXVlICYmIHF1ZXVlLnNsaWNlKDApLCBmdW5jdGlvbihsaXN0ZW5lcil7XG5cdFx0XHRcdGxpc3RlbmVyLmFwcGx5KG51bGwsIGlzQXJyYXkoYXJncykgPyBhcmdzIDogW2FyZ3NdKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0b24gPSByZXEub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcil7XG5cdFx0XHQvLyBub3RpY2UgYSBxdWV1ZSBpcyBub3QgY3JlYXRlZCB1bnRpbCBhIGNsaWVudCBhY3R1YWxseSBjb25uZWN0c1xuXHRcdFx0dmFyIHF1ZXVlID0gbGlzdGVuZXJRdWV1ZXNbdHlwZV0gfHwgKGxpc3RlbmVyUXVldWVzW3R5cGVdID0gW10pO1xuXHRcdFx0cXVldWUucHVzaChsaXN0ZW5lcik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyZW1vdmU6ZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpPHF1ZXVlLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRcdGlmKHF1ZXVlW2ldPT09bGlzdGVuZXIpe1xuXHRcdFx0XHRcdFx0XHRxdWV1ZS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblxuXHQvLyBjb25maWd1cmF0aW9uIG1hY2hpbmVyeTsgd2l0aCBhbiBvcHRpbWl6ZWQvYnVpbHQgZGVmYXVsdENvbmZpZywgYWxsIGNvbmZpZ3VyYXRpb24gbWFjaGluZXJ5IGNhbiBiZSBkaXNjYXJkZWRcblx0Ly8gbGV4aWNhbCB2YXJpYWJsZXMgaG9sZCBrZXkgbG9hZGVyIGRhdGEgc3RydWN0dXJlcyB0byBoZWxwIHdpdGggbWluaWZpY2F0aW9uOyB0aGVzZSBtYXkgYmUgY29tcGxldGVseSxcblx0Ly8gb25lLXRpbWUgaW5pdGlhbGl6ZWQgYnkgZGVmYXVsdENvbmZpZyBmb3Igb3B0aW1pemVkL2J1aWx0IHZlcnNpb25zXG5cdHZhclxuXHRcdGFsaWFzZXNcblx0XHRcdC8vIGEgdmVjdG9yIG9mIHBhaXJzIG9mIFtyZWdleHMgb3Igc3RyaW5nLCByZXBsYWNlbWVudF0gPT4gKGFsaWFzLCBhY3R1YWwpXG5cdFx0XHQ9IFtdLFxuXG5cdFx0cGF0aHNcblx0XHRcdC8vIENvbW1vbkpTIHBhdGhzXG5cdFx0XHQ9IHt9LFxuXG5cdFx0cGF0aHNNYXBQcm9nXG5cdFx0XHQvLyBsaXN0IG9mIChmcm9tLXBhdGgsIHRvLXBhdGgsIHJlZ2V4LCBsZW5ndGgpIGRlcml2ZWQgZnJvbSBwYXRocztcblx0XHRcdC8vIGEgXCJwcm9ncmFtXCIgdG8gYXBwbHkgcGF0aHM7IHNlZSBjb21wdXRlTWFwUHJvZ1xuXHRcdFx0PSBbXSxcblxuXHRcdHBhY2tzXG5cdFx0XHQvLyBhIG1hcCBmcm9tIHBhY2thZ2VJZCB0byBwYWNrYWdlIGNvbmZpZ3VyYXRpb24gb2JqZWN0OyBzZWUgZml4dXBQYWNrYWdlSW5mb1xuXHRcdFx0PSB7fSxcblxuXHRcdG1hcCA9IHJlcS5tYXBcblx0XHRcdC8vIEFNRCBtYXAgY29uZmlnIHZhcmlhYmxlOyBkb2pvL19iYXNlL2tlcm5lbCBuZWVkcyByZXEubWFwIHRvIGZpZ3VyZSBvdXQgdGhlIHNjb3BlIG1hcFxuXHRcdFx0PSB7fSxcblxuXHRcdG1hcFByb2dzXG5cdFx0XHQvLyB2ZWN0b3Igb2YgcXVhZHMgYXMgZGVzY3JpYmVkIGJ5IGNvbXB1dGVNYXBQcm9nOyBtYXAta2V5IGlzIEFNRCBtYXAga2V5LCBtYXAtdmFsdWUgaXMgQU1EIG1hcCB2YWx1ZVxuXHRcdFx0PSBbXSxcblxuXHRcdG1vZHVsZXNcblx0XHRcdC8vIEEgaGFzaDoobWlkKSAtLT4gKG1vZHVsZS1vYmplY3QpIHRoZSBtb2R1bGUgbmFtZXNwYWNlXG5cdFx0XHQvL1xuXHRcdFx0Ly8gcGlkOiB0aGUgcGFja2FnZSBpZGVudGlmaWVyIHRvIHdoaWNoIHRoZSBtb2R1bGUgYmVsb25ncyAoZS5nLiwgXCJkb2pvXCIpOyBcIlwiIGluZGljYXRlcyB0aGUgc3lzdGVtIG9yIGRlZmF1bHQgcGFja2FnZVxuXHRcdFx0Ly8gbWlkOiB0aGUgZnVsbHktcmVzb2x2ZWQgKGkuZS4sIG1hcHBpbmdzIGhhdmUgYmVlbiBhcHBsaWVkKSBtb2R1bGUgaWRlbnRpZmllciB3aXRob3V0IHRoZSBwYWNrYWdlIGlkZW50aWZpZXIgKGUuZy4sIFwiZG9qby9pby9zY3JpcHRcIilcblx0XHRcdC8vIHVybDogdGhlIFVSTCBmcm9tIHdoaWNoIHRoZSBtb2R1bGUgd2FzIHJldHJpZXZlZFxuXHRcdFx0Ly8gcGFjazogdGhlIHBhY2thZ2Ugb2JqZWN0IG9mIHRoZSBwYWNrYWdlIHRvIHdoaWNoIHRoZSBtb2R1bGUgYmVsb25nc1xuXHRcdFx0Ly8gZXhlY3V0ZWQ6IDAgPT4gbm90IGV4ZWN1dGVkOyBleGVjdXRpbmcgPT4gaW4gdGhlIHByb2Nlc3Mgb2YgdHJhdmVyc2luZyBkZXBzIGFuZCBydW5uaW5nIGZhY3Rvcnk7IGV4ZWN1dGVkID0+IGZhY3RvcnkgaGFzIGJlZW4gZXhlY3V0ZWRcblx0XHRcdC8vIGRlcHM6IHRoZSBkZXBlbmRlbmN5IHZlY3RvciBmb3IgdGhpcyBtb2R1bGUgKHZlY3RvciBvZiBtb2R1bGVzIG9iamVjdHMpXG5cdFx0XHQvLyBkZWY6IHRoZSBmYWN0b3J5IGZvciB0aGlzIG1vZHVsZVxuXHRcdFx0Ly8gcmVzdWx0OiB0aGUgcmVzdWx0IG9mIHRoZSBydW5uaW5nIHRoZSBmYWN0b3J5IGZvciB0aGlzIG1vZHVsZVxuXHRcdFx0Ly8gaW5qZWN0ZWQ6ICgwIHwgcmVxdWVzdGVkIHwgYXJyaXZlZCkgdGhlIHN0YXR1cyBvZiB0aGUgbW9kdWxlOyBub25tb2R1bGUgbWVhbnMgdGhlIHJlc291cmNlIGRpZCBub3QgY2FsbCBkZWZpbmVcblx0XHRcdC8vIGxvYWQ6IHBsdWdpbiBsb2FkIGZ1bmN0aW9uOyBhcHBsaWNhYmxlIG9ubHkgZm9yIHBsdWdpbnNcblx0XHRcdC8vXG5cdFx0XHQvLyBNb2R1bGVzIGdvIHRocm91Z2ggc2V2ZXJhbCBwaGFzZXMgaW4gY3JlYXRpb246XG5cdFx0XHQvL1xuXHRcdFx0Ly8gMS4gUmVxdWVzdGVkOiBzb21lIG90aGVyIG1vZHVsZSdzIGRlZmluaXRpb24gb3IgYSByZXF1aXJlIGFwcGxpY2F0aW9uIGNvbnRhaW5lZCB0aGUgcmVxdWVzdGVkIG1vZHVsZSBpblxuXHRcdFx0Ly9cdCAgaXRzIGRlcGVuZGVuY3kgdmVjdG9yIG9yIGV4ZWN1dGluZyBjb2RlIGV4cGxpY2l0bHkgZGVtYW5kcyBhIG1vZHVsZSB2aWEgcmVxLnJlcXVpcmUuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gMi4gSW5qZWN0ZWQ6IGEgc2NyaXB0IGVsZW1lbnQgaGFzIGJlZW4gYXBwZW5kZWQgdG8gdGhlIGluc2VydC1wb2ludCBlbGVtZW50IGRlbWFuZGluZyB0aGUgcmVzb3VyY2UgaW1wbGllZCBieSB0aGUgVVJMXG5cdFx0XHQvL1xuXHRcdFx0Ly8gMy4gTG9hZGVkOiB0aGUgcmVzb3VyY2UgaW5qZWN0ZWQgaW4gWzJdIGhhcyBiZWVuIGV2YWx1YXRlZC5cblx0XHRcdC8vXG5cdFx0XHQvLyA0LiBEZWZpbmVkOiB0aGUgcmVzb3VyY2UgY29udGFpbmVkIGEgZGVmaW5lIHN0YXRlbWVudCB0aGF0IGFkdmlzZWQgdGhlIGxvYWRlciBhYm91dCB0aGUgbW9kdWxlLiBOb3RpY2UgdGhhdCBzb21lXG5cdFx0XHQvL1x0ICByZXNvdXJjZXMgbWF5IGp1c3QgY29udGFpbiBhIGJ1bmRsZSBvZiBjb2RlIGFuZCBuZXZlciBmb3JtYWxseSBkZWZpbmUgYSBtb2R1bGUgdmlhIGRlZmluZVxuXHRcdFx0Ly9cblx0XHRcdC8vIDUuIEV2YWx1YXRlZDogdGhlIG1vZHVsZSB3YXMgZGVmaW5lZCB2aWEgZGVmaW5lIGFuZCB0aGUgbG9hZGVyIGhhcyBldmFsdWF0ZWQgdGhlIGZhY3RvcnkgYW5kIGNvbXB1dGVkIGEgcmVzdWx0LlxuXHRcdFx0PSB7fSxcblxuXHRcdGNhY2hlQnVzdFxuXHRcdFx0Ly8gcXVlcnkgc3RyaW5nIHRvIGFwcGVuZCB0byBtb2R1bGUgVVJMcyB0byBidXN0IGJyb3dzZXIgY2FjaGVcblx0XHRcdD0gXCJcIixcblxuXHRcdGNhY2hlXG5cdFx0XHQvLyBoYXNoOihtaWQgfCB1cmwpLS0+KGZ1bmN0aW9uIHwgc3RyaW5nKVxuXHRcdFx0Ly9cblx0XHRcdC8vIEEgY2FjaGUgb2YgcmVzb3VyY2VzLiBUaGUgcmVzb3VyY2VzIGFycml2ZSB2aWEgYSBjb25maWcuY2FjaGUgb2JqZWN0LCB3aGljaCBpcyBhIGhhc2ggZnJvbSBlaXRoZXIgbWlkIC0tPiBmdW5jdGlvbiBvclxuXHRcdFx0Ly8gdXJsIC0tPiBzdHJpbmcuIFRoZSB1cmwga2V5IGlzIGRpc3Rpbmd1aXNoZWQgZnJvbSB0aGUgbWlkIGtleSBieSBhbHdheXMgY29udGFpbmluZyB0aGUgcHJlZml4IFwidXJsOlwiLiB1cmwga2V5cyBhcyBwcm92aWRlZFxuXHRcdFx0Ly8gYnkgY29uZmlnLmNhY2hlIGFsd2F5cyBoYXZlIGEgc3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgY29udGVudHMgb2YgdGhlIHJlc291cmNlIGF0IHRoZSBnaXZlbiB1cmwuIG1pZCBrZXlzIGFzIHByb3ZpZGVkXG5cdFx0XHQvLyBieSBjb25maWdsLmNhY2hlIGFsd2F5cyBoYXZlIGEgZnVuY3Rpb24gdmFsdWUgdGhhdCBjYXVzZXMgdGhlIHNhbWUgY29kZSB0byBleGVjdXRlIGFzIGlmIHRoZSBtb2R1bGUgd2FzIHNjcmlwdCBpbmplY3RlZC5cblx0XHRcdC8vXG5cdFx0XHQvLyBCb3RoIGtpbmRzIG9mIGtleS12YWx1ZSBwYWlycyBhcmUgZW50ZXJlZCBpbnRvIGNhY2hlIHZpYSB0aGUgZnVuY3Rpb24gY29uc3VtZVBlbmRpbmdDYWNoZSwgd2hpY2ggbWF5IHJlbG9jYXRlIGtleXMgYXMgZ2l2ZW5cblx0XHRcdC8vIGJ5IGFueSBtYXBwaW5ncyAqaWZmKiB0aGUgY29uZmlnLmNhY2hlIHdhcyByZWNlaXZlZCBhcyBwYXJ0IG9mIGEgbW9kdWxlIHJlc291cmNlIHJlcXVlc3QuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gRnVydGhlciwgZm9yIG1pZCBrZXlzLCB0aGUgaW1wbGllZCB1cmwgaXMgY29tcHV0ZWQgYW5kIHRoZSB2YWx1ZSBpcyBlbnRlcmVkIGludG8gdGhhdCBrZXkgYXMgd2VsbC4gVGhpcyBhbGxvd3MgbWFwcGVkIG1vZHVsZXNcblx0XHRcdC8vIHRvIHJldHJpZXZlIGNhY2hlZCBpdGVtcyB0aGF0IG1heSBoYXZlIGFycml2ZWQgY29uc2VxdWVudCB0byBhbm90aGVyIG5hbWVzcGFjZS5cblx0XHRcdC8vXG5cdFx0XHQgPSB7fSxcblxuXHRcdHVybEtleVByZWZpeFxuXHRcdFx0Ly8gdGhlIHByZWZpeCB0byBwcmVwZW5kIHRvIGEgVVJMIGtleSBpbiB0aGUgY2FjaGUuXG5cdFx0XHQ9IFwidXJsOlwiLFxuXG5cdFx0cGVuZGluZ0NhY2hlSW5zZXJ0XG5cdFx0XHQvLyBoYXNoOihtaWQpLS0+KGZ1bmN0aW9uKVxuXHRcdFx0Ly9cblx0XHRcdC8vIEdpdmVzIGEgc2V0IG9mIGNhY2hlIG1vZHVsZXMgcGVuZGluZyBlbnRyeSBpbnRvIGNhY2hlLiBXaGVuIGNhY2hlZCBtb2R1bGVzIGFyZSBwdWJsaXNoZWQgdG8gdGhlIGxvYWRlciwgdGhleSBhcmVcblx0XHRcdC8vIGVudGVyZWQgaW50byBwZW5kaW5nQ2FjaGVJbnNlcnQ7IG1vZHVsZXMgYXJlIHRoZW4gcHJlc3NlZCBpbnRvIGNhY2hlIHVwb24gKDEpIEFNRCBkZWZpbmUgb3IgKDIpIHVwb24gcmVjZWl2aW5nIGFub3RoZXJcblx0XHRcdC8vIGluZGVwZW5kZW50IHNldCBvZiBjYWNoZWQgbW9kdWxlcy4gKDEpIGlzIHRoZSB1c3VhbCBjYXNlLCBhbmQgdGhpcyBjYXNlIGFsbG93cyBub3JtYWxpemluZyBtaWRzIGdpdmVuIGluIHRoZSBwZW5kaW5nXG5cdFx0XHQvLyBjYWNoZSBmb3IgdGhlIGxvY2FsIGNvbmZpZ3VyYXRpb24sIHBvc3NpYmx5IHJlbG9jYXRpbmcgbW9kdWxlcy5cblx0XHRcdCA9IHt9LFxuXG5cdFx0ZG9qb1NuaWZmQ29uZmlnXG5cdFx0XHQvLyBtYXAgb2YgY29uZmlndXJhdGlvbiB2YXJpYWJsZXNcblx0XHRcdC8vIGdpdmUgdGhlIGRhdGEtZG9qby1jb25maWcgYXMgc25pZmZlZCBmcm9tIHRoZSBkb2N1bWVudCAoaWYgYW55KVxuXHRcdFx0PSB7fSxcblxuXHRcdGluc2VydFBvaW50U2libGluZ1xuXHRcdFx0Ly8gdGhlIG5vZGVzIHVzZWQgdG8gbG9jYXRlIHdoZXJlIHNjcmlwdHMgYXJlIGluamVjdGVkIGludG8gdGhlIGRvY3VtZW50XG5cdFx0XHQ9IDA7XG5cblx0aWYoIDEgKXtcblx0XHRpZiAoISAxICkge1xuXHRcdFx0dmFyIGNvbnN1bWVQZW5kaW5nQ2FjaGVJbnNlcnQgPSBmdW5jdGlvbihyZWZlcmVuY2VNb2R1bGUsIGNsZWFyKXtcblx0XHRcdFx0XHRjbGVhciA9IGNsZWFyICE9PSBmYWxzZTtcblx0XHRcdFx0XHR2YXIgcCwgaXRlbSwgbWF0Y2gsIG5vdywgbTtcblx0XHRcdFx0XHRmb3IocCBpbiBwZW5kaW5nQ2FjaGVJbnNlcnQpe1xuXHRcdFx0XHRcdFx0aXRlbSA9IHBlbmRpbmdDYWNoZUluc2VydFtwXTtcblx0XHRcdFx0XHRcdG1hdGNoID0gcC5tYXRjaCgvXnVybFxcOiguKykvKTtcblx0XHRcdFx0XHRcdGlmKG1hdGNoKXtcblx0XHRcdFx0XHRcdFx0Y2FjaGVbdXJsS2V5UHJlZml4ICsgdG9VcmwobWF0Y2hbMV0sIHJlZmVyZW5jZU1vZHVsZSldID0gIGl0ZW07XG5cdFx0XHRcdFx0XHR9ZWxzZSBpZihwPT1cIipub3dcIil7XG5cdFx0XHRcdFx0XHRcdG5vdyA9IGl0ZW07XG5cdFx0XHRcdFx0XHR9ZWxzZSBpZihwIT1cIipub3JlZlwiKXtcblx0XHRcdFx0XHRcdFx0bSA9IGdldE1vZHVsZUluZm8ocCwgcmVmZXJlbmNlTW9kdWxlLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0Y2FjaGVbbS5taWRdID0gY2FjaGVbdXJsS2V5UHJlZml4ICsgbS51cmxdID0gaXRlbTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYobm93KXtcblx0XHRcdFx0XHRcdG5vdyhjcmVhdGVSZXF1aXJlKHJlZmVyZW5jZU1vZHVsZSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihjbGVhcil7XG5cdFx0XHRcdFx0XHRwZW5kaW5nQ2FjaGVJbnNlcnQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fVxuXHRcdHZhciBlc2NhcGVTdHJpbmcgPSBmdW5jdGlvbihzKXtcblx0XHRcdFx0cmV0dXJuIHMucmVwbGFjZSgvKFtcXC4kPyp8e31cXChcXClcXFtcXF1cXFxcXFwvXFwrXl0pL2csIGZ1bmN0aW9uKGMpeyByZXR1cm4gXCJcXFxcXCIgKyBjOyB9KTtcblx0XHRcdH0sXG5cblx0XHRcdGNvbXB1dGVNYXBQcm9nID0gZnVuY3Rpb24obWFwLCBkZXN0KXtcblx0XHRcdFx0Ly8gVGhpcyByb3V0aW5lIHRha2VzIGEgbWFwIGFzIHJlcHJlc2VudGVkIGJ5IGEgSmF2YVNjcmlwdCBvYmplY3QgYW5kIGluaXRpYWxpemVzIGRlc3QsIGEgdmVjdG9yIG9mXG5cdFx0XHRcdC8vIHF1YWRzIG9mIChtYXAta2V5LCBtYXAtdmFsdWUsIHJlZmV4LWZvci1tYXAta2V5LCBsZW5ndGgtb2YtbWFwLWtleSksIHNvcnRlZCBkZWNyZWFzaW5nIGJ5IGxlbmd0aC1cblx0XHRcdFx0Ly8gb2YtbWFwLWtleS4gVGhlIHJlZ2V4IGxvb2tzIGZvciB0aGUgbWFwLWtleSBmb2xsb3dlZCBieSBlaXRoZXIgXCIvXCIgb3IgZW5kLW9mLXN0cmluZyBhdCB0aGUgYmVnaW5uaW5nXG5cdFx0XHRcdC8vIG9mIGEgdGhlIHNlYXJjaCBzb3VyY2UuIE5vdGljZSB0aGUgbWFwLXZhbHVlIGlzIGlycmVsZXZhbnQgdG8gdGhlIGFsZ29yaXRobVxuXHRcdFx0XHRkZXN0LnNwbGljZSgwLCBkZXN0Lmxlbmd0aCk7XG5cdFx0XHRcdGZvcih2YXIgcCBpbiBtYXApe1xuXHRcdFx0XHRcdGRlc3QucHVzaChbXG5cdFx0XHRcdFx0XHRwLFxuXHRcdFx0XHRcdFx0bWFwW3BdLFxuXHRcdFx0XHRcdFx0bmV3IFJlZ0V4cChcIl5cIiArIGVzY2FwZVN0cmluZyhwKSArIFwiKFxcL3wkKVwiKSxcblx0XHRcdFx0XHRcdHAubGVuZ3RoXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVzdC5zb3J0KGZ1bmN0aW9uKGxocywgcmhzKXsgcmV0dXJuIHJoc1szXSAtIGxoc1szXTsgfSk7XG5cdFx0XHRcdHJldHVybiBkZXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Y29tcHV0ZUFsaWFzZXMgPSBmdW5jdGlvbihjb25maWcsIGRlc3Qpe1xuXHRcdFx0XHRmb3JFYWNoKGNvbmZpZywgZnVuY3Rpb24ocGFpcil7XG5cdFx0XHRcdFx0Ly8gdGFrZSBhIGZpeGVkLXVwIGNvcHkuLi5cblx0XHRcdFx0XHRkZXN0LnB1c2goW2lzU3RyaW5nKHBhaXJbMF0pID8gbmV3IFJlZ0V4cChcIl5cIiArIGVzY2FwZVN0cmluZyhwYWlyWzBdKSArIFwiJFwiKSA6IHBhaXJbMF0sIHBhaXJbMV1dKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXG5cblx0XHRcdGZpeHVwUGFja2FnZUluZm8gPSBmdW5jdGlvbihwYWNrYWdlSW5mbyl7XG5cdFx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgcHJlY2lzZSAobmFtZSwgbG9jYXRpb24sIG1haW4sIG1hcHBpbmdzKSBmb3IgYSBwYWNrYWdlXG5cdFx0XHRcdHZhciBuYW1lID0gcGFja2FnZUluZm8ubmFtZTtcblx0XHRcdFx0aWYoIW5hbWUpe1xuXHRcdFx0XHRcdC8vIHBhY2thZ2VJbmZvIG11c3QgYmUgYSBzdHJpbmcgdGhhdCBnaXZlcyB0aGUgbmFtZVxuXHRcdFx0XHRcdG5hbWUgPSBwYWNrYWdlSW5mbztcblx0XHRcdFx0XHRwYWNrYWdlSW5mbyA9IHtuYW1lOm5hbWV9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhY2thZ2VJbmZvID0gbWl4KHttYWluOlwibWFpblwifSwgcGFja2FnZUluZm8pO1xuXHRcdFx0XHRwYWNrYWdlSW5mby5sb2NhdGlvbiA9IHBhY2thZ2VJbmZvLmxvY2F0aW9uID8gcGFja2FnZUluZm8ubG9jYXRpb24gOiBuYW1lO1xuXG5cdFx0XHRcdC8vIHBhY2thZ2VNYXAgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBBTUQgbWFwXG5cdFx0XHRcdGlmKHBhY2thZ2VJbmZvLnBhY2thZ2VNYXApe1xuXHRcdFx0XHRcdG1hcFtuYW1lXSA9IHBhY2thZ2VJbmZvLnBhY2thZ2VNYXA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZighcGFja2FnZUluZm8ubWFpbi5pbmRleE9mKFwiLi9cIikpe1xuXHRcdFx0XHRcdHBhY2thZ2VJbmZvLm1haW4gPSBwYWNrYWdlSW5mby5tYWluLnN1YnN0cmluZygyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG5vdyB0aGF0IHdlJ3ZlIGdvdCBhIGZ1bGx5LXJlc29sdmVkIHBhY2thZ2Ugb2JqZWN0LCBwdXNoIGl0IGludG8gdGhlIGNvbmZpZ3VyYXRpb25cblx0XHRcdFx0cGFja3NbbmFtZV0gPSBwYWNrYWdlSW5mbztcblx0XHRcdH0sXG5cblx0XHRcdGRlbGF5ZWRNb2R1bGVDb25maWdcblx0XHRcdFx0Ly8gbW9kdWxlIGNvbmZpZyBjYW5ub3QgYmUgY29uc3VtZWQgdW50aWwgdGhlIGxvYWRlciBpcyBjb21wbGV0ZWx5IGluaXRpYWxpemVkOyB0aGVyZWZvcmUsIGFsbFxuXHRcdFx0XHQvLyBtb2R1bGUgY29uZmlnIGRldGVjdGVkIGR1cmluZyBib290aW5nIGlzIG1lbW9yaXplZCBhbmQgYXBwbGllZCBhdCB0aGUgZW5kIG9mIGxvYWRlciBpbml0aWFsaXphdGlvblxuXHRcdFx0XHQvLyBUT0RPOiB0aGlzIGlzIGEgYml0IG9mIGEga2x1ZGdlOyBhbGwgY29uZmlnIHNob3VsZCBiZSBtb3ZlZCB0byBlbmQgb2YgbG9hZGVyIGluaXRpYWxpemF0aW9uLCBidXRcblx0XHRcdFx0Ly8gd2UnbGwgZGVsYXkgdGhpcyBjaG9yZSBhbmQgZG8gaXQgd2l0aCBhIGZpbmFsIGxvYWRlciAxLnggY2xlYW51cCBhZnRlciB0aGUgMi54IGxvYWRlciBwcm90b3R5cGluZyBpcyBjb21wbGV0ZVxuXHRcdFx0XHQ9IFtdLFxuXG5cblx0XHRcdGNvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZywgYm9vdGluZywgcmVmZXJlbmNlTW9kdWxlKXtcblx0XHRcdFx0Zm9yKHZhciBwIGluIGNvbmZpZyl7XG5cdFx0XHRcdFx0aWYocD09XCJ3YWl0U2Vjb25kc1wiKXtcblx0XHRcdFx0XHRcdHJlcS53YWl0bXMgPSAoY29uZmlnW3BdIHx8IDApICogMTAwMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocD09XCJjYWNoZUJ1c3RcIil7XG5cdFx0XHRcdFx0XHRjYWNoZUJ1c3QgPSBjb25maWdbcF0gPyAoaXNTdHJpbmcoY29uZmlnW3BdKSA/IGNvbmZpZ1twXSA6IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKyBcIlwiKSA6IFwiXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHA9PVwiYmFzZVVybFwiIHx8IHA9PVwiY29tYm9cIil7XG5cdFx0XHRcdFx0XHRyZXFbcF0gPSBjb25maWdbcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCAwICAmJiBwPT1cImFzeW5jXCIpe1xuXHRcdFx0XHRcdFx0Ly8gZmFsc3kgb3IgXCJzeW5jXCIgPT4gbGVnYWN5IHN5bmMgbG9hZGVyXG5cdFx0XHRcdFx0XHQvLyBcInhkXCIgPT4gc3luYyBidXQgbG9hZGluZyB4ZG9tYWluIHRyZWUgYW5kIHRoZXJlZm9yZSBsb2FkaW5nIGFzeW5jaHJvbm91c2x5IChub3QgY29uZmlndXJhYmxlLCBzZXQgYXV0b21hdGljYWxseSBieSB0aGUgbG9hZGVyKVxuXHRcdFx0XHRcdFx0Ly8gXCJsZWdhY3lBc3luY1wiID0+IHBlcm1hbmVudGx5IGluIFwieGRcIiBieSBjaG9pY2Vcblx0XHRcdFx0XHRcdC8vIFwiZGVidWdBdEFsbENvc3RzXCIgPT4gdHJ5aW5nIHRvIGxvYWQgZXZlcnl0aGluZyB2aWEgc2NyaXB0IGluamVjdGlvbiAobm90IGltcGxlbWVudGVkKVxuXHRcdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlLCBtdXN0IGJlIHRydXRoeSA9PiBBTURcblx0XHRcdFx0XHRcdC8vIGxlZ2FjeU1vZGU6IHN5bmMgfCBsZWdhY3lBc3luYyB8IHhkIHwgZmFsc2Vcblx0XHRcdFx0XHRcdHZhciBtb2RlID0gY29uZmlnW3BdO1xuXHRcdFx0XHRcdFx0cmVxLmxlZ2FjeU1vZGUgPSBsZWdhY3lNb2RlID0gKGlzU3RyaW5nKG1vZGUpICYmIC9zeW5jfGxlZ2FjeUFzeW5jLy50ZXN0KG1vZGUpID8gbW9kZSA6ICghbW9kZSA/IHN5bmMgOiBmYWxzZSkpO1xuXHRcdFx0XHRcdFx0cmVxLmFzeW5jID0gIWxlZ2FjeU1vZGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGNvbmZpZ1twXSE9PWhhc0NhY2hlKXtcblx0XHRcdFx0XHRcdC8vIGFjY3VtdWxhdGUgcmF3IGNvbmZpZyBpbmZvIGZvciBjbGllbnQgYXBwcyB3aGljaCBjYW4gdXNlIHRoaXMgdG8gcGFzcyB0aGVpciBvd24gY29uZmlnXG5cdFx0XHRcdFx0XHRyZXEucmF3Q29uZmlnW3BdID0gY29uZmlnW3BdO1xuXHRcdFx0XHRcdFx0cCE9XCJoYXNcIiAmJiBoYXMuYWRkKFwiY29uZmlnLVwiK3AsIGNvbmZpZ1twXSwgMCwgYm9vdGluZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbWFrZSBzdXJlIGJhc2VVcmwgZXhpc3RzXG5cdFx0XHRcdGlmKCFyZXEuYmFzZVVybCl7XG5cdFx0XHRcdFx0cmVxLmJhc2VVcmwgPSBcIi4vXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbWFrZSBzdXJlIGJhc2VVcmwgZW5kcyB3aXRoIGEgc2xhc2hcblx0XHRcdFx0aWYoIS9cXC8kLy50ZXN0KHJlcS5iYXNlVXJsKSl7XG5cdFx0XHRcdFx0cmVxLmJhc2VVcmwgKz0gXCIvXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBub3cgZG8gdGhlIHNwZWNpYWwgd29yayBmb3IgaGFzLCBwYWNrYWdlcywgcGFja2FnZVBhdGhzLCBwYXRocywgYWxpYXNlcywgYW5kIGNhY2hlXG5cblx0XHRcdFx0Zm9yKHAgaW4gY29uZmlnLmhhcyl7XG5cdFx0XHRcdFx0aGFzLmFkZChwLCBjb25maWcuaGFzW3BdLCAwLCBib290aW5nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGZvciBlYWNoIHBhY2thZ2UgZm91bmQgaW4gYW55IHBhY2thZ2VzIGNvbmZpZyBpdGVtLCBhdWdtZW50IHRoZSBwYWNrcyBtYXAgb3duZWQgYnkgdGhlIGxvYWRlclxuXHRcdFx0XHRmb3JFYWNoKGNvbmZpZy5wYWNrYWdlcywgZml4dXBQYWNrYWdlSW5mbyk7XG5cblx0XHRcdFx0Ly8gZm9yIGVhY2ggcGFja2FnZVBhdGggZm91bmQgaW4gYW55IHBhY2thZ2VQYXRocyBjb25maWcgaXRlbSwgYXVnbWVudCB0aGUgcGFja2FnZUNvbmZpZ1xuXHRcdFx0XHQvLyBwYWNrYWdlUGF0aHMgaXMgZGVwcmVjYXRlZDsgcmVtb3ZlIGluIDIuMFxuXHRcdFx0XHRmb3IodmFyIGJhc2VVcmwgaW4gY29uZmlnLnBhY2thZ2VQYXRocyl7XG5cdFx0XHRcdFx0Zm9yRWFjaChjb25maWcucGFja2FnZVBhdGhzW2Jhc2VVcmxdLCBmdW5jdGlvbihwYWNrYWdlSW5mbyl7XG5cdFx0XHRcdFx0XHR2YXIgbG9jYXRpb24gPSBiYXNlVXJsICsgXCIvXCIgKyBwYWNrYWdlSW5mbztcblx0XHRcdFx0XHRcdGlmKGlzU3RyaW5nKHBhY2thZ2VJbmZvKSl7XG5cdFx0XHRcdFx0XHRcdHBhY2thZ2VJbmZvID0ge25hbWU6cGFja2FnZUluZm99O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFja2FnZUluZm8ubG9jYXRpb24gPSBsb2NhdGlvbjtcblx0XHRcdFx0XHRcdGZpeHVwUGFja2FnZUluZm8ocGFja2FnZUluZm8pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbm90aWNlIHRoYXQgY29tcHV0ZU1hcFByb2cgdHJlYXRzIHRoZSBkZXN0IGFzIGEgcmVmZXJlbmNlOyB0aGVyZWZvcmUsIGlmL3doZW4gdGhhdCB2YXJpYWJsZVxuXHRcdFx0XHQvLyBpcyBwdWJsaXNoZWQgKHNlZSBkb2pvLXB1Ymxpc2gtcHJpdmF0ZXMpLCB0aGUgcHVibGlzaGVkIHZhcmlhYmxlIHdpbGwgYWx3YXlzIGhvbGQgYSB2YWxpZCB2YWx1ZS5cblxuXHRcdFx0XHQvLyB0aGlzIG11c3QgY29tZSBhZnRlciBhbGwgcGFja2FnZSBwcm9jZXNzaW5nIHNpbmNlIHBhY2thZ2UgcHJvY2Vzc2luZyBtYXkgbXV0YXRlIG1hcFxuXHRcdFx0XHRjb21wdXRlTWFwUHJvZyhtaXgobWFwLCBjb25maWcubWFwKSwgbWFwUHJvZ3MpO1xuXHRcdFx0XHRmb3JFYWNoKG1hcFByb2dzLCBmdW5jdGlvbihpdGVtKXtcblx0XHRcdFx0XHRpdGVtWzFdID0gY29tcHV0ZU1hcFByb2coaXRlbVsxXSwgW10pO1xuXHRcdFx0XHRcdGlmKGl0ZW1bMF09PVwiKlwiKXtcblx0XHRcdFx0XHRcdG1hcFByb2dzLnN0YXIgPSBpdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gcHVzaCBpbiBhbnkgcGF0aHMgYW5kIHJlY29tcHV0ZSB0aGUgaW50ZXJuYWwgcGF0aG1hcFxuXHRcdFx0XHRjb21wdXRlTWFwUHJvZyhtaXgocGF0aHMsIGNvbmZpZy5wYXRocyksIHBhdGhzTWFwUHJvZyk7XG5cblx0XHRcdFx0Ly8gYWxpYXNlc1xuXHRcdFx0XHRjb21wdXRlQWxpYXNlcyhjb25maWcuYWxpYXNlcywgYWxpYXNlcyk7XG5cblx0XHRcdFx0aWYgKCEgMSApIHtcblx0XHRcdFx0XHRpZihib290aW5nKXtcblx0XHRcdFx0XHRcdGRlbGF5ZWRNb2R1bGVDb25maWcucHVzaCh7Y29uZmlnOmNvbmZpZy5jb25maWd9KTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdGZvcihwIGluIGNvbmZpZy5jb25maWcpe1xuXHRcdFx0XHRcdFx0XHR2YXIgbW9kdWxlID0gZ2V0TW9kdWxlKHAsIHJlZmVyZW5jZU1vZHVsZSk7XG5cdFx0XHRcdFx0XHRcdG1vZHVsZS5jb25maWcgPSBtaXgobW9kdWxlLmNvbmZpZyB8fCB7fSwgY29uZmlnLmNvbmZpZ1twXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gcHVzaCBpbiBhbnkgbmV3IGNhY2hlIHZhbHVlc1xuXHRcdFx0XHRcdGlmKGNvbmZpZy5jYWNoZSl7XG5cdFx0XHRcdFx0XHRjb25zdW1lUGVuZGluZ0NhY2hlSW5zZXJ0KCk7XG5cdFx0XHRcdFx0XHRwZW5kaW5nQ2FjaGVJbnNlcnQgPSBjb25maWcuY2FjaGU7XG5cdFx0XHRcdFx0XHQvL2luamVjdCBub3cgYWxsIGRlcGVuY2llcyBzbyBjYWNoZSBpcyBhdmFpbGFibGUgZm9yIG1hcHBlZCBtb2R1bGVcblx0XHRcdFx0XHRcdGNvbnN1bWVQZW5kaW5nQ2FjaGVJbnNlcnQoMCwgISFjb25maWcuY2FjaGVbXCIqbm9yZWZcIl0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzaWduYWwoXCJjb25maWdcIiwgW2NvbmZpZywgcmVxLnJhd0NvbmZpZ10pO1xuXHRcdFx0fTtcblxuXHRcdC8vXG5cdFx0Ly8gZXhlY3V0ZSB0aGUgdmFyaW91cyBzbmlmZnM7IHVzZXJDb25maWcgY2FuIG92ZXJyaWRlIGFuZCB2YWx1ZVxuXHRcdC8vXG5cblx0XHRpZiggMCAgfHwgIDAgKXtcblx0XHRcdC8vIHRoZSBzbmlmZiByZWdleCBsb29rcyBmb3IgYSBzcmMgYXR0cmlidXRlIGVuZGluZyBpbiBkb2pvLmpzLCBvcHRpb25hbGx5IHByZWNlZGVkIHdpdGggYSBwYXRoLlxuXHRcdFx0Ly8gbWF0Y2hbM10gcmV0dXJucyB0aGUgcGF0aCB0byBkb2pvLmpzIChpZiBhbnkpIHdpdGhvdXQgdGhlIHRyYWlsaW5nIHNsYXNoLiBUaGlzIGlzIHVzZWQgZm9yIHRoZVxuXHRcdFx0Ly8gZG9qbyBsb2NhdGlvbiBvbiBDRE4gZGVwbG95bWVudHMgYW5kIGJhc2VVcmwgd2hlbiBlaXRoZXIvYm90aCBvZiB0aGVzZSBhcmUgbm90IHByb3ZpZGVkXG5cdFx0XHQvLyBleHBsaWNpdGx5IGluIHRoZSBjb25maWcgZGF0YTsgdGhpcyBpcyB0aGUgMS42LSBiZWhhdmlvci5cblxuXHRcdFx0dmFyIHNjcmlwdHMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIiksXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRzY3JpcHQsIGRvam9EaXIsIHNyYywgbWF0Y2g7XG5cdFx0XHR3aGlsZShpIDwgc2NyaXB0cy5sZW5ndGgpe1xuXHRcdFx0XHRzY3JpcHQgPSBzY3JpcHRzW2krK107XG5cdFx0XHRcdGlmKChzcmMgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKFwic3JjXCIpKSAmJiAobWF0Y2ggPSBzcmMubWF0Y2goLygoKC4qKVxcLyl8Xilkb2pvXFwuanMoXFxXfCQpL2kpKSl7XG5cdFx0XHRcdFx0Ly8gc25pZmYgZG9qb0RpciBhbmQgYmFzZVVybFxuXHRcdFx0XHRcdGRvam9EaXIgPSBtYXRjaFszXSB8fCBcIlwiO1xuXHRcdFx0XHRcdGRlZmF1bHRDb25maWcuYmFzZVVybCA9IGRlZmF1bHRDb25maWcuYmFzZVVybCB8fCBkb2pvRGlyO1xuXG5cdFx0XHRcdFx0Ly8gcmVtZW1iZXIgYW4gaW5zZXJ0UG9pbnRTaWJsaW5nXG5cdFx0XHRcdFx0aW5zZXJ0UG9pbnRTaWJsaW5nID0gc2NyaXB0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc25pZmYgY29uZmlndXJhdGlvbiBvbiBhdHRyaWJ1dGUgaW4gc2NyaXB0IGVsZW1lbnRcblx0XHRcdFx0aWYoKHNyYyA9IChzY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1kb2pvLWNvbmZpZ1wiKSB8fCBzY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGpDb25maWdcIikpKSl7XG5cdFx0XHRcdFx0ZG9qb1NuaWZmQ29uZmlnID0gcmVxLmV2YWwoXCIoeyBcIiArIHNyYyArIFwiIH0pXCIsIFwiZGF0YS1kb2pvLWNvbmZpZ1wiKTtcblxuXHRcdFx0XHRcdC8vIHJlbWVtYmVyIGFuIGluc2VydFBvaW50U2libGluZ1xuXHRcdFx0XHRcdGluc2VydFBvaW50U2libGluZyA9IHNjcmlwdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNuaWZmIHJlcXVpcmVqcyBhdHRyaWJ1dGVcblx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHRpZigoc3JjID0gc2NyaXB0LmdldEF0dHJpYnV0ZShcImRhdGEtbWFpblwiKSkpe1xuXHRcdFx0XHRcdFx0ZG9qb1NuaWZmQ29uZmlnLmRlcHMgPSBkb2pvU25pZmZDb25maWcuZGVwcyB8fCBbc3JjXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiggMCApe1xuXHRcdFx0Ly8gcGFzcyBkb3duIGRvaC50ZXN0Q29uZmlnIGZyb20gcGFyZW50IGFzIGlmIGl0IHdlcmUgYSBkYXRhLWRvam8tY29uZmlnXG5cdFx0XHR0cnl7XG5cdFx0XHRcdGlmKHdpbmRvdy5wYXJlbnQgIT0gd2luZG93ICYmIHdpbmRvdy5wYXJlbnQucmVxdWlyZSl7XG5cdFx0XHRcdFx0dmFyIGRvaCA9IHdpbmRvdy5wYXJlbnQucmVxdWlyZShcImRvaFwiKTtcblx0XHRcdFx0XHRkb2ggJiYgbWl4KGRvam9TbmlmZkNvbmZpZywgZG9oLnRlc3RDb25maWcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9Y2F0Y2goZSl7fVxuXHRcdH1cblxuXHRcdC8vIGNvbmZpZ3VyZSB0aGUgbG9hZGVyOyBsZXQgdGhlIHVzZXIgb3ZlcnJpZGUgZGVmYXVsdHNcblx0XHRyZXEucmF3Q29uZmlnID0ge307XG5cdFx0Y29uZmlnKGRlZmF1bHRDb25maWcsIDEpO1xuXG5cdFx0Ly8gZG8gdGhpcyBiZWZvcmUgc2V0dGluZyB1c2VyQ29uZmlnL3NuaWZmQ29uZmlnIHRvIGFsbG93IHVzZXJDb25maWcvc25pZmYgb3ZlcnJpZGVzXG5cdFx0aWYoIDAgKXtcblx0XHRcdHBhY2tzLmRvam8ubG9jYXRpb24gPSBkb2pvRGlyO1xuXHRcdFx0aWYoZG9qb0Rpcil7XG5cdFx0XHRcdGRvam9EaXIgKz0gXCIvXCI7XG5cdFx0XHR9XG5cdFx0XHRwYWNrcy5kaWppdC5sb2NhdGlvbiA9IGRvam9EaXIgKyBcIi4uL2Rpaml0L1wiO1xuXHRcdFx0cGFja3MuZG9qb3gubG9jYXRpb24gPSBkb2pvRGlyICsgXCIuLi9kb2pveC9cIjtcblx0XHR9XG5cblx0XHRjb25maWcodXNlckNvbmZpZywgMSk7XG5cdFx0Y29uZmlnKGRvam9TbmlmZkNvbmZpZywgMSk7XG5cblx0fWVsc2V7XG5cdFx0Ly8gbm8gY29uZmlnIEFQSSwgYXNzdW1lIGRlZmF1bHRDb25maWcgaGFzIGV2ZXJ5dGhpbmcgdGhlIGxvYWRlciBuZWVkcy4uLmZvciB0aGUgZW50aXJlIGxpZmV0aW1lIG9mIHRoZSBhcHBsaWNhdGlvblxuXHRcdHBhdGhzID0gZGVmYXVsdENvbmZpZy5wYXRocztcblx0XHRwYXRoc01hcFByb2cgPSBkZWZhdWx0Q29uZmlnLnBhdGhzTWFwUHJvZztcblx0XHRwYWNrcyA9IGRlZmF1bHRDb25maWcucGFja3M7XG5cdFx0YWxpYXNlcyA9IGRlZmF1bHRDb25maWcuYWxpYXNlcztcblx0XHRtYXBQcm9ncyA9IGRlZmF1bHRDb25maWcubWFwUHJvZ3M7XG5cdFx0bW9kdWxlcyA9IGRlZmF1bHRDb25maWcubW9kdWxlcztcblx0XHRjYWNoZSA9IGRlZmF1bHRDb25maWcuY2FjaGU7XG5cdFx0Y2FjaGVCdXN0ID0gZGVmYXVsdENvbmZpZy5jYWNoZUJ1c3Q7XG5cblx0XHQvLyByZW1lbWJlciB0aGUgZGVmYXVsdCBjb25maWcgZm9yIG90aGVyIHByb2Nlc3NlcyAoZS5nLiwgZG9qby9jb25maWcpXG5cdFx0cmVxLnJhd0NvbmZpZyA9IGRlZmF1bHRDb25maWc7XG5cdH1cblxuXG5cdGlmICghIDEgKSB7XG5cdFx0aWYoIDAgKXtcblx0XHRcdHJlcS5jb21ibyA9IHJlcS5jb21ibyB8fCB7YWRkOm5vb3B9O1xuXHRcdFx0dmFyIGNvbWJvUGVuZGluZyA9IDAsXG5cdFx0XHRcdGNvbWJvc1BlbmRpbmcgPSBbXSxcblx0XHRcdFx0Y29tYm9QZW5kaW5nVGltZXIgPSBudWxsO1xuXHRcdH1cblx0XHRcblxuXHRcdC8vIGJ1aWxkIHRoZSBsb2FkZXIgbWFjaGluZXJ5IGlhdyBjb25maWd1cmF0aW9uLCBpbmNsdWRpbmcgaGFzIGZlYXR1cmUgdGVzdHNcblx0XHR2YXIgaW5qZWN0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24obW9kdWxlKXtcblx0XHRcdFx0Ly8gY2hlY2tDb21wbGV0ZSE9MCBob2xkcyB0aGUgaWRsZSBzaWduYWw7IHdlJ3JlIG5vdCBpZGxlIGlmIHdlJ3JlIGluamVjdGluZyBkZXBlbmRlbmNpZXNcblx0XHRcdFx0Z3VhcmRDaGVja0NvbXBsZXRlKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0Zm9yRWFjaChtb2R1bGUuZGVwcywgaW5qZWN0TW9kdWxlKTtcblx0XHRcdFx0XHRpZiggMCAgJiYgY29tYm9QZW5kaW5nICYmICFjb21ib1BlbmRpbmdUaW1lcil7XG5cdFx0XHRcdFx0XHRjb21ib1BlbmRpbmdUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGNvbWJvUGVuZGluZyA9IDA7XG5cdFx0XHRcdFx0XHRcdGNvbWJvUGVuZGluZ1RpbWVyID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0cmVxLmNvbWJvLmRvbmUoZnVuY3Rpb24obWlkcywgdXJsKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG9uTG9hZENhbGxiYWNrPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZGVmUSBpcyBhIHZlY3RvciBvZiBtb2R1bGUgZGVmaW5pdGlvbnMgMS10by0xLCBvbnRvIG1pZHNcblx0XHRcdFx0XHRcdFx0XHRcdHJ1bkRlZlEoMCwgbWlkcyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRjb21ib3NQZW5kaW5nLnB1c2gobWlkcyk7XG5cdFx0XHRcdFx0XHRcdFx0aW5qZWN0aW5nTW9kdWxlID0gbWlkcztcblx0XHRcdFx0XHRcdFx0XHRyZXEuaW5qZWN0VXJsKHVybCwgb25Mb2FkQ2FsbGJhY2ssIG1pZHMpO1xuXHRcdFx0XHRcdFx0XHRcdGluamVjdGluZ01vZHVsZSA9IDA7XG5cdFx0XHRcdFx0XHRcdH0sIHJlcSk7XG5cdFx0XHRcdFx0XHR9LCAwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblxuXHRcdFx0Y29udGV4dFJlcXVpcmUgPSBmdW5jdGlvbihhMSwgYTIsIGEzLCByZWZlcmVuY2VNb2R1bGUsIGNvbnRleHRSZXF1aXJlKXtcblx0XHRcdFx0dmFyIG1vZHVsZSwgc3ludGhldGljTWlkO1xuXHRcdFx0XHRpZihpc1N0cmluZyhhMSkpe1xuXHRcdFx0XHRcdC8vIHNpZ25hdHVyZSBpcyAobW9kdWxlSWQpXG5cdFx0XHRcdFx0bW9kdWxlID0gZ2V0TW9kdWxlKGExLCByZWZlcmVuY2VNb2R1bGUsIHRydWUpO1xuXHRcdFx0XHRcdGlmKG1vZHVsZSAmJiBtb2R1bGUuZXhlY3V0ZWQpe1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1vZHVsZS5yZXN1bHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRocm93IG1ha2VFcnJvcihcInVuZGVmaW5lZE1vZHVsZVwiLCBhMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWlzQXJyYXkoYTEpKXtcblx0XHRcdFx0XHQvLyBhMSBpcyBhIGNvbmZpZ3VyYXRpb25cblx0XHRcdFx0XHRjb25maWcoYTEsIDAsIHJlZmVyZW5jZU1vZHVsZSk7XG5cblx0XHRcdFx0XHQvLyBqdWdnbGUgYXJnczsgKGEyLCBhMykgbWF5IGJlIChkZXBlbmRlbmNpZXMsIGNhbGxiYWNrKVxuXHRcdFx0XHRcdGExID0gYTI7XG5cdFx0XHRcdFx0YTIgPSBhMztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihpc0FycmF5KGExKSl7XG5cdFx0XHRcdFx0Ly8gc2lnbmF0dXJlIGlzIChyZXF1ZXN0TGlzdCBbLGNhbGxiYWNrXSlcblx0XHRcdFx0XHRpZighYTEubGVuZ3RoKXtcblx0XHRcdFx0XHRcdGEyICYmIGEyKCk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRzeW50aGV0aWNNaWQgPSBcInJlcXVpcmUqXCIgKyB1aWQoKTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVzb2x2ZSB0aGUgcmVxdWVzdCBsaXN0IHdpdGggcmVzcGVjdCB0byB0aGUgcmVmZXJlbmNlIG1vZHVsZVxuXHRcdFx0XHRcdFx0Zm9yKHZhciBtaWQsIGRlcHMgPSBbXSwgaSA9IDA7IGkgPCBhMS5sZW5ndGg7KXtcblx0XHRcdFx0XHRcdFx0bWlkID0gYTFbaSsrXTtcblx0XHRcdFx0XHRcdFx0ZGVwcy5wdXNoKGdldE1vZHVsZShtaWQsIHJlZmVyZW5jZU1vZHVsZSkpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBjb25zdHJ1Y3QgYSBzeW50aGV0aWMgbW9kdWxlIHRvIGNvbnRyb2wgZXhlY3V0aW9uIG9mIHRoZSByZXF1ZXN0TGlzdCwgYW5kLCBvcHRpb25hbGx5LCBjYWxsYmFja1xuXHRcdFx0XHRcdFx0bW9kdWxlID0gbWl4KG1ha2VNb2R1bGVJbmZvKFwiXCIsIHN5bnRoZXRpY01pZCwgMCwgXCJcIiksIHtcblx0XHRcdFx0XHRcdFx0aW5qZWN0ZWQ6IGFycml2ZWQsXG5cdFx0XHRcdFx0XHRcdGRlcHM6IGRlcHMsXG5cdFx0XHRcdFx0XHRcdGRlZjogYTIgfHwgbm9vcCxcblx0XHRcdFx0XHRcdFx0cmVxdWlyZTogcmVmZXJlbmNlTW9kdWxlID8gcmVmZXJlbmNlTW9kdWxlLnJlcXVpcmUgOiByZXEsXG5cdFx0XHRcdFx0XHRcdGdjOiAxIC8vZ2FyYmFnZSBjb2xsZWN0XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdG1vZHVsZXNbbW9kdWxlLm1pZF0gPSBtb2R1bGU7XG5cblx0XHRcdFx0XHRcdC8vIGNoZWNrQ29tcGxldGUhPTAgaG9sZHMgdGhlIGlkbGUgc2lnbmFsOyB3ZSdyZSBub3QgaWRsZSBpZiB3ZSdyZSBpbmplY3RpbmcgZGVwZW5kZW5jaWVzXG5cdFx0XHRcdFx0XHRpbmplY3REZXBlbmRlbmNpZXMobW9kdWxlKTtcblxuXHRcdFx0XHRcdFx0Ly8gdHJ5IHRvIGltbWVkaWF0ZWx5IGV4ZWN1dGVcblx0XHRcdFx0XHRcdC8vIGlmIGFscmVhZHkgdHJhdmVyc2luZyBhIGZhY3RvcnkgdHJlZSwgdGhlbiBzdHJpY3QgY2F1c2VzIGNpcmN1bGFyIGRlcGVuZGVuY3kgdG8gYWJvcnQgdGhlIGV4ZWN1dGlvbjsgbWF5YmVcblx0XHRcdFx0XHRcdC8vIGl0J3MgcG9zc2libGUgdG8gZXhlY3V0ZSB0aGlzIHJlcXVpcmUgbGF0ZXIgYWZ0ZXIgdGhlIGN1cnJlbnQgdHJhdmVyc2FsIGNvbXBsZXRlcyBhbmQgYXZvaWQgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG5cdFx0XHRcdFx0XHQvLyAuLi5idXQgKmFsd2F5cyogaW5zaXN0IG9uIGltbWVkaWF0ZSBpbiBzeW5jaCBtb2RlXG5cdFx0XHRcdFx0XHR2YXIgc3RyaWN0ID0gY2hlY2tDb21wbGV0ZUd1YXJkICYmIGxlZ2FjeU1vZGUhPXN5bmM7XG5cdFx0XHRcdFx0XHRndWFyZENoZWNrQ29tcGxldGUoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0ZXhlY01vZHVsZShtb2R1bGUsIHN0cmljdCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGlmKCFtb2R1bGUuZXhlY3V0ZWQpe1xuXHRcdFx0XHRcdFx0XHQvLyBzb21lIGRlcHMgd2VyZW4ndCBvbiBib2FyZCBvciBjaXJjdWxhciBkZXBlbmRlbmN5IGRldGVjdGVkIGFuZCBzdHJpY3Q7IHRoZXJlZm9yZSwgcHVzaCBpbnRvIHRoZSBleGVjUVxuXHRcdFx0XHRcdFx0XHRleGVjUS5wdXNoKG1vZHVsZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb250ZXh0UmVxdWlyZTtcblx0XHRcdH0sXG5cblx0XHRcdGNyZWF0ZVJlcXVpcmUgPSBmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFx0XHRpZighbW9kdWxlKXtcblx0XHRcdFx0XHRyZXR1cm4gcmVxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciByZXN1bHQgPSBtb2R1bGUucmVxdWlyZTtcblx0XHRcdFx0aWYoIXJlc3VsdCl7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZnVuY3Rpb24oYTEsIGEyLCBhMyl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY29udGV4dFJlcXVpcmUoYTEsIGEyLCBhMywgbW9kdWxlLCByZXN1bHQpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0bW9kdWxlLnJlcXVpcmUgPSBtaXgocmVzdWx0LCByZXEpO1xuXHRcdFx0XHRcdHJlc3VsdC5tb2R1bGUgPSBtb2R1bGU7XG5cdFx0XHRcdFx0cmVzdWx0LnRvVXJsID0gZnVuY3Rpb24obmFtZSl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdG9VcmwobmFtZSwgbW9kdWxlKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJlc3VsdC50b0Fic01pZCA9IGZ1bmN0aW9uKG1pZCl7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdG9BYnNNaWQobWlkLCBtb2R1bGUpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHRcdHJlc3VsdC51bmRlZiA9IGZ1bmN0aW9uKG1pZCl7XG5cdFx0XHRcdFx0XHRcdHJlcS51bmRlZihtaWQsIG1vZHVsZSk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiggMCApe1xuXHRcdFx0XHRcdFx0cmVzdWx0LnN5bmNMb2FkTmxzID0gZnVuY3Rpb24obWlkKXtcblx0XHRcdFx0XHRcdFx0dmFyIG5sc01vZHVsZUluZm8gPSBnZXRNb2R1bGVJbmZvKG1pZCwgbW9kdWxlKSxcblx0XHRcdFx0XHRcdFx0XHRubHNNb2R1bGUgPSBtb2R1bGVzW25sc01vZHVsZUluZm8ubWlkXTtcblx0XHRcdFx0XHRcdFx0aWYoIW5sc01vZHVsZSB8fCAhbmxzTW9kdWxlLmV4ZWN1dGVkKXtcblx0XHRcdFx0XHRcdFx0XHRjYWNoZWQgPSBjYWNoZVtubHNNb2R1bGVJbmZvLm1pZF0gfHwgY2FjaGVbdXJsS2V5UHJlZml4ICsgbmxzTW9kdWxlSW5mby51cmxdO1xuXHRcdFx0XHRcdFx0XHRcdGlmKGNhY2hlZCl7XG5cdFx0XHRcdFx0XHRcdFx0XHRldmFsTW9kdWxlVGV4dChjYWNoZWQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0bmxzTW9kdWxlID0gbW9kdWxlc1tubHNNb2R1bGVJbmZvLm1pZF07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiBubHNNb2R1bGUgJiYgbmxzTW9kdWxlLmV4ZWN1dGVkICYmIG5sc01vZHVsZS5yZXN1bHQ7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9LFxuXG5cdFx0ICBleGVjUSA9XG5cdFx0XHRcdC8vIFRoZSBsaXN0IG9mIG1vZHVsZXMgdGhhdCBuZWVkIHRvIGJlIGV2YWx1YXRlZC5cblx0XHRcdFx0W10sXG5cblx0XHRcdGRlZlEgPVxuXHRcdFx0XHQvLyBUaGUgcXVldWUgb2YgZGVmaW5lIGFyZ3VtZW50cyBzZW50IHRvIGxvYWRlci5cblx0XHRcdFx0W10sXG5cblx0XHRcdHdhaXRpbmcgPVxuXHRcdFx0XHQvLyBUaGUgc2V0IG9mIG1vZHVsZXMgdXBvbiB3aGljaCB0aGUgbG9hZGVyIGlzIHdhaXRpbmcgZm9yIGRlZmluaXRpb24gdG8gYXJyaXZlXG5cdFx0XHRcdHt9LFxuXG5cdFx0XHRzZXRSZXF1ZXN0ZWQgPSBmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFx0XHRtb2R1bGUuaW5qZWN0ZWQgPSByZXF1ZXN0ZWQ7XG5cdFx0XHRcdHdhaXRpbmdbbW9kdWxlLm1pZF0gPSAxO1xuXHRcdFx0XHRpZihtb2R1bGUudXJsKXtcblx0XHRcdFx0XHR3YWl0aW5nW21vZHVsZS51cmxdID0gbW9kdWxlLnBhY2sgfHwgMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydFRpbWVyKCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRBcnJpdmVkID0gZnVuY3Rpb24obW9kdWxlKXtcblx0XHRcdFx0bW9kdWxlLmluamVjdGVkID0gYXJyaXZlZDtcblx0XHRcdFx0ZGVsZXRlIHdhaXRpbmdbbW9kdWxlLm1pZF07XG5cdFx0XHRcdGlmKG1vZHVsZS51cmwpe1xuXHRcdFx0XHRcdGRlbGV0ZSB3YWl0aW5nW21vZHVsZS51cmxdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGlzRW1wdHkod2FpdGluZykpe1xuXHRcdFx0XHRcdGNsZWFyVGltZXIoKTtcblx0XHRcdFx0XHQgMCAgJiYgbGVnYWN5TW9kZT09eGQgJiYgKGxlZ2FjeU1vZGUgPSBzeW5jKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0ZXhlY0NvbXBsZXRlID0gcmVxLmlkbGUgPVxuXHRcdFx0XHQvLyBzYXlzIHRoZSBsb2FkZXIgaGFzIGNvbXBsZXRlZCAob3Igbm90KSBpdHMgd29ya1xuXHRcdFx0XHRmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHJldHVybiAhZGVmUS5sZW5ndGggJiYgaXNFbXB0eSh3YWl0aW5nKSAmJiAhZXhlY1EubGVuZ3RoICYmICFjaGVja0NvbXBsZXRlR3VhcmQ7XG5cdFx0XHRcdH07XG5cdH1cblxuXHR2YXIgcnVuTWFwUHJvZyA9IGZ1bmN0aW9uKHRhcmdldE1pZCwgbWFwKXtcblx0XHRcdC8vIHNlYXJjaCBmb3IgdGFyZ2V0TWlkIGluIG1hcDsgcmV0dXJuIHRoZSBtYXAgaXRlbSBpZiBmb3VuZDsgZmFsc3kgb3RoZXJ3aXNlXG5cdFx0XHRpZihtYXApe1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1hcC5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGlmKG1hcFtpXVsyXS50ZXN0KHRhcmdldE1pZCkpe1xuXHRcdFx0XHRcdHJldHVybiBtYXBbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAwO1xuXHRcdH0sXG5cblx0XHRjb21wYWN0UGF0aCA9IGZ1bmN0aW9uKHBhdGgpe1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdFx0XHRzZWdtZW50LCBsYXN0U2VnbWVudDtcblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKS5zcGxpdCgnLycpO1xuXHRcdFx0d2hpbGUocGF0aC5sZW5ndGgpe1xuXHRcdFx0XHRzZWdtZW50ID0gcGF0aC5zaGlmdCgpO1xuXHRcdFx0XHRpZihzZWdtZW50PT1cIi4uXCIgJiYgcmVzdWx0Lmxlbmd0aCAmJiBsYXN0U2VnbWVudCE9XCIuLlwiKXtcblx0XHRcdFx0XHRyZXN1bHQucG9wKCk7XG5cdFx0XHRcdFx0bGFzdFNlZ21lbnQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR9ZWxzZSBpZihzZWdtZW50IT1cIi5cIil7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2gobGFzdFNlZ21lbnQ9IHNlZ21lbnQpO1xuXHRcdFx0XHR9IC8vIGVsc2UgaWdub3JlIFwiLlwiXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCIvXCIpO1xuXHRcdH0sXG5cblx0XHRtYWtlTW9kdWxlSW5mbyA9IGZ1bmN0aW9uKHBpZCwgbWlkLCBwYWNrLCB1cmwpe1xuXHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0dmFyIHhkPSByZXEuaXNYZFVybCh1cmwpO1xuXHRcdFx0XHRyZXR1cm4ge3BpZDpwaWQsIG1pZDptaWQsIHBhY2s6cGFjaywgdXJsOnVybCwgZXhlY3V0ZWQ6MCwgZGVmOjAsIGlzWGQ6eGQsIGlzQW1kOiEhKHhkIHx8IChwYWNrc1twaWRdICYmIHBhY2tzW3BpZF0uaXNBbWQpKX07XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0cmV0dXJuIHtwaWQ6cGlkLCBtaWQ6bWlkLCBwYWNrOnBhY2ssIHVybDp1cmwsIGV4ZWN1dGVkOjAsIGRlZjowfTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0TW9kdWxlSW5mb18gPSBmdW5jdGlvbihtaWQsIHJlZmVyZW5jZU1vZHVsZSwgcGFja3MsIG1vZHVsZXMsIGJhc2VVcmwsIG1hcFByb2dzLCBwYXRoc01hcFByb2csIGFsaWFzZXMsIGFsd2F5c0NyZWF0ZSwgZnJvbVBlbmRpbmdDYWNoZSl7XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbnN0ZWFkIG9mIHVzaW5nIGxleGljYWwgdmFyaWFibGVzIHNvIHRoYXQgdGhpcyBmdW5jdGlvbiBteSBiZSB1c2VkIGluZGVwZW5kZW50IG9mIHRoZSBsb2FkZXIgKGUuZy4sIHRoZSBidWlsZGVyKVxuXHRcdFx0Ly8gYWx3YXlzQ3JlYXRlIGlzIHVzZWZ1bCBpbiB0aGlzIGNhc2Ugc28gdGhhdCBnZXRNb2R1bGVJbmZvIG5ldmVyIHJldHVybnMgcmVmZXJlbmNlcyB0byByZWFsIG1vZHVsZXMgb3duZWQgYnkgdGhlIGxvYWRlclxuXHRcdFx0dmFyIHBpZCwgcGFjaywgbWlkSW5QYWNrYWdlLCBtYXBJdGVtLCB1cmwsIHJlc3VsdCwgaXNSZWxhdGl2ZSwgcmVxdWVzdGVkTWlkO1xuXHRcdFx0cmVxdWVzdGVkTWlkID0gbWlkO1xuXHRcdFx0aXNSZWxhdGl2ZSA9IC9eXFwuLy50ZXN0KG1pZCk7XG5cdFx0XHRpZigvKF5cXC8pfChcXDopfChcXC5qcyQpLy50ZXN0KG1pZCkgfHwgKGlzUmVsYXRpdmUgJiYgIXJlZmVyZW5jZU1vZHVsZSkpe1xuXHRcdFx0XHQvLyBhYnNvbHV0ZSBwYXRoIG9yIHByb3RvY29sIG9mIC5qcyBmaWxldHlwZSwgb3IgcmVsYXRpdmUgcGF0aCBidXQgbm8gcmVmZXJlbmNlIG1vZHVsZSBhbmQgdGhlcmVmb3JlIHJlbGF0aXZlIHRvIHBhZ2Vcblx0XHRcdFx0Ly8gd2hhdGV2ZXIgaXQgaXMsIGl0J3Mgbm90IGEgbW9kdWxlIGJ1dCBqdXN0IGEgVVJMIG9mIHNvbWUgc29ydFxuXHRcdFx0XHQvLyBub3RlOiBwaWQ9PT0wIGluZGljYXRlcyB0aGUgcm91dGluZSBpcyByZXR1cm5pbmcgYW4gdW5tb2RpZmllZCBtaWRcblxuXHRcdFx0XHRyZXR1cm4gbWFrZU1vZHVsZUluZm8oMCwgbWlkLCAwLCBtaWQpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIHJlbGF0aXZlIG1vZHVsZSBpZHMgYXJlIHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2VNb2R1bGU7IGdldCByaWQgb2YgYW55IGRvdHNcblx0XHRcdFx0bWlkID0gY29tcGFjdFBhdGgoaXNSZWxhdGl2ZSA/IChyZWZlcmVuY2VNb2R1bGUubWlkICsgXCIvLi4vXCIgKyBtaWQpIDogbWlkKTtcblx0XHRcdFx0aWYoL15cXC4vLnRlc3QobWlkKSl7XG5cdFx0XHRcdFx0dGhyb3cgbWFrZUVycm9yKFwiaXJyYXRpb25hbFBhdGhcIiwgbWlkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBhdCB0aGlzIHBvaW50LCBtaWQgaXMgYW4gYWJzb2x1dGUgbWlkXG5cblx0XHRcdFx0Ly8gbWFwIHRoZSBtaWRcblx0XHRcdFx0aWYoIWZyb21QZW5kaW5nQ2FjaGUgJiYgIWlzUmVsYXRpdmUgJiYgbWFwUHJvZ3Muc3Rhcil7XG5cdFx0XHRcdFx0bWFwSXRlbSA9IHJ1bk1hcFByb2cobWlkLCBtYXBQcm9ncy5zdGFyWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighbWFwSXRlbSAmJiByZWZlcmVuY2VNb2R1bGUpe1xuXHRcdFx0XHRcdG1hcEl0ZW0gPSBydW5NYXBQcm9nKHJlZmVyZW5jZU1vZHVsZS5taWQsIG1hcFByb2dzKTtcblx0XHRcdFx0XHRtYXBJdGVtID0gbWFwSXRlbSAmJiBydW5NYXBQcm9nKG1pZCwgbWFwSXRlbVsxXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihtYXBJdGVtKXtcblx0XHRcdFx0XHRtaWQgPSBtYXBJdGVtWzFdICsgbWlkLnN1YnN0cmluZyhtYXBJdGVtWzNdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0bWF0Y2ggPSBtaWQubWF0Y2goL14oW15cXC9dKykoXFwvKC4rKSk/JC8pO1xuXHRcdFx0XHRwaWQgPSBtYXRjaCA/IG1hdGNoWzFdIDogXCJcIjtcblx0XHRcdFx0aWYoKHBhY2sgPSBwYWNrc1twaWRdKSl7XG5cdFx0XHRcdFx0bWlkID0gcGlkICsgXCIvXCIgKyAobWlkSW5QYWNrYWdlID0gKG1hdGNoWzNdIHx8IHBhY2subWFpbikpO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRwaWQgPSBcIlwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2VhcmNoIGFsaWFzZXNcblx0XHRcdFx0dmFyIGNhbmRpZGF0ZUxlbmd0aCA9IDAsXG5cdFx0XHRcdFx0Y2FuZGlkYXRlID0gMDtcblx0XHRcdFx0Zm9yRWFjaChhbGlhc2VzLCBmdW5jdGlvbihwYWlyKXtcblx0XHRcdFx0XHR2YXIgbWF0Y2ggPSBtaWQubWF0Y2gocGFpclswXSk7XG5cdFx0XHRcdFx0aWYobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoPmNhbmRpZGF0ZUxlbmd0aCl7XG5cdFx0XHRcdFx0XHRjYW5kaWRhdGUgPSBpc0Z1bmN0aW9uKHBhaXJbMV0pID8gbWlkLnJlcGxhY2UocGFpclswXSwgcGFpclsxXSkgOiBwYWlyWzFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmKGNhbmRpZGF0ZSl7XG5cdFx0XHRcdFx0cmV0dXJuIGdldE1vZHVsZUluZm9fKGNhbmRpZGF0ZSwgMCwgcGFja3MsIG1vZHVsZXMsIGJhc2VVcmwsIG1hcFByb2dzLCBwYXRoc01hcFByb2csIGFsaWFzZXMsIGFsd2F5c0NyZWF0ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgPSBtb2R1bGVzW21pZF07XG5cdFx0XHRcdGlmKHJlc3VsdCl7XG5cdFx0XHRcdFx0cmV0dXJuIGFsd2F5c0NyZWF0ZSA/IG1ha2VNb2R1bGVJbmZvKHJlc3VsdC5waWQsIHJlc3VsdC5taWQsIHJlc3VsdC5wYWNrLCByZXN1bHQudXJsKSA6IG1vZHVsZXNbbWlkXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gZ2V0IGhlcmUgaWZmIHRoZSBzb3VnaHQtYWZ0ZXIgbW9kdWxlIGRvZXMgbm90IHlldCBleGlzdDsgdGhlcmVmb3JlLCB3ZSBuZWVkIHRvIGNvbXB1dGUgdGhlIFVSTCBnaXZlbiB0aGVcblx0XHRcdC8vIGZ1bGx5IHJlc29sdmVkIChpLmUuLCBhbGwgcmVsYXRpdmUgaW5kaWNhdG9ycyBhbmQgcGFja2FnZSBtYXBwaW5nIHJlc29sdmVkKSBtb2R1bGUgaWRcblxuXHRcdFx0Ly8gbm90ZTogcGlkIT09MCBpbmRpY2F0ZXMgdGhlIHJvdXRpbmUgaXMgcmV0dXJuaW5nIGEgdXJsIHRoYXQgaGFzIC5qcyBhcHBlbmRlZCB1bm1vZGlmaWVkIG1pZFxuXHRcdFx0bWFwSXRlbSA9IHJ1bk1hcFByb2cobWlkLCBwYXRoc01hcFByb2cpO1xuXHRcdFx0aWYobWFwSXRlbSl7XG5cdFx0XHRcdHVybCA9IG1hcEl0ZW1bMV0gKyBtaWQuc3Vic3RyaW5nKG1hcEl0ZW1bM10pO1xuXHRcdFx0fWVsc2UgaWYocGlkKXtcblx0XHRcdFx0dXJsID0gKHBhY2subG9jYXRpb24uc2xpY2UoLTEpID09PSAnLycgPyBwYWNrLmxvY2F0aW9uLnNsaWNlKDAsIC0xKSA6IHBhY2subG9jYXRpb24pICsgXCIvXCIgKyBtaWRJblBhY2thZ2U7XG5cdFx0XHR9ZWxzZSBpZiggMCApe1xuXHRcdFx0XHR1cmwgPSBcIi4uL1wiICsgbWlkO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHVybCA9IG1pZDtcblx0XHRcdH1cblx0XHRcdC8vIGlmIHJlc3VsdCBpcyBub3QgYWJzb2x1dGUsIGFkZCBiYXNlVXJsXG5cdFx0XHRpZighKC8oXlxcLyl8KFxcOikvLnRlc3QodXJsKSkpe1xuXHRcdFx0XHR1cmwgPSBiYXNlVXJsICsgdXJsO1xuXHRcdFx0fVxuXHRcdFx0dXJsICs9IFwiLmpzXCI7XG5cdFx0XHRyZXR1cm4gbWFrZU1vZHVsZUluZm8ocGlkLCBtaWQsIHBhY2ssIGNvbXBhY3RQYXRoKHVybCkpO1xuXHRcdH0sXG5cblx0XHRnZXRNb2R1bGVJbmZvID0gZnVuY3Rpb24obWlkLCByZWZlcmVuY2VNb2R1bGUsIGZyb21QZW5kaW5nQ2FjaGUpe1xuXHRcdFx0cmV0dXJuIGdldE1vZHVsZUluZm9fKG1pZCwgcmVmZXJlbmNlTW9kdWxlLCBwYWNrcywgbW9kdWxlcywgcmVxLmJhc2VVcmwsIG1hcFByb2dzLCBwYXRoc01hcFByb2csIGFsaWFzZXMsIHVuZGVmaW5lZCwgZnJvbVBlbmRpbmdDYWNoZSk7XG5cdFx0fTtcblxuXHRpZiAoISAxICkge1xuXHRcdHZhciByZXNvbHZlUGx1Z2luUmVzb3VyY2VJZCA9IGZ1bmN0aW9uKHBsdWdpbiwgcHJpZCwgcmVmZXJlbmNlTW9kdWxlKXtcblx0XHRcdFx0cmV0dXJuIHBsdWdpbi5ub3JtYWxpemUgPyBwbHVnaW4ubm9ybWFsaXplKHByaWQsIGZ1bmN0aW9uKG1pZCl7cmV0dXJuIHRvQWJzTWlkKG1pZCwgcmVmZXJlbmNlTW9kdWxlKTt9KSA6IHRvQWJzTWlkKHByaWQsIHJlZmVyZW5jZU1vZHVsZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRkeW5hbWljUGx1Z2luVWlkR2VuZXJhdG9yID0gMCxcblxuXHRcdFx0Z2V0TW9kdWxlID0gZnVuY3Rpb24obWlkLCByZWZlcmVuY2VNb2R1bGUsIGltbWVkaWF0ZSl7XG5cdFx0XHRcdC8vIGNvbXB1dGUgYW5kIG9wdGlvbmFsbHkgY29uc3RydWN0IChpZiBuZWNlc3NhcnkpIHRoZSBtb2R1bGUgaW1wbGllZCBieSB0aGUgbWlkIHdpdGggcmVzcGVjdCB0byByZWZlcmVuY2VNb2R1bGVcblx0XHRcdFx0dmFyIG1hdGNoLCBwbHVnaW4sIHByaWQsIHJlc3VsdDtcblx0XHRcdFx0bWF0Y2ggPSBtaWQubWF0Y2goL14oLis/KVxcISguKikkLyk7XG5cdFx0XHRcdGlmKG1hdGNoKXtcblx0XHRcdFx0XHQvLyBuYW1lIHdhcyA8cGx1Z2luLW1vZHVsZT4hPHBsdWdpbi1yZXNvdXJjZS1pZD5cblx0XHRcdFx0XHRwbHVnaW4gPSBnZXRNb2R1bGUobWF0Y2hbMV0sIHJlZmVyZW5jZU1vZHVsZSwgaW1tZWRpYXRlKTtcblxuXHRcdFx0XHRcdGlmKCAwICAmJiBsZWdhY3lNb2RlID09IHN5bmMgJiYgIXBsdWdpbi5leGVjdXRlZCl7XG5cdFx0XHRcdFx0XHRpbmplY3RNb2R1bGUocGx1Z2luKTtcblx0XHRcdFx0XHRcdGlmKHBsdWdpbi5pbmplY3RlZD09PWFycml2ZWQgJiYgIXBsdWdpbi5leGVjdXRlZCl7XG5cdFx0XHRcdFx0XHRcdGd1YXJkQ2hlY2tDb21wbGV0ZShmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdGV4ZWNNb2R1bGUocGx1Z2luKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihwbHVnaW4uZXhlY3V0ZWQpe1xuXHRcdFx0XHRcdFx0XHRwcm9tb3RlTW9kdWxlVG9QbHVnaW4ocGx1Z2luKTtcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHQvLyB3ZSBhcmUgaW4geGRvbWFpbiBtb2RlIGZvciBzb21lIHJlYXNvblxuXHRcdFx0XHRcdFx0XHRleGVjUS51bnNoaWZ0KHBsdWdpbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cblxuXHRcdFx0XHRcdGlmKHBsdWdpbi5leGVjdXRlZCA9PT0gZXhlY3V0ZWQgJiYgIXBsdWdpbi5sb2FkKXtcblx0XHRcdFx0XHRcdC8vIGV4ZWN1dGVkIHRoZSBtb2R1bGUgbm90IGtub3dpbmcgaXQgd2FzIGEgcGx1Z2luXG5cdFx0XHRcdFx0XHRwcm9tb3RlTW9kdWxlVG9QbHVnaW4ocGx1Z2luKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBpZiB0aGUgcGx1Z2luIGhhcyBub3QgYmVlbiBsb2FkZWQsIHRoZW4gY2FuJ3QgcmVzb2x2ZSB0aGUgcHJpZCBhbmQgIG11c3QgYXNzdW1lIHRoaXMgcGx1Z2luIGlzIGR5bmFtaWMgdW50aWwgd2UgZmluZCBvdXQgb3RoZXJ3aXNlXG5cdFx0XHRcdFx0aWYocGx1Z2luLmxvYWQpe1xuXHRcdFx0XHRcdFx0cHJpZCA9IHJlc29sdmVQbHVnaW5SZXNvdXJjZUlkKHBsdWdpbiwgbWF0Y2hbMl0sIHJlZmVyZW5jZU1vZHVsZSk7XG5cdFx0XHRcdFx0XHRtaWQgPSAocGx1Z2luLm1pZCArIFwiIVwiICsgKHBsdWdpbi5keW5hbWljID8gKytkeW5hbWljUGx1Z2luVWlkR2VuZXJhdG9yICsgXCIhXCIgOiBcIlwiKSArIHByaWQpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0cHJpZCA9IG1hdGNoWzJdO1xuXHRcdFx0XHRcdFx0bWlkID0gcGx1Z2luLm1pZCArIFwiIVwiICsgKCsrZHluYW1pY1BsdWdpblVpZEdlbmVyYXRvcikgKyBcIiF3YWl0aW5nRm9yUGx1Z2luXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCA9IHtwbHVnaW46cGx1Z2luLCBtaWQ6bWlkLCByZXE6Y3JlYXRlUmVxdWlyZShyZWZlcmVuY2VNb2R1bGUpLCBwcmlkOnByaWR9O1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRyZXN1bHQgPSBnZXRNb2R1bGVJbmZvKG1pZCwgcmVmZXJlbmNlTW9kdWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlc1tyZXN1bHQubWlkXSB8fCAoIWltbWVkaWF0ZSAmJiAobW9kdWxlc1tyZXN1bHQubWlkXSA9IHJlc3VsdCkpO1xuXHRcdFx0fTtcblx0fVxuXG5cdHZhciB0b0Fic01pZCA9IHJlcS50b0Fic01pZCA9IGZ1bmN0aW9uKG1pZCwgcmVmZXJlbmNlTW9kdWxlKXtcblx0XHRcdHJldHVybiBnZXRNb2R1bGVJbmZvKG1pZCwgcmVmZXJlbmNlTW9kdWxlKS5taWQ7XG5cdFx0fSxcblxuXHRcdHRvVXJsID0gcmVxLnRvVXJsID0gZnVuY3Rpb24obmFtZSwgcmVmZXJlbmNlTW9kdWxlKXtcblx0XHRcdHZhciBtb2R1bGVJbmZvID0gZ2V0TW9kdWxlSW5mbyhuYW1lK1wiL3hcIiwgcmVmZXJlbmNlTW9kdWxlKSxcblx0XHRcdFx0dXJsPSBtb2R1bGVJbmZvLnVybDtcblx0XHRcdHJldHVybiBmaXh1cFVybChtb2R1bGVJbmZvLnBpZD09PTAgP1xuXHRcdFx0XHQvLyBpZiBwaWQ9PT0wLCB0aGVuIG5hbWUgaGFkIGEgcHJvdG9jb2wgb3IgYWJzb2x1dGUgcGF0aDsgZWl0aGVyIHdheSwgdG9VcmwgaXMgdGhlIGlkZW50aWZ5IGZ1bmN0aW9uIGluIHN1Y2ggY2FzZXNcblx0XHRcdFx0bmFtZSA6XG5cdFx0XHRcdC8vIFwiL3guanNcIiBzaW5jZSBnZXRNb2R1bGVJbmZvIGF1dG9tYXRpY2FsbHkgYXBwZW5kcyBcIi5qc1wiIGFuZCB3ZSBhcHBlbmRlZCBcIi94XCIgdG8gbWFrZSBuYW1lIGxvb2sgbGlrZSBhIG1vZHVsZSBpZFxuXHRcdFx0XHR1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGgtNSlcblx0XHRcdCk7XG5cdFx0fTtcblxuXHRpZiAoISAxICkge1xuXHRcdHZhciBub25Nb2R1bGVQcm9wcyA9IHtcblx0XHRcdFx0aW5qZWN0ZWQ6IGFycml2ZWQsXG5cdFx0XHRcdGV4ZWN1dGVkOiBleGVjdXRlZCxcblx0XHRcdFx0ZGVmOiBub25tb2R1bGUsXG5cdFx0XHRcdHJlc3VsdDogbm9ubW9kdWxlXG5cdFx0XHR9LFxuXG5cdFx0XHRtYWtlQ2pzID0gZnVuY3Rpb24obWlkKXtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZXNbbWlkXSA9IG1peCh7bWlkOm1pZH0sIG5vbk1vZHVsZVByb3BzKTtcblx0XHRcdH0sXG5cblx0XHRcdGNqc1JlcXVpcmVNb2R1bGUgPSBtYWtlQ2pzKFwicmVxdWlyZVwiKSxcblx0XHRcdGNqc0V4cG9ydHNNb2R1bGUgPSBtYWtlQ2pzKFwiZXhwb3J0c1wiKSxcblx0XHRcdGNqc01vZHVsZU1vZHVsZSA9IG1ha2VDanMoXCJtb2R1bGVcIiksXG5cblx0XHRcdHJ1bkZhY3RvcnkgPSBmdW5jdGlvbihtb2R1bGUsIGFyZ3Mpe1xuXHRcdFx0XHRyZXEudHJhY2UoXCJsb2FkZXItcnVuLWZhY3RvcnlcIiwgW21vZHVsZS5taWRdKTtcblx0XHRcdFx0dmFyIGZhY3RvcnkgPSBtb2R1bGUuZGVmLFxuXHRcdFx0XHRcdHJlc3VsdDtcblx0XHRcdFx0IDAgICYmIHN5bmNFeGVjU3RhY2sudW5zaGlmdChtb2R1bGUpO1xuXHRcdFx0XHRpZiggMCApe1xuXHRcdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRcdHJlc3VsdD0gaXNGdW5jdGlvbihmYWN0b3J5KSA/IGZhY3RvcnkuYXBwbHkobnVsbCwgYXJncykgOiBmYWN0b3J5O1xuXHRcdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHRcdHNpZ25hbChlcnJvciwgbW9kdWxlLnJlc3VsdCA9IG1ha2VFcnJvcihcImZhY3RvcnlUaHJld1wiLCBbbW9kdWxlLCBlXSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0cmVzdWx0PSBpc0Z1bmN0aW9uKGZhY3RvcnkpID8gZmFjdG9yeS5hcHBseShudWxsLCBhcmdzKSA6IGZhY3Rvcnk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bW9kdWxlLnJlc3VsdCA9IHJlc3VsdD09PXVuZGVmaW5lZCAmJiBtb2R1bGUuY2pzID8gbW9kdWxlLmNqcy5leHBvcnRzIDogcmVzdWx0O1xuXHRcdFx0XHQgMCAgJiYgc3luY0V4ZWNTdGFjay5zaGlmdChtb2R1bGUpO1xuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnRFeGVjID0ge30sXG5cblx0XHRcdGRlZk9yZGVyID0gMCxcblxuXHRcdFx0cHJvbW90ZU1vZHVsZVRvUGx1Z2luID0gZnVuY3Rpb24ocGx1Z2luTW9kdWxlKXtcblx0XHRcdFx0dmFyIHBsdWdpbiA9IHBsdWdpbk1vZHVsZS5yZXN1bHQ7XG5cdFx0XHRcdHBsdWdpbk1vZHVsZS5keW5hbWljID0gcGx1Z2luLmR5bmFtaWM7XG5cdFx0XHRcdHBsdWdpbk1vZHVsZS5ub3JtYWxpemUgPSBwbHVnaW4ubm9ybWFsaXplO1xuXHRcdFx0XHRwbHVnaW5Nb2R1bGUubG9hZCA9IHBsdWdpbi5sb2FkO1xuXHRcdFx0XHRyZXR1cm4gcGx1Z2luTW9kdWxlO1xuXHRcdFx0fSxcblxuXHRcdFx0cmVzb2x2ZVBsdWdpbkxvYWRRID0gZnVuY3Rpb24ocGx1Z2luKXtcblx0XHRcdFx0Ly8gcGx1Z2lucyBpcyBhIG5ld2x5IGV4ZWN1dGVkIG1vZHVsZSB0aGF0IGhhcyBhIGxvYWRRIHdhaXRpbmcgdG8gcnVuXG5cblx0XHRcdFx0Ly8gc3RlcCAxOiB0cmF2ZXJzZSB0aGUgbG9hZFEgYW5kIGZpeHVwIHRoZSBtaWQgYW5kIHByaWQ7IHJlbWVtYmVyIHRoZSBtYXAgZnJvbSBvcmlnaW5hbCBtaWQgdG8gbmV3IG1pZFxuXHRcdFx0XHQvLyByZWNhbGwgdGhlIG9yaWdpbmFsIG1pZCB3YXMgY3JlYXRlZCBiZWZvcmUgdGhlIHBsdWdpbiB3YXMgb24gYm9hcmQgYW5kIHRoZXJlZm9yZSBpdCB3YXMgaW1wb3NzaWJsZSB0b1xuXHRcdFx0XHQvLyBjb21wdXRlIHRoZSBmaW5hbCBtaWQ7IGFjY29yZGluZ2x5LCBwcmlkIG1heSBvciBtYXkgbm90IGNoYW5nZSwgYnV0IHRoZSBtaWQgd2lsbCBkZWZpbml0ZWx5IGNoYW5nZVxuXHRcdFx0XHR2YXIgbWFwID0ge307XG5cdFx0XHRcdGZvckVhY2gocGx1Z2luLmxvYWRRLCBmdW5jdGlvbihwc2V1ZG9QbHVnaW5SZXNvdXJjZSl7XG5cdFx0XHRcdFx0Ly8gbWFudWZhY3R1cmUgYW5kIGluc2VydCB0aGUgcmVhbCBtb2R1bGUgaW4gbW9kdWxlc1xuXHRcdFx0XHRcdHZhciBwcmlkID0gcmVzb2x2ZVBsdWdpblJlc291cmNlSWQocGx1Z2luLCBwc2V1ZG9QbHVnaW5SZXNvdXJjZS5wcmlkLCBwc2V1ZG9QbHVnaW5SZXNvdXJjZS5yZXEubW9kdWxlKSxcblx0XHRcdFx0XHRcdG1pZCA9IHBsdWdpbi5keW5hbWljID8gcHNldWRvUGx1Z2luUmVzb3VyY2UubWlkLnJlcGxhY2UoL3dhaXRpbmdGb3JQbHVnaW4kLywgcHJpZCkgOiAocGx1Z2luLm1pZCArIFwiIVwiICsgcHJpZCksXG5cdFx0XHRcdFx0XHRwbHVnaW5SZXNvdXJjZSA9IG1peChtaXgoe30sIHBzZXVkb1BsdWdpblJlc291cmNlKSwge21pZDptaWQsIHByaWQ6cHJpZCwgaW5qZWN0ZWQ6MH0pO1xuXHRcdFx0XHRcdGlmKCFtb2R1bGVzW21pZF0gfHwgIW1vZHVsZXNbbWlkXS5pbmplY3RlZCAvKmZvciByZXF1aXJlLnVuZGVmKi8pe1xuXHRcdFx0XHRcdFx0Ly8gY3JlYXRlIGEgbmV3ICh0aGUgcmVhbCkgcGx1Z2luIHJlc291cmNlIGFuZCBpbmplY3QgaXQgbm9ybWFsbHkgbm93IHRoYXQgdGhlIHBsdWdpbiBpcyBvbiBib2FyZFxuXHRcdFx0XHRcdFx0aW5qZWN0UGx1Z2luKG1vZHVsZXNbbWlkXSA9IHBsdWdpblJlc291cmNlKTtcblx0XHRcdFx0XHR9IC8vIGVsc2UgdGhpcyB3YXMgYSBkdXBsaWNhdGUgcmVxdWVzdCBmb3IgdGhlIHNhbWUgKHBsdWdpbiwgcmlkKSBmb3IgYSBub25keW5hbWljIHBsdWdpblxuXG5cdFx0XHRcdFx0Ly8gcGx1Z2luUmVzb3VyY2UgaXMgcmVhbGx5IGp1c3QgYSBwbGFjZWhvbGRlciB3aXRoIHRoZSB3cm9uZyBtaWQgKGJlY2F1c2Ugd2UgY291bGRuJ3QgY2FsY3VsYXRlIGl0IHVudGlsIHRoZSBwbHVnaW4gd2FzIG9uIGJvYXJkKVxuXHRcdFx0XHRcdC8vIG1hcmsgaXMgYXMgYXJyaXZlZCBhbmQgZGVsZXRlIGl0IGZyb20gbW9kdWxlczsgdGhlIHJlYWwgbW9kdWxlIHdhcyByZXF1ZXN0ZWQgYWJvdmVcblx0XHRcdFx0XHRtYXBbcHNldWRvUGx1Z2luUmVzb3VyY2UubWlkXSA9IG1vZHVsZXNbbWlkXTtcblx0XHRcdFx0XHRzZXRBcnJpdmVkKHBzZXVkb1BsdWdpblJlc291cmNlKTtcblx0XHRcdFx0XHRkZWxldGUgbW9kdWxlc1twc2V1ZG9QbHVnaW5SZXNvdXJjZS5taWRdO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cGx1Z2luLmxvYWRRID0gMDtcblxuXHRcdFx0XHQvLyBzdGVwMjogcmVwbGFjZSBhbGwgcmVmZXJlbmNlcyB0byBhbnkgcGxhY2Vob2xkZXIgbW9kdWxlcyB3aXRoIHJlYWwgbW9kdWxlc1xuXHRcdFx0XHR2YXIgc3Vic3RpdHV0ZU1vZHVsZXMgPSBmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFx0XHRcdGZvcih2YXIgcmVwbGFjZW1lbnQsIGRlcHMgPSBtb2R1bGUuZGVwcyB8fCBbXSwgaSA9IDA7IGk8ZGVwcy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0XHRyZXBsYWNlbWVudCA9IG1hcFtkZXBzW2ldLm1pZF07XG5cdFx0XHRcdFx0XHRpZihyZXBsYWNlbWVudCl7XG5cdFx0XHRcdFx0XHRcdGRlcHNbaV0gPSByZXBsYWNlbWVudDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdGZvcih2YXIgcCBpbiBtb2R1bGVzKXtcblx0XHRcdFx0XHRzdWJzdGl0dXRlTW9kdWxlcyhtb2R1bGVzW3BdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3JFYWNoKGV4ZWNRLCBzdWJzdGl0dXRlTW9kdWxlcyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRmaW5pc2hFeGVjID0gZnVuY3Rpb24obW9kdWxlKXtcblx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWZpbmlzaC1leGVjXCIsIFttb2R1bGUubWlkXSk7XG5cdFx0XHRcdG1vZHVsZS5leGVjdXRlZCA9IGV4ZWN1dGVkO1xuXHRcdFx0XHRtb2R1bGUuZGVmT3JkZXIgPSBkZWZPcmRlcisrO1xuXHRcdFx0XHQgMCAgJiYgZm9yRWFjaChtb2R1bGUucHJvdmlkZXMsIGZ1bmN0aW9uKGNiKXsgY2IoKTsgfSk7XG5cdFx0XHRcdGlmKG1vZHVsZS5sb2FkUSl7XG5cdFx0XHRcdFx0Ly8gdGhlIG1vZHVsZSB3YXMgYSBwbHVnaW5cblx0XHRcdFx0XHRwcm9tb3RlTW9kdWxlVG9QbHVnaW4obW9kdWxlKTtcblx0XHRcdFx0XHRyZXNvbHZlUGx1Z2luTG9hZFEobW9kdWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIHRoaXMgbW9kdWxlIGZyb20gdGhlIGV4ZWNRXG5cdFx0XHRcdGZvcihpID0gMDsgaSA8IGV4ZWNRLmxlbmd0aDspe1xuXHRcdFx0XHRcdGlmKGV4ZWNRW2ldID09PSBtb2R1bGUpe1xuXHRcdFx0XHRcdFx0ZXhlY1Euc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBkZWxldGUgcmVmZXJlbmNlcyB0byBzeW50aGV0aWMgbW9kdWxlc1xuXHRcdFx0XHRpZiAoL15yZXF1aXJlXFwqLy50ZXN0KG1vZHVsZS5taWQpKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIG1vZHVsZXNbbW9kdWxlLm1pZF07XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGNpcmNsZVRyYWNlID0gW10sXG5cblx0XHRcdGV4ZWNNb2R1bGUgPSBmdW5jdGlvbihtb2R1bGUsIHN0cmljdCl7XG5cdFx0XHRcdC8vIHJ1biB0aGUgZGVwZW5kZW5jeSB2ZWN0b3IsIHRoZW4gcnVuIHRoZSBmYWN0b3J5IGZvciBtb2R1bGVcblx0XHRcdFx0aWYobW9kdWxlLmV4ZWN1dGVkID09PSBleGVjdXRpbmcpe1xuXHRcdFx0XHRcdHJlcS50cmFjZShcImxvYWRlci1jaXJjdWxhci1kZXBlbmRlbmN5XCIsIFtjaXJjbGVUcmFjZS5jb25jYXQobW9kdWxlLm1pZCkuam9pbihcIi0+XCIpXSk7XG5cdFx0XHRcdFx0cmV0dXJuICghbW9kdWxlLmRlZiB8fCBzdHJpY3QpID8gYWJvcnRFeGVjIDogIChtb2R1bGUuY2pzICYmIG1vZHVsZS5janMuZXhwb3J0cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYXQgdGhpcyBwb2ludCB0aGUgbW9kdWxlIGlzIGVpdGhlciBub3QgZXhlY3V0ZWQgb3IgZnVsbHkgZXhlY3V0ZWRcblxuXG5cdFx0XHRcdGlmKCFtb2R1bGUuZXhlY3V0ZWQpe1xuXHRcdFx0XHRcdGlmKCFtb2R1bGUuZGVmKXtcblx0XHRcdFx0XHRcdHJldHVybiBhYm9ydEV4ZWM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBtaWQgPSBtb2R1bGUubWlkLFxuXHRcdFx0XHRcdFx0ZGVwcyA9IG1vZHVsZS5kZXBzIHx8IFtdLFxuXHRcdFx0XHRcdFx0YXJnLCBhcmdSZXN1bHQsXG5cdFx0XHRcdFx0XHRhcmdzID0gW10sXG5cdFx0XHRcdFx0XHRpID0gMDtcblxuXHRcdFx0XHRcdGlmKCAwICl7XG5cdFx0XHRcdFx0XHRjaXJjbGVUcmFjZS5wdXNoKG1pZCk7XG5cdFx0XHRcdFx0XHRyZXEudHJhY2UoXCJsb2FkZXItZXhlYy1tb2R1bGVcIiwgW1wiZXhlY1wiLCBjaXJjbGVUcmFjZS5sZW5ndGgsIG1pZF0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGZvciBjaXJjdWxhciBkZXBlbmRlbmNpZXMsIGFzc3VtZSB0aGUgZmlyc3QgbW9kdWxlIGVuY291bnRlcmVkIHdhcyBleGVjdXRlZCBPS1xuXHRcdFx0XHRcdC8vIG1vZHVsZXMgdGhhdCBjaXJjdWxhcmx5IGRlcGVuZCBvbiBhIG1vZHVsZSB0aGF0IGhhcyBub3QgcnVuIGl0cyBmYWN0b3J5IHdpbGwgZ2V0XG5cdFx0XHRcdFx0Ly8gdGhlIHByZS1tYWRlIGNqcy5leHBvcnRzPT09bW9kdWxlLnJlc3VsdC4gVGhleSBjYW4gdGFrZSBhIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdCBhbmQvb3Jcblx0XHRcdFx0XHQvLyBhZGQgcHJvcGVydGllcyB0byBpdC4gV2hlbiB0aGUgbW9kdWxlIGZpbmFsbHkgcnVucyBpdHMgZmFjdG9yeSwgdGhlIGZhY3RvcnkgY2FuXG5cdFx0XHRcdFx0Ly8gcmVhZC93cml0ZS9yZXBsYWNlIHRoaXMgb2JqZWN0LiBOb3RpY2UgdGhhdCBzbyBsb25nIGFzIHRoZSBvYmplY3QgaXNuJ3QgcmVwbGFjZWQsIGFueVxuXHRcdFx0XHRcdC8vIHJlZmVyZW5jZSB0YWtlbiBlYXJsaWVyIHdoaWxlIHdhbGtpbmcgdGhlIGRlcHMgbGlzdCBpcyBzdGlsbCB2YWxpZC5cblx0XHRcdFx0XHRtb2R1bGUuZXhlY3V0ZWQgPSBleGVjdXRpbmc7XG5cdFx0XHRcdFx0d2hpbGUoKGFyZyA9IGRlcHNbaSsrXSkpe1xuXHRcdFx0XHRcdFx0YXJnUmVzdWx0ID0gKChhcmcgPT09IGNqc1JlcXVpcmVNb2R1bGUpID8gY3JlYXRlUmVxdWlyZShtb2R1bGUpIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0KChhcmcgPT09IGNqc0V4cG9ydHNNb2R1bGUpID8gbW9kdWxlLmNqcy5leHBvcnRzIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoKGFyZyA9PT0gY2pzTW9kdWxlTW9kdWxlKSA/IG1vZHVsZS5janMgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXhlY01vZHVsZShhcmcsIHN0cmljdCkpKSk7XG5cdFx0XHRcdFx0XHRpZihhcmdSZXN1bHQgPT09IGFib3J0RXhlYyl7XG5cdFx0XHRcdFx0XHRcdG1vZHVsZS5leGVjdXRlZCA9IDA7XG5cdFx0XHRcdFx0XHRcdHJlcS50cmFjZShcImxvYWRlci1leGVjLW1vZHVsZVwiLCBbXCJhYm9ydFwiLCBtaWRdKTtcblx0XHRcdFx0XHRcdFx0IDAgICYmIGNpcmNsZVRyYWNlLnBvcCgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYWJvcnRFeGVjO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YXJncy5wdXNoKGFyZ1Jlc3VsdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJ1bkZhY3RvcnkobW9kdWxlLCBhcmdzKTtcblx0XHRcdFx0XHRmaW5pc2hFeGVjKG1vZHVsZSk7XG5cdFx0XHRcdFx0IDAgICYmIGNpcmNsZVRyYWNlLnBvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGF0IHRoaXMgcG9pbnQgdGhlIG1vZHVsZSBpcyBndWFyYW50ZWVkIGZ1bGx5IGV4ZWN1dGVkXG5cblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5yZXN1bHQ7XG5cdFx0XHR9LFxuXG5cblx0XHRcdGNoZWNrQ29tcGxldGVHdWFyZCA9IDAsXG5cblx0XHRcdGd1YXJkQ2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uKHByb2Mpe1xuXHRcdFx0XHR0cnl7XG5cdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZUd1YXJkKys7XG5cdFx0XHRcdFx0cHJvYygpO1xuXHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmRvam90b29sa2l0Lm9yZy90aWNrZXQvMTY2MTdcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9ZmluYWxseXtcblx0XHRcdFx0XHRjaGVja0NvbXBsZXRlR3VhcmQtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihleGVjQ29tcGxldGUoKSl7XG5cdFx0XHRcdFx0c2lnbmFsKFwiaWRsZVwiLCBbXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHQvLyBrZWVwIGdvaW5nIHRocm91Z2ggdGhlIGV4ZWNRIGFzIGxvbmcgYXMgYXQgbGVhc3Qgb25lIGZhY3RvcnkgaXMgZXhlY3V0ZWRcblx0XHRcdFx0Ly8gcGx1Z2lucywgcmVjdXJzaW9uLCBjYWNoZWQgbW9kdWxlcyBhbGwgbWFrZSBmb3IgbWFueSBleGVjdXRpb24gcGF0aCBwb3NzaWJpbGl0aWVzXG5cdFx0XHRcdGlmKGNoZWNrQ29tcGxldGVHdWFyZCl7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGd1YXJkQ2hlY2tDb21wbGV0ZShmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGNoZWNrRG9qb1JlcXVpcmVQbHVnaW4oKTtcblx0XHRcdFx0XHRmb3IodmFyIGN1cnJlbnREZWZPcmRlciwgbW9kdWxlLCBpID0gMDsgaSA8IGV4ZWNRLmxlbmd0aDspe1xuXHRcdFx0XHRcdFx0Y3VycmVudERlZk9yZGVyID0gZGVmT3JkZXI7XG5cdFx0XHRcdFx0XHRtb2R1bGUgPSBleGVjUVtpXTtcblx0XHRcdFx0XHRcdGV4ZWNNb2R1bGUobW9kdWxlKTtcblx0XHRcdFx0XHRcdGlmKGN1cnJlbnREZWZPcmRlciE9ZGVmT3JkZXIpe1xuXHRcdFx0XHRcdFx0XHQvLyBkZWZPcmRlciB3YXMgYnVtcGVkIG9uZSBvciBtb3JlIHRpbWVzIGluZGljYXRpbmcgc29tZXRoaW5nIHdhcyBleGVjdXRlZCAobm90ZSwgdGhpcyBpbmRpY2F0ZXNcblx0XHRcdFx0XHRcdFx0Ly8gdGhlIGV4ZWNRIHdhcyBtb2RpZmllZCwgbWF5YmUgYSBsb3QgKGZvciBleGFtcGxlIGEgbGF0ZXIgbW9kdWxlIGNhdXNlcyBhbiBlYXJsaWVyIG1vZHVsZSB0byBleGVjdXRlKVxuXHRcdFx0XHRcdFx0XHRjaGVja0Rvam9SZXF1aXJlUGx1Z2luKCk7XG5cdFx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdC8vIG5vdGhpbmcgaGFwcGVuZWQ7IGNoZWNrIHRoZSBuZXh0IG1vZHVsZSBpbiB0aGUgZXhlYyBxdWV1ZVxuXHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdH1cblxuXHR2YXIgZml4dXBVcmw9IHR5cGVvZiB1c2VyQ29uZmlnLmZpeHVwVXJsID09IFwiZnVuY3Rpb25cIiA/IHVzZXJDb25maWcuZml4dXBVcmwgOiBmdW5jdGlvbih1cmwpe1xuXHRcdFx0dXJsICs9IFwiXCI7IC8vIG1ha2Ugc3VyZSB1cmwgaXMgYSBKYXZhc2NyaXB0IHN0cmluZyAoc29tZSBwYXRocyBtYXkgYmUgYSBKYXZhIHN0cmluZylcblx0XHRcdHJldHVybiB1cmwgKyAoY2FjaGVCdXN0ID8gKCgvXFw/Ly50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiKSArIGNhY2hlQnVzdCkgOiBcIlwiKTtcblx0XHR9O1xuXG5cblxuXHRpZiggMCApe1xuXHRcdHJlcS51bmRlZiA9IGZ1bmN0aW9uKG1vZHVsZUlkLCByZWZlcmVuY2VNb2R1bGUpe1xuXHRcdFx0Ly8gSW4gb3JkZXIgdG8gcmVsb2FkIGEgbW9kdWxlLCBpdCBtdXN0IGJlIHVuZGVmaW5lZCAodGhpcyByb3V0aW5lKSBhbmQgdGhlbiByZS1yZXF1ZXN0ZWQuXG5cdFx0XHQvLyBUaGlzIGlzIHVzZWZ1bCBmb3IgdGVzdGluZyBmcmFtZXdvcmtzIChhdCBsZWFzdCkuXG5cdFx0XHR2YXIgbW9kdWxlID0gZ2V0TW9kdWxlKG1vZHVsZUlkLCByZWZlcmVuY2VNb2R1bGUpO1xuXHRcdFx0c2V0QXJyaXZlZChtb2R1bGUpO1xuXHRcdFx0bWl4KG1vZHVsZSwge2RlZjowLCBleGVjdXRlZDowLCBpbmplY3RlZDowLCBub2RlOjAsIGxvYWQ6MH0pO1xuXHRcdH07XG5cdH1cblxuXHRpZiggZmFsc2UgKXtcblx0XHRpZiggMCA9PT11bmRlZmluZWQpe1xuXHRcdFx0IDAgJiYgaGFzLmFkZChcImRvam8tbG9hZGVyLWV2YWwtaGludC11cmxcIiwgMSk7XG5cdFx0fVxuXG5cdFx0dmFyIGluamVjdFBsdWdpbiA9IGZ1bmN0aW9uKFxuXHRcdFx0XHRtb2R1bGVcblx0XHRcdCl7XG5cdFx0XHRcdC8vIGluamVjdHMgdGhlIHBsdWdpbiBtb2R1bGUgZ2l2ZW4gYnkgbW9kdWxlOyBtYXkgaGF2ZSB0byBpbmplY3QgdGhlIHBsdWdpbiBpdHNlbGZcblx0XHRcdFx0dmFyIHBsdWdpbiA9IG1vZHVsZS5wbHVnaW47XG5cblx0XHRcdFx0aWYocGx1Z2luLmV4ZWN1dGVkID09PSBleGVjdXRlZCAmJiAhcGx1Z2luLmxvYWQpe1xuXHRcdFx0XHRcdC8vIGV4ZWN1dGVkIHRoZSBtb2R1bGUgbm90IGtub3dpbmcgaXQgd2FzIGEgcGx1Z2luXG5cdFx0XHRcdFx0cHJvbW90ZU1vZHVsZVRvUGx1Z2luKHBsdWdpbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb25Mb2FkID0gZnVuY3Rpb24oZGVmKXtcblx0XHRcdFx0XHRcdG1vZHVsZS5yZXN1bHQgPSBkZWY7XG5cdFx0XHRcdFx0XHRzZXRBcnJpdmVkKG1vZHVsZSk7XG5cdFx0XHRcdFx0XHRmaW5pc2hFeGVjKG1vZHVsZSk7XG5cdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZihwbHVnaW4ubG9hZCl7XG5cdFx0XHRcdFx0cGx1Z2luLmxvYWQobW9kdWxlLnByaWQsIG1vZHVsZS5yZXEsIG9uTG9hZCk7XG5cdFx0XHRcdH1lbHNlIGlmKHBsdWdpbi5sb2FkUSl7XG5cdFx0XHRcdFx0cGx1Z2luLmxvYWRRLnB1c2gobW9kdWxlKTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0Ly8gdGhlIHVuc2hpZnQgaW5zdGVhZCBvZiBwdXNoIGlzIGltcG9ydGFudDogd2UgZG9uJ3Qgd2FudCBwbHVnaW5zIHRvIGV4ZWN1dGUgYXNcblx0XHRcdFx0XHQvLyBkZXBlbmRlbmNpZXMgb2Ygc29tZSBvdGhlciBtb2R1bGUgYmVjYXVzZSB0aGlzIG1heSBjYXVzZSBjaXJjbGVzIHdoZW4gdGhlIHBsdWdpblxuXHRcdFx0XHRcdC8vIGxvYWRRIGlzIHJ1bjsgYWxzbywgZ2VuZXJhbGx5LCB3ZSB3YW50IHBsdWdpbnMgdG8gcnVuIGVhcmx5IHNpbmNlIHRoZXkgbWF5IGxvYWRcblx0XHRcdFx0XHQvLyBzZXZlcmFsIG90aGVyIG1vZHVsZXMgYW5kIHRoZXJlZm9yZSBjYW4gcG90ZW50aWFsbHkgdW5ibG9jayBtYW55IG1vZHVsZXNcblx0XHRcdFx0XHRwbHVnaW4ubG9hZFEgPSBbbW9kdWxlXTtcblx0XHRcdFx0XHRleGVjUS51bnNoaWZ0KHBsdWdpbik7XG5cdFx0XHRcdFx0aW5qZWN0TW9kdWxlKHBsdWdpbik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIGZvciBJRSwgaW5qZWN0aW5nIGEgbW9kdWxlIG1heSByZXN1bHQgaW4gYSByZWN1cnNpdmUgZXhlY3V0aW9uIGlmIHRoZSBtb2R1bGUgaXMgaW4gdGhlIGNhY2hlXG5cblx0XHRcdGNhY2hlZCA9IDAsXG5cblx0XHRcdGluamVjdGluZ01vZHVsZSA9IDAsXG5cblx0XHRcdGluamVjdGluZ0NhY2hlZE1vZHVsZSA9IDAsXG5cblx0XHRcdGV2YWxNb2R1bGVUZXh0ID0gZnVuY3Rpb24odGV4dCwgbW9kdWxlKXtcblx0XHRcdFx0Ly8gc2VlIGRlZigpIGZvciB0aGUgaW5qZWN0aW5nQ2FjaGVkTW9kdWxlIGJyYWNrZXQ7IGl0IHNpbXBseSBjYXVzZXMgYSBzaG9ydCwgc2FmZSBjaXJjdWl0XG5cdFx0XHRcdGlmKCAwICl7XG5cdFx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvKFtcIiddKXVzZSBzdHJpY3RcXDEvZywgJycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluamVjdGluZ0NhY2hlZE1vZHVsZSA9IDE7XG5cdFx0XHRcdGlmKCAwICl7XG5cdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0aWYodGV4dD09PWNhY2hlZCl7XG5cdFx0XHRcdFx0XHRcdGNhY2hlZC5jYWxsKG51bGwpO1xuXHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdHJlcS5ldmFsKHRleHQsICAwICA/IG1vZHVsZS51cmwgOiBtb2R1bGUubWlkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9Y2F0Y2goZSl7XG5cdFx0XHRcdFx0XHRzaWduYWwoZXJyb3IsIG1ha2VFcnJvcihcImV2YWxNb2R1bGVUaHJld1wiLCBtb2R1bGUpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdGlmKHRleHQ9PT1jYWNoZWQpe1xuXHRcdFx0XHRcdFx0Y2FjaGVkLmNhbGwobnVsbCk7XG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRyZXEuZXZhbCh0ZXh0LCAgMCAgPyBtb2R1bGUudXJsIDogbW9kdWxlLm1pZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGluamVjdGluZ0NhY2hlZE1vZHVsZSA9IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHRpbmplY3RNb2R1bGUgPSBmdW5jdGlvbihtb2R1bGUpe1xuXHRcdFx0XHQvLyBJbmplY3QgdGhlIG1vZHVsZS4gSW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQsIHRoaXMgbWVhbnMgYXBwZW5kaW5nIGEgc2NyaXB0IGVsZW1lbnQgaW50b1xuXHRcdFx0XHQvLyB0aGUgZG9jdW1lbnQ7IGluIG90aGVyIGVudmlyb25tZW50cywgaXQgbWVhbnMgbG9hZGluZyBhIGZpbGUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIElmIGluIHN5bmNocm9ub3VzIG1vZGUsIHRoZW4gZ2V0IHRoZSBtb2R1bGUgc3luY2hyb25vdXNseSBpZiBpdCdzIG5vdCB4ZG9tYWluTG9hZGluZy5cblxuXHRcdFx0XHR2YXIgbWlkID0gbW9kdWxlLm1pZCxcblx0XHRcdFx0XHR1cmwgPSBtb2R1bGUudXJsO1xuXHRcdFx0XHRpZihtb2R1bGUuZXhlY3V0ZWQgfHwgbW9kdWxlLmluamVjdGVkIHx8IHdhaXRpbmdbbWlkXSB8fCAobW9kdWxlLnVybCAmJiAoKG1vZHVsZS5wYWNrICYmIHdhaXRpbmdbbW9kdWxlLnVybF09PT1tb2R1bGUucGFjaykgfHwgd2FpdGluZ1ttb2R1bGUudXJsXT09MSkpKXtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0UmVxdWVzdGVkKG1vZHVsZSk7XG5cblx0XHRcdFx0aWYoIDAgKXtcblx0XHRcdFx0XHR2YXIgdmlhQ29tYm8gPSAwO1xuXHRcdFx0XHRcdGlmKG1vZHVsZS5wbHVnaW4gJiYgbW9kdWxlLnBsdWdpbi5pc0NvbWJvKXtcblx0XHRcdFx0XHRcdC8vIGEgY29tYm8gcGx1Z2luOyB0aGVyZWZvcmUsIG11c3QgYmUgaGFuZGxlZCBieSBjb21ibyBzZXJ2aWNlXG5cdFx0XHRcdFx0XHQvLyB0aGUgcHJpZCBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gY29udmVydGVkIHRvIGEgVVJMIChpZiByZXF1aXJlZCBieSB0aGUgcGx1Z2luKSBkdXJpbmdcblx0XHRcdFx0XHRcdC8vIHRoZSBub3JtYWxpemUgcHJvY2VzczsgaW4gYW55IGV2ZW50LCB0aGVyZSBpcyBubyB3YXkgZm9yIHRoZSBsb2FkZXIgdG8ga25vdyBob3cgdG9cblx0XHRcdFx0XHRcdC8vIHRvIHRoZSBjb252ZXJzaW9uOyB0aGVyZWZvcmUgdGhlIHRoaXJkIGFyZ3VtZW50IGlzIHplcm9cblx0XHRcdFx0XHRcdHJlcS5jb21iby5hZGQobW9kdWxlLnBsdWdpbi5taWQsIG1vZHVsZS5wcmlkLCAwLCByZXEpO1xuXHRcdFx0XHRcdFx0dmlhQ29tYm8gPSAxO1xuXHRcdFx0XHRcdH1lbHNlIGlmKCFtb2R1bGUucGx1Z2luKXtcblx0XHRcdFx0XHRcdHZpYUNvbWJvID0gcmVxLmNvbWJvLmFkZCgwLCBtb2R1bGUubWlkLCBtb2R1bGUudXJsLCByZXEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZih2aWFDb21ibyl7XG5cdFx0XHRcdFx0XHRjb21ib1BlbmRpbmc9IDE7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYobW9kdWxlLnBsdWdpbil7XG5cdFx0XHRcdFx0aW5qZWN0UGx1Z2luKG1vZHVsZSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IC8vIGVsc2UgYSBub3JtYWwgbW9kdWxlIChub3QgYSBwbHVnaW4pXG5cblxuXHRcdFx0XHR2YXIgb25Mb2FkQ2FsbGJhY2sgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdHJ1bkRlZlEobW9kdWxlKTtcblx0XHRcdFx0XHRpZihtb2R1bGUuaW5qZWN0ZWQgIT09IGFycml2ZWQpe1xuXHRcdFx0XHRcdFx0Ly8gdGhlIHNjcmlwdCB0aGF0IGNvbnRhaW5lZCB0aGUgbW9kdWxlIGFycml2ZWQgYW5kIGhhcyBiZWVuIGV4ZWN1dGVkIHlldFxuXHRcdFx0XHRcdFx0Ly8gbm90aGluZyB3YXMgYWRkZWQgdG8gdGhlIGRlZlEgKHNvIGl0IHdhc24ndCBhbiBBTUQgbW9kdWxlKSBhbmQgdGhlIG1vZHVsZVxuXHRcdFx0XHRcdFx0Ly8gd2Fzbid0IG1hcmtlZCBhcyBhcnJpdmVkIGJ5IGRvam8ucHJvdmlkZSAoc28gaXQgd2Fzbid0IGEgdjEuNi0gbW9kdWxlKTtcblx0XHRcdFx0XHRcdC8vIHRoZXJlZm9yZSwgaXQgbXVzdCBub3QgaGF2ZSBiZWVuIGEgbW9kdWxlOyBhZGp1c3Qgc3RhdGUgYWNjb3JkaW5nbHlcblx0XHRcdFx0XHRcdGlmKCAwICl7XG5cdFx0XHRcdFx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwibm9EZWZpbmVcIiwgbW9kdWxlKSk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNldEFycml2ZWQobW9kdWxlKTtcblx0XHRcdFx0XHRcdG1peChtb2R1bGUsIG5vbk1vZHVsZVByb3BzKTtcblx0XHRcdFx0XHRcdHJlcS50cmFjZShcImxvYWRlci1kZWZpbmUtbm9ubW9kdWxlXCIsIFttb2R1bGUudXJsXSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoIDAgICYmIGxlZ2FjeU1vZGUpe1xuXHRcdFx0XHRcdFx0Ly8gbXVzdCBjYWxsIGNoZWNrQ29tcGxldGUgZXZlbiBpbiBmb3Igc3luYyBsb2FkZXIgYmVjYXVzZSB3ZSBtYXkgYmUgaW4geGRvbWFpbkxvYWRpbmcgbW9kZTtcblx0XHRcdFx0XHRcdC8vIGJ1dCwgaWYgeGQgbG9hZGluZywgdGhlbiBkb24ndCBjYWxsIGNoZWNrQ29tcGxldGUgdW50aWwgb3V0IG9mIHRoZSBjdXJyZW50IHN5bmMgdHJhdmVyc2FsXG5cdFx0XHRcdFx0XHQvLyBpbiBvcmRlciB0byBwcmVzZXJ2ZSBvcmRlciBvZiBleGVjdXRpb24gb2YgdGhlIGRvam8ucmVxdWlyZWQgbW9kdWxlc1xuXHRcdFx0XHRcdFx0IXN5bmNFeGVjU3RhY2subGVuZ3RoICYmIGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdGNhY2hlZCA9IGNhY2hlW21pZF0gfHwgY2FjaGVbdXJsS2V5UHJlZml4ICsgbW9kdWxlLnVybF07XG5cdFx0XHRcdGlmKGNhY2hlZCl7XG5cdFx0XHRcdFx0cmVxLnRyYWNlKFwibG9hZGVyLWluamVjdFwiLCBbXCJjYWNoZVwiLCBtb2R1bGUubWlkLCB1cmxdKTtcblx0XHRcdFx0XHRldmFsTW9kdWxlVGV4dChjYWNoZWQsIG1vZHVsZSk7XG5cdFx0XHRcdFx0b25Mb2FkQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIDAgICYmIGxlZ2FjeU1vZGUpe1xuXHRcdFx0XHRcdGlmKG1vZHVsZS5pc1hkKXtcblx0XHRcdFx0XHRcdC8vIHN3aXRjaCB0byBhc3luYyBtb2RlIHRlbXBvcmFyaWx5OyBpZiBjdXJyZW50IGxlZ2FjeU1vZGUhPXN5bmMsIHRoZW4gaXMgbXVzdCBiZSBvbmUgb2Yge2xlZ2FjeUFzeW5jLCB4ZCwgZmFsc2V9XG5cdFx0XHRcdFx0XHRsZWdhY3lNb2RlPT1zeW5jICYmIChsZWdhY3lNb2RlID0geGQpO1xuXHRcdFx0XHRcdFx0Ly8gZmFsbCB0aHJvdWdoIGFuZCBsb2FkIHZpYSBzY3JpcHQgaW5qZWN0aW9uXG5cdFx0XHRcdFx0fWVsc2UgaWYobW9kdWxlLmlzQW1kICYmIGxlZ2FjeU1vZGUhPXN5bmMpe1xuXHRcdFx0XHRcdFx0Ly8gZmFsbCB0aHJvdWdoIGFuZCBsb2FkIHZpYSBzY3JpcHQgaW5qZWN0aW9uXG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHQvLyBtb2RlIG1heSBiZSBzeW5jLCB4ZC9sZWdhY3lBc3luYywgb3IgYXN5bmM7IG1vZHVsZSBtYXkgYmUgQU1EIG9yIGxlZ2FjeTsgYnV0IG1vZHVsZSBpcyBhbHdheXMgbG9jYXRlZCBvbiB0aGUgc2FtZSBkb21haW5cblx0XHRcdFx0XHRcdHZhciB4aHJDYWxsYmFjayA9IGZ1bmN0aW9uKHRleHQpe1xuXHRcdFx0XHRcdFx0XHRpZihsZWdhY3lNb2RlPT1zeW5jKXtcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGUgdG9wIG9mIHN5bmNFeGVjU3RhY2sgZ2l2ZXMgdGhlIGN1cnJlbnQgc3luY2hyb25vdXNseSBleGVjdXRpbmcgbW9kdWxlOyB0aGUgbG9hZGVyIG5lZWRzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdG8ga25vdyB0aGlzIGlmIGl0IGhhcyB0byBzd2l0Y2ggdG8gYXN5bmMgbG9hZGluZyBpbiB0aGUgbWlkZGxlIG9mIGV2YWx1YXRpbmcgYSBsZWdhY3kgbW9kdWxlXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBoYXBwZW5zIHdoZW4gYSBtb2R1bGVzIGRvam8ucmVxdWlyZSdzIGEgbW9kdWxlIHRoYXQgbXVzdCBiZSBsb2FkZWQgYXN5bmMgYmVjYXVzZSBpdCdzIHhkb21haW5cblx0XHRcdFx0XHRcdFx0XHQvLyAodXNpbmcgdW5zaGlmdC9zaGlmdCBiZWNhdXNlIHRoZXJlIGlzIG5vIGJhY2soKSBtZXRob2RzIGZvciBKYXZhc2NyaXB0IGFycmF5cylcblx0XHRcdFx0XHRcdFx0XHRzeW5jRXhlY1N0YWNrLnVuc2hpZnQobW9kdWxlKTtcblx0XHRcdFx0XHRcdFx0XHRldmFsTW9kdWxlVGV4dCh0ZXh0LCBtb2R1bGUpO1xuXHRcdFx0XHRcdFx0XHRcdHN5bmNFeGVjU3RhY2suc2hpZnQoKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIG1heWJlIHRoZSBtb2R1bGUgd2FzIGFuIEFNRCBtb2R1bGVcblx0XHRcdFx0XHRcdFx0XHRydW5EZWZRKG1vZHVsZSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBsZWdhY3kgbW9kdWxlcyBuZXZlciBnZXQgdG8gZGVmaW5lTW9kdWxlKCkgPT4gY2pzIGFuZCBpbmplY3RlZCBuZXZlciBzZXQ7IGFsc28gZXZhbHVhdGlvbiBpbXBsaWVzIGV4ZWN1dGluZ1xuXHRcdFx0XHRcdFx0XHRcdGlmKCFtb2R1bGUuY2pzKXtcblx0XHRcdFx0XHRcdFx0XHRcdHNldEFycml2ZWQobW9kdWxlKTtcblx0XHRcdFx0XHRcdFx0XHRcdGZpbmlzaEV4ZWMobW9kdWxlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRpZihtb2R1bGUuZmluaXNoKXtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHdoaWxlIHN5bmNocm9ub3VzbHkgZXZhbHVhdGluZyB0aGlzIG1vZHVsZSwgZG9qby5yZXF1aXJlIHdhcyBhcHBsaWVkIHJlZmVyZW5jaW5nIGEgbW9kdWxlXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGF0IGhhZCB0byBiZSBsb2FkZWQgYXN5bmM7IHRoZXJlZm9yZSwgdGhlIGxvYWRlciBzdG9wcGVkIGFuc3dlcmluZyBhbGwgZG9qby5yZXF1aXJlXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyByZXF1ZXN0cyBzbyB0aGV5IGNvdWxkIGJlIGFuc3dlcmVkIGNvbXBsZXRlbHkgaW4gdGhlIGNvcnJlY3Qgc2VxdWVuY2U7IG1vZHVsZS5maW5pc2ggZ2l2ZXNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHRoZSBsaXN0IG9mIGRvam8ucmVxdWlyZXMgdGhhdCBtdXN0IGJlIHJlLWFwcGxpZWQgb25jZSBhbGwgdGFyZ2V0IG1vZHVsZXMgYXJlIGF2YWlsYWJsZTtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIG1ha2UgYSBzeW50aGV0aWMgbW9kdWxlIHRvIGV4ZWN1dGUgdGhlIGRvam8ucmVxdWlyZSdzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIGNvbXB1dGUgYSBndWFyYW50ZWVkLXVuaXF1ZSBtaWQgZm9yIHRoZSBzeW50aGV0aWMgZmluaXNoIG1vZHVsZTsgcmVtZW1iZXIgdGhlIGZpbmlzaCB2ZWN0b3I7IHJlbW92ZSBpdCBmcm9tIHRoZSByZWZlcmVuY2UgbW9kdWxlXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBjYW4gd2UganVzdCBsZWF2ZSB0aGUgbW9kdWxlLmZpbmlzaC4uLndoYXQncyBpdCBodXJ0aW5nP1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGZpbmlzaE1pZCA9IG1pZCArIFwiKmZpbmlzaFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaW5pc2ggPSBtb2R1bGUuZmluaXNoO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIG1vZHVsZS5maW5pc2g7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGRlZihmaW5pc2hNaWQsIFtcImRvam9cIiwgKFwiZG9qby9yZXF1aXJlIVwiICsgZmluaXNoLmpvaW4oXCIsXCIpKS5yZXBsYWNlKC9cXC4vZywgXCIvXCIpXSwgZnVuY3Rpb24oZG9qbyl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvckVhY2goZmluaXNoLCBmdW5jdGlvbihtaWQpeyBkb2pvLnJlcXVpcmUobWlkKTsgfSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHVuc2hpZnQsIG5vdCBwdXNoLCB3aGljaCBjYXVzZXMgdGhlIGN1cnJlbnQgdHJhdmVyc2FsIHRvIGJlIHJlYXR0ZW1wdGVkIGZyb20gdGhlIHRvcFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXhlY1EudW5zaGlmdChnZXRNb2R1bGUoZmluaXNoTWlkKSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdG9uTG9hZENhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRcdHRleHQgPSB0cmFuc2Zvcm1Ub0FtZChtb2R1bGUsIHRleHQpO1xuXHRcdFx0XHRcdFx0XHRcdGlmKHRleHQpe1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXZhbE1vZHVsZVRleHQodGV4dCwgbW9kdWxlKTtcblx0XHRcdFx0XHRcdFx0XHRcdG9uTG9hZENhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBpZiB0cmFuc2Zvcm1Ub0FtZCByZXR1cm5lZCBmYWxzeSwgdGhlbiB0aGUgbW9kdWxlIHdhcyBhbHJlYWR5IEFNRCBhbmQgaXQgY2FuIGJlIHNjcmlwdC1pbmplY3RlZFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZG8gc28gdG8gaW1wcm92ZSBkZWJ1Z2FiaWxpdHkoZXZlbiB0aG91Z2ggaXQgbWVhbnMgYW5vdGhlciBkb3dubG9hZC4uLndoaWNoIHByb2JhYmx5IHdvbid0IGhhcHBlbiB3aXRoIGEgZ29vZCBicm93c2VyIGNhY2hlKVxuXHRcdFx0XHRcdFx0XHRcdFx0aW5qZWN0aW5nTW9kdWxlID0gbW9kdWxlO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVxLmluamVjdFVybChmaXh1cFVybCh1cmwpLCBvbkxvYWRDYWxsYmFjaywgbW9kdWxlKTtcblx0XHRcdFx0XHRcdFx0XHRcdGluamVjdGluZ01vZHVsZSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRyZXEudHJhY2UoXCJsb2FkZXItaW5qZWN0XCIsIFtcInhoclwiLCBtb2R1bGUubWlkLCB1cmwsIGxlZ2FjeU1vZGUhPXN5bmNdKTtcblx0XHRcdFx0XHRcdGlmKCAwICl7XG5cdFx0XHRcdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRcdFx0XHRyZXEuZ2V0VGV4dCh1cmwsIGxlZ2FjeU1vZGUhPXN5bmMsIHhockNhbGxiYWNrKTtcblx0XHRcdFx0XHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRcdFx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwieGhySW5qZWN0RmFpbGVkXCIsIFttb2R1bGUsIGVdKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRyZXEuZ2V0VGV4dCh1cmwsIGxlZ2FjeU1vZGUhPXN5bmMsIHhockNhbGxiYWNrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gLy8gZWxzZSBhc3luYyBtb2RlIG9yIGZlbGwgdGhyb3VnaCBpbiB4ZG9tYWluIGxvYWRpbmcgbW9kZTsgZWl0aGVyIHdheSwgbG9hZCBieSBzY3JpcHQgaW5qZWN0aW9uXG5cdFx0XHRcdHJlcS50cmFjZShcImxvYWRlci1pbmplY3RcIiwgW1wic2NyaXB0XCIsIG1vZHVsZS5taWQsIHVybF0pO1xuXHRcdFx0XHRpbmplY3RpbmdNb2R1bGUgPSBtb2R1bGU7XG5cdFx0XHRcdHJlcS5pbmplY3RVcmwoZml4dXBVcmwodXJsKSwgb25Mb2FkQ2FsbGJhY2ssIG1vZHVsZSk7XG5cdFx0XHRcdGluamVjdGluZ01vZHVsZSA9IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHRkZWZpbmVNb2R1bGUgPSBmdW5jdGlvbihtb2R1bGUsIGRlcHMsIGRlZil7XG5cdFx0XHRcdHJlcS50cmFjZShcImxvYWRlci1kZWZpbmUtbW9kdWxlXCIsIFttb2R1bGUubWlkLCBkZXBzXSk7XG5cblx0XHRcdFx0aWYoIDAgICYmIG1vZHVsZS5wbHVnaW4gJiYgbW9kdWxlLnBsdWdpbi5pc0NvbWJvKXtcblx0XHRcdFx0XHQvLyB0aGUgbW9kdWxlIGlzIGEgcGx1Z2luIHJlc291cmNlIGxvYWRlZCBieSB0aGUgY29tYm8gc2VydmljZVxuXHRcdFx0XHRcdC8vIG5vdGU6IGNoZWNrIGZvciBtb2R1bGUucGx1Z2luIHNob3VsZCBiZSBlbm91Z2ggc2luY2Ugbm9ybWFsIHBsdWdpbiByZXNvdXJjZXMgc2hvdWxkXG5cdFx0XHRcdFx0Ly8gbm90IGZvbGxvdyB0aGlzIHBhdGg7IG1vZHVsZS5wbHVnaW4uaXNDb21ibyBpcyBmdXR1cmUtcHJvb2ZpbmcgYmVsdCBhbmQgc3VzcGVuZGVyc1xuXHRcdFx0XHRcdG1vZHVsZS5yZXN1bHQgPSBpc0Z1bmN0aW9uKGRlZikgPyBkZWYoKSA6IGRlZjtcblx0XHRcdFx0XHRzZXRBcnJpdmVkKG1vZHVsZSk7XG5cdFx0XHRcdFx0ZmluaXNoRXhlYyhtb2R1bGUpO1xuXHRcdFx0XHRcdHJldHVybiBtb2R1bGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbWlkID0gbW9kdWxlLm1pZDtcblx0XHRcdFx0aWYobW9kdWxlLmluamVjdGVkID09PSBhcnJpdmVkKXtcblx0XHRcdFx0XHRzaWduYWwoZXJyb3IsIG1ha2VFcnJvcihcIm11bHRpcGxlRGVmaW5lXCIsIG1vZHVsZSkpO1xuXHRcdFx0XHRcdHJldHVybiBtb2R1bGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWl4KG1vZHVsZSwge1xuXHRcdFx0XHRcdGRlcHM6IGRlcHMsXG5cdFx0XHRcdFx0ZGVmOiBkZWYsXG5cdFx0XHRcdFx0Y2pzOiB7XG5cdFx0XHRcdFx0XHRpZDogbW9kdWxlLm1pZCxcblx0XHRcdFx0XHRcdHVyaTogbW9kdWxlLnVybCxcblx0XHRcdFx0XHRcdGV4cG9ydHM6IChtb2R1bGUucmVzdWx0ID0ge30pLFxuXHRcdFx0XHRcdFx0c2V0RXhwb3J0czogZnVuY3Rpb24oZXhwb3J0cyl7XG5cdFx0XHRcdFx0XHRcdG1vZHVsZS5janMuZXhwb3J0cyA9IGV4cG9ydHM7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0Y29uZmlnOmZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBtb2R1bGUuY29uZmlnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gcmVzb2x2ZSBkZXBzIHdpdGggcmVzcGVjdCB0byB0aGlzIG1vZHVsZVxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBkZXBzW2ldOyBpKyspe1xuXHRcdFx0XHRcdGRlcHNbaV0gPSBnZXRNb2R1bGUoZGVwc1tpXSwgbW9kdWxlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmKCAwICAmJiBsZWdhY3lNb2RlICYmICF3YWl0aW5nW21pZF0pe1xuXHRcdFx0XHRcdC8vIHRoZSBtb2R1bGUgc2hvd2VkIHVwIHdpdGhvdXQgYmVpbmcgYXNrZWQgZm9yOyBpdCB3YXMgcHJvYmFibHkgaW4gYSA8c2NyaXB0PiBlbGVtZW50XG5cdFx0XHRcdFx0aW5qZWN0RGVwZW5kZW5jaWVzKG1vZHVsZSk7XG5cdFx0XHRcdFx0ZXhlY1EucHVzaChtb2R1bGUpO1xuXHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRBcnJpdmVkKG1vZHVsZSk7XG5cblx0XHRcdFx0aWYoIWlzRnVuY3Rpb24oZGVmKSAmJiAhZGVwcy5sZW5ndGgpe1xuXHRcdFx0XHRcdG1vZHVsZS5yZXN1bHQgPSBkZWY7XG5cdFx0XHRcdFx0ZmluaXNoRXhlYyhtb2R1bGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1vZHVsZTtcblx0XHRcdH0sXG5cblx0XHRcdHJ1bkRlZlEgPSBmdW5jdGlvbihyZWZlcmVuY2VNb2R1bGUsIG1pZHMpe1xuXHRcdFx0XHQvLyBkZWZRIGlzIGFuIGFycmF5IG9mIFtpZCwgZGVwZW5kZW5jaWVzLCBmYWN0b3J5XVxuXHRcdFx0XHQvLyBtaWRzIChpZiBhbnkpIGlzIGEgdmVjdG9yIG9mIG1pZHMgZ2l2ZW4gYnkgYSBjb21ibyBzZXJ2aWNlXG5cdFx0XHRcdHZhciBkZWZpbmVkTW9kdWxlcyA9IFtdLFxuXHRcdFx0XHRcdG1vZHVsZSwgYXJncztcblx0XHRcdFx0d2hpbGUoZGVmUS5sZW5ndGgpe1xuXHRcdFx0XHRcdGFyZ3MgPSBkZWZRLnNoaWZ0KCk7XG5cdFx0XHRcdFx0bWlkcyAmJiAoYXJnc1swXT0gbWlkcy5zaGlmdCgpKTtcblx0XHRcdFx0XHQvLyBleHBsaWNpdCBkZWZpbmUgaW5kaWNhdGVzIHBvc3NpYmxlIG11bHRpcGxlIG1vZHVsZXMgaW4gYSBzaW5nbGUgZmlsZTsgZGVsYXkgaW5qZWN0aW5nIGRlcGVuZGVuY2llcyB1bnRpbCBkZWZRIGZ1bGx5XG5cdFx0XHRcdFx0Ly8gcHJvY2Vzc2VkIHNpbmNlIG1vZHVsZXMgZWFybGllciBpbiB0aGUgcXVldWUgZGVwZW5kIG9uIGFscmVhZHktYXJyaXZlZCBtb2R1bGVzIHRoYXQgYXJlIGxhdGVyIGluIHRoZSBxdWV1ZVxuXHRcdFx0XHRcdC8vIFRPRE86IHdoYXQgaWYgbm8gYXJnc1swXSBhbmQgbm8gcmVmZXJlbmNlTW9kdWxlXG5cdFx0XHRcdFx0bW9kdWxlID0gKGFyZ3NbMF0gJiYgZ2V0TW9kdWxlKGFyZ3NbMF0pKSB8fCByZWZlcmVuY2VNb2R1bGU7XG5cdFx0XHRcdFx0ZGVmaW5lZE1vZHVsZXMucHVzaChbbW9kdWxlLCBhcmdzWzFdLCBhcmdzWzJdXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3VtZVBlbmRpbmdDYWNoZUluc2VydChyZWZlcmVuY2VNb2R1bGUpO1xuXHRcdFx0XHRmb3JFYWNoKGRlZmluZWRNb2R1bGVzLCBmdW5jdGlvbihhcmdzKXtcblx0XHRcdFx0XHRpbmplY3REZXBlbmRlbmNpZXMoZGVmaW5lTW9kdWxlLmFwcGx5KG51bGwsIGFyZ3MpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXHR9XG5cblx0dmFyIHRpbWVySWQgPSAwLFxuXHRcdGNsZWFyVGltZXIgPSBub29wLFxuXHRcdHN0YXJ0VGltZXIgPSBub29wO1xuXHRpZiggMCApe1xuXHRcdC8vIFRpbWVyIG1hY2hpbmVyeSB0aGF0IG1vbml0b3JzIGhvdyBsb25nIHRoZSBsb2FkZXIgaXMgd2FpdGluZyBhbmQgc2lnbmFscyBhbiBlcnJvciB3aGVuIHRoZSB0aW1lciBydW5zIG91dC5cblx0XHRjbGVhclRpbWVyID0gZnVuY3Rpb24oKXtcblx0XHRcdHRpbWVySWQgJiYgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuXHRcdFx0dGltZXJJZCA9IDA7XG5cdFx0fTtcblxuXHRcdHN0YXJ0VGltZXIgPSBmdW5jdGlvbigpe1xuXHRcdFx0Y2xlYXJUaW1lcigpO1xuXHRcdFx0aWYocmVxLndhaXRtcyl7XG5cdFx0XHRcdHRpbWVySWQgPSBnbG9iYWwuc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGNsZWFyVGltZXIoKTtcblx0XHRcdFx0XHRzaWduYWwoZXJyb3IsIG1ha2VFcnJvcihcInRpbWVvdXRcIiwgd2FpdGluZykpO1xuXHRcdFx0XHR9LCByZXEud2FpdG1zKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0aWYgKCAwICkge1xuXHRcdC8vIFRlc3QgZm9yIElFJ3MgZGlmZmVyZW50IHdheSBvZiBzaWduYWxpbmcgd2hlbiBzY3JpcHRzIGZpbmlzaCBsb2FkaW5nLiAgTm90ZSB0aGF0IGFjY29yZGluZyB0b1xuXHRcdC8vIGh0dHA6Ly9idWdzLmRvam90b29sa2l0Lm9yZy90aWNrZXQvMTUwOTYjY29tbWVudDoxNCwgSUU5IGFsc28gbmVlZHMgdG8gZm9sbG93IHRoZVxuXHRcdC8vIElFIHNwZWNpZmljIGNvZGUgcGF0aCBldmVuIHRob3VnaCBpdCBoYXMgYW4gYWRkRXZlbnRMaXN0ZW5lcigpIG1ldGhvZC5cblx0XHQvLyBVbmtub3duIGlmIHNwZWNpYWwgcGF0aCBuZWVkZWQgb24gSUUxMCssIHdoaWNoIGFsc28gaGFzIGEgZG9jdW1lbnQuYXR0YWNoRXZlbnQoKSBtZXRob2QuXG5cdFx0Ly8gU2hvdWxkIGV2YWx1YXRlIHRvIGZhbHNlIGZvciBPcGVyYSBhbmQgV2luZG93cyA4IGFwcHMsIGV2ZW4gdGhvdWdoIHRoZXkgZG9jdW1lbnQuYXR0YWNoRXZlbnQoKVxuXHRcdC8vICBpcyBkZWZpbmVkIGluIGJvdGggdGhvc2UgZW52aXJvbm1lbnRzLlxuXHRcdCAwICYmIGhhcy5hZGQoXCJpZS1ldmVudC1iZWhhdmlvclwiLCBkb2MuYXR0YWNoRXZlbnQgJiYgdHlwZW9mIFdpbmRvd3MgPT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdCh0eXBlb2Ygb3BlcmEgPT09IFwidW5kZWZpbmVkXCIgfHwgb3BlcmEudG9TdHJpbmcoKSAhPSBcIltvYmplY3QgT3BlcmFdXCIpKTtcblx0fVxuXG5cdGlmKCAwICAmJiAoIGZhbHNlICB8fCAgMSApKXtcblx0XHR2YXIgZG9tT24gPSBmdW5jdGlvbihub2RlLCBldmVudE5hbWUsIGllRXZlbnROYW1lLCBoYW5kbGVyKXtcblx0XHRcdFx0Ly8gQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGEgRE9NIG5vZGUgdXNpbmcgdGhlIEFQSSBhcHByb3ByaWF0ZSBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlcjtcblx0XHRcdFx0Ly8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGRpc2Nvbm5lY3QgdGhlIGxpc3RlbmVyLlxuXHRcdFx0XHRpZighIDAgKXtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0bm9kZS5hdHRhY2hFdmVudChpZUV2ZW50TmFtZSwgaGFuZGxlcik7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRub2RlLmRldGFjaEV2ZW50KGllRXZlbnROYW1lLCBoYW5kbGVyKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0d2luZG93T25Mb2FkTGlzdGVuZXIgPSBkb21Pbih3aW5kb3csIFwibG9hZFwiLCBcIm9ubG9hZFwiLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRyZXEucGFnZUxvYWRlZCA9IDE7XG5cdFx0XHRcdC8vIGh0dHBzOi8vYnVncy5kb2pvdG9vbGtpdC5vcmcvdGlja2V0LzE2MjQ4XG5cdFx0XHRcdHRyeXtcblx0XHRcdFx0XHRkb2MucmVhZHlTdGF0ZSE9XCJjb21wbGV0ZVwiICYmIChkb2MucmVhZHlTdGF0ZSA9IFwiY29tcGxldGVcIik7XG5cdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0fVxuXHRcdFx0XHR3aW5kb3dPbkxvYWRMaXN0ZW5lcigpO1xuXHRcdFx0fSk7XG5cblx0XHRpZiggZmFsc2UgKXtcblx0XHRcdC8vIGlmIHRoZSBsb2FkZXIgaXMgb24gdGhlIHBhZ2UsIHRoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIHNjcmlwdCBlbGVtZW50XG5cdFx0XHQvLyBnZXR0aW5nIGl0cyBwYXJlbnQgYW5kIHRoZW4gZG9pbmcgaW5zZXJ0QmVmb3JlIHNvbHZlcyB0aGUgXCJPcGVyYXRpb24gQWJvcnRlZFwiXG5cdFx0XHQvLyBlcnJvciBpbiBJRSBmcm9tIGFwcGVuZGluZyB0byBhIG5vZGUgdGhhdCBpc24ndCBwcm9wZXJseSBjbG9zZWQ7IHNlZVxuXHRcdFx0Ly8gZG9qby90ZXN0cy9fYmFzZS9sb2FkZXIvcmVxdWlyZWpzL3NpbXBsZS1iYWRiYXNlLmh0bWwgZm9yIGFuIGV4YW1wbGVcblx0XHRcdC8vIGRvbid0IHVzZSBzY3JpcHRzIHdpdGggdHlwZSBkb2pvLy4uLiBzaW5jZSB0aGVzZSBtYXkgYmUgcmVtb3ZlZDsgc2VlICMxNTgwOVxuXHRcdFx0Ly8gcHJlZmVyIHRvIHVzZSB0aGUgaW5zZXJ0UG9pbnQgY29tcHV0ZWQgZHVyaW5nIHRoZSBjb25maWcgc25pZmYgaW4gY2FzZSBhIHNjcmlwdCBpcyByZW1vdmVkOyBzZWUgIzE2OTU4XG5cdFx0XHR2YXIgc2NyaXB0cyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdHNjcmlwdDtcblx0XHRcdHdoaWxlKCFpbnNlcnRQb2ludFNpYmxpbmcpe1xuXHRcdFx0XHRpZighL15kb2pvLy50ZXN0KChzY3JpcHQgPSBzY3JpcHRzW2krK10pICYmIHNjcmlwdC50eXBlKSl7XG5cdFx0XHRcdFx0aW5zZXJ0UG9pbnRTaWJsaW5nPSBzY3JpcHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmVxLmluamVjdFVybCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIG93bmVyKXtcblx0XHRcdFx0Ly8gaW5zZXJ0IGEgc2NyaXB0IGVsZW1lbnQgdG8gdGhlIGluc2VydC1wb2ludCBlbGVtZW50IHdpdGggc3JjPXVybDtcblx0XHRcdFx0Ly8gYXBwbHkgY2FsbGJhY2sgdXBvbiBkZXRlY3RpbmcgdGhlIHNjcmlwdCBoYXMgbG9hZGVkLlxuXG5cdFx0XHRcdHZhciBub2RlID0gb3duZXIubm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpLFxuXHRcdFx0XHRcdG9uTG9hZCA9IGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXHRcdFx0XHRcdFx0dmFyIG5vZGUgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG5cdFx0XHRcdFx0XHRpZihlLnR5cGUgPT09IFwibG9hZFwiIHx8IC9jb21wbGV0ZXxsb2FkZWQvLnRlc3Qobm9kZS5yZWFkeVN0YXRlKSl7XG5cdFx0XHRcdFx0XHRcdGxvYWREaXNjb25uZWN0b3IoKTtcblx0XHRcdFx0XHRcdFx0ZXJyb3JEaXNjb25uZWN0b3IoKTtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGxvYWREaXNjb25uZWN0b3IgPSBkb21Pbihub2RlLCBcImxvYWRcIiwgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgb25Mb2FkKSxcblx0XHRcdFx0XHRlcnJvckRpc2Nvbm5lY3RvciA9IGRvbU9uKG5vZGUsIFwiZXJyb3JcIiwgXCJvbmVycm9yXCIsIGZ1bmN0aW9uKGUpe1xuXHRcdFx0XHRcdFx0bG9hZERpc2Nvbm5lY3RvcigpO1xuXHRcdFx0XHRcdFx0ZXJyb3JEaXNjb25uZWN0b3IoKTtcblx0XHRcdFx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwic2NyaXB0RXJyb3I6IFwiICsgdXJsLCBbdXJsLCBlXSkpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdG5vZGUudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG5cdFx0XHRcdG5vZGUuY2hhcnNldCA9IFwidXRmLThcIjtcblx0XHRcdFx0bm9kZS5zcmMgPSB1cmw7XG5cdFx0XHRcdGluc2VydFBvaW50U2libGluZy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBpbnNlcnRQb2ludFNpYmxpbmcpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0aWYoIDAgKXtcblx0XHRyZXEubG9nID0gZnVuY3Rpb24oKXtcblx0XHRcdHRyeXtcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYXJndW1lbnRzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fWNhdGNoKGUpe31cblx0XHR9O1xuXHR9ZWxzZXtcblx0XHRyZXEubG9nID0gbm9vcDtcblx0fVxuXG5cdGlmKCAwICl7XG5cdFx0dmFyIHRyYWNlID0gcmVxLnRyYWNlID0gZnVuY3Rpb24oXG5cdFx0XHRncm91cCxcdC8vIHRoZSB0cmFjZSBncm91cCB0byB3aGljaCB0aGlzIGFwcGxpY2F0aW9uIGJlbG9uZ3Ncblx0XHRcdGFyZ3NcdC8vIHRoZSBjb250ZW50cyBvZiB0aGUgdHJhY2Vcblx0XHQpe1xuXHRcdFx0Ly8vXG5cdFx0XHQvLyBUcmFjaW5nIGludGVyZmFjZSBieSBncm91cC5cblx0XHRcdC8vXG5cdFx0XHQvLyBTZW5kcyB0aGUgY29udGVudHMgb2YgYXJncyB0byB0aGUgY29uc29sZSBpZmYgKHJlcS50cmFjZS5vbiAmJiByZXEudHJhY2VbZ3JvdXBdKVxuXG5cdFx0XHRpZih0cmFjZS5vbiAmJiB0cmFjZS5ncm91cFtncm91cF0pe1xuXHRcdFx0XHRzaWduYWwoXCJ0cmFjZVwiLCBbZ3JvdXAsIGFyZ3NdKTtcblx0XHRcdFx0Zm9yKHZhciBhcmcsIGR1bXAgPSBbXSwgdGV4dD0gXCJ0cmFjZTpcIiArIGdyb3VwICsgKGFyZ3MubGVuZ3RoID8gKFwiOlwiICsgYXJnc1swXSkgOiBcIlwiKSwgaT0gMTsgaTxhcmdzLmxlbmd0aDspe1xuXHRcdFx0XHRcdGFyZyA9IGFyZ3NbaSsrXTtcblx0XHRcdFx0XHRpZihpc1N0cmluZyhhcmcpKXtcblx0XHRcdFx0XHRcdHRleHQgKz0gXCIsIFwiICsgYXJnO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0ZHVtcC5wdXNoKGFyZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJlcS5sb2codGV4dCk7XG5cdFx0XHRcdGR1bXAubGVuZ3RoICYmIGR1bXAucHVzaChcIi5cIik7XG5cdFx0XHRcdHJlcS5sb2cuYXBwbHkocmVxLCBkdW1wKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdG1peCh0cmFjZSwge1xuXHRcdFx0b246MSxcblx0XHRcdGdyb3VwOnt9LFxuXHRcdFx0c2V0OmZ1bmN0aW9uKGdyb3VwLCB2YWx1ZSl7XG5cdFx0XHRcdGlmKGlzU3RyaW5nKGdyb3VwKSl7XG5cdFx0XHRcdFx0dHJhY2UuZ3JvdXBbZ3JvdXBdPSB2YWx1ZTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0bWl4KHRyYWNlLmdyb3VwLCBncm91cCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHR0cmFjZS5zZXQobWl4KG1peChtaXgoe30sIGRlZmF1bHRDb25maWcudHJhY2UpLCB1c2VyQ29uZmlnLnRyYWNlKSwgZG9qb1NuaWZmQ29uZmlnLnRyYWNlKSk7XG5cdFx0b24oXCJjb25maWdcIiwgZnVuY3Rpb24oY29uZmlnKXtcblx0XHRcdGNvbmZpZy50cmFjZSAmJiB0cmFjZS5zZXQoY29uZmlnLnRyYWNlKTtcblx0XHR9KTtcblx0fWVsc2V7XG5cdFx0cmVxLnRyYWNlID0gbm9vcDtcblx0fVxuXHRpZiAoISAxICkge1xuXHRcdHZhciBkZWYgPSBmdW5jdGlvbihcblx0XHRcdG1pZCxcdFx0ICAvLyhjb21tb25qcy5tb2R1bGVJZCwgb3B0aW9uYWwpXG5cdFx0XHRkZXBlbmRlbmNpZXMsIC8vKGFycmF5IG9mIGNvbW1vbmpzLm1vZHVsZUlkLCBvcHRpb25hbCkgbGlzdCBvZiBtb2R1bGVzIHRvIGJlIGxvYWRlZCBiZWZvcmUgcnVubmluZyBmYWN0b3J5XG5cdFx0XHRmYWN0b3J5XHRcdCAgLy8oYW55KVxuXHRcdCl7XG5cdFx0XHQvLy9cblx0XHRcdC8vIEFkdmlzZXMgdGhlIGxvYWRlciBvZiBhIG1vZHVsZSBmYWN0b3J5LiAvL0ltcGxlbWVudHMgaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvTW9kdWxlcy9Bc3luY2hyb25vdXNEZWZpbml0aW9uLlxuXHRcdFx0Ly8vXG5cdFx0XHQvL25vdGVcblx0XHRcdC8vIENvbW1vbkpTIGZhY3Rvcnkgc2NhbiBjb3VydGVzeSBvZiBodHRwOi8vcmVxdWlyZWpzLm9yZ1xuXG5cdFx0XHR2YXIgYXJpdHkgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0XHRkZWZhdWx0RGVwcyA9IFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwibW9kdWxlXCJdLFxuXHRcdFx0XHQvLyB0aGUgcHJlZG9taW5hdGUgc2lnbmF0dXJlLi4uXG5cdFx0XHRcdGFyZ3MgPSBbMCwgbWlkLCBkZXBlbmRlbmNpZXNdO1xuXHRcdFx0aWYoYXJpdHk9PTEpe1xuXHRcdFx0XHRhcmdzID0gWzAsIChpc0Z1bmN0aW9uKG1pZCkgPyBkZWZhdWx0RGVwcyA6IFtdKSwgbWlkXTtcblx0XHRcdH1lbHNlIGlmKGFyaXR5PT0yICYmIGlzU3RyaW5nKG1pZCkpe1xuXHRcdFx0XHRhcmdzID0gW21pZCwgKGlzRnVuY3Rpb24oZGVwZW5kZW5jaWVzKSA/IGRlZmF1bHREZXBzIDogW10pLCBkZXBlbmRlbmNpZXNdO1xuXHRcdFx0fWVsc2UgaWYoYXJpdHk9PTMpe1xuXHRcdFx0XHRhcmdzID0gW21pZCwgZGVwZW5kZW5jaWVzLCBmYWN0b3J5XTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIDAgICYmIGFyZ3NbMV09PT1kZWZhdWx0RGVwcyl7XG5cdFx0XHRcdGFyZ3NbMl0udG9TdHJpbmcoKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC8oXFwvXFwqKFtcXHNcXFNdKj8pXFwqXFwvfFxcL1xcLyguKikkKS9tZywgXCJcIilcblx0XHRcdFx0XHQucmVwbGFjZSgvcmVxdWlyZVxcKFtcIiddKFtcXHdcXCFcXC1fXFwuXFwvXSspW1wiJ11cXCkvZywgZnVuY3Rpb24obWF0Y2gsIGRlcCl7XG5cdFx0XHRcdFx0YXJnc1sxXS5wdXNoKGRlcCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXEudHJhY2UoXCJsb2FkZXItZGVmaW5lXCIsIGFyZ3Muc2xpY2UoMCwgMikpO1xuXHRcdFx0dmFyIHRhcmdldE1vZHVsZSA9IGFyZ3NbMF0gJiYgZ2V0TW9kdWxlKGFyZ3NbMF0pLFxuXHRcdFx0XHRtb2R1bGU7XG5cdFx0XHRpZih0YXJnZXRNb2R1bGUgJiYgIXdhaXRpbmdbdGFyZ2V0TW9kdWxlLm1pZF0pe1xuXHRcdFx0XHQvLyBnaXZlbiBhIG1pZCB0aGF0IGhhc24ndCBiZWVuIHJlcXVlc3RlZDsgdGhlcmVmb3JlLCBkZWZpbmVkIHRocm91Z2ggbWVhbnMgb3RoZXIgdGhhbiBpbmplY3Rpbmdcblx0XHRcdFx0Ly8gY29uc2VxdWVudCB0byBhIHJlcXVpcmUoKSBvciBkZWZpbmUoKSBhcHBsaWNhdGlvbjsgZXhhbXBsZXMgaW5jbHVkZSBkZWZpbmluZyBtb2R1bGVzIG9uLXRoZS1mbHlcblx0XHRcdFx0Ly8gZHVlIHRvIHNvbWUgY29kZSBwYXRoIG9yIGluY2x1ZGluZyBhIG1vZHVsZSBpbiBhIHNjcmlwdCBlbGVtZW50LiBJbiBhbnkgY2FzZSxcblx0XHRcdFx0Ly8gdGhlcmUgaXMgbm8gY2FsbGJhY2sgd2FpdGluZyB0byBmaW5pc2ggcHJvY2Vzc2luZyBhbmQgbm90aGluZyB0byB0cmlnZ2VyIHRoZSBkZWZRIGFuZCB0aGVcblx0XHRcdFx0Ly8gZGVwZW5kZW5jaWVzIGFyZSBuZXZlciByZXF1ZXN0ZWQ7IHRoZXJlZm9yZSwgZG8gaXQgaGVyZS5cblx0XHRcdFx0aW5qZWN0RGVwZW5kZW5jaWVzKGRlZmluZU1vZHVsZSh0YXJnZXRNb2R1bGUsIGFyZ3NbMV0sIGFyZ3NbMl0pKTtcblx0XHRcdH1lbHNlIGlmKCEgMCAgfHwgISAxICB8fCBpbmplY3RpbmdDYWNoZWRNb2R1bGUpe1xuXHRcdFx0XHQvLyBub3QgSUUgcGF0aDogYW5vbnltb3VzIG1vZHVsZSBhbmQgdGhlcmVmb3JlIG11c3QgaGF2ZSBiZWVuIGluamVjdGVkOyB0aGVyZWZvcmUsIG9uTG9hZCB3aWxsIGZpcmUgaW1tZWRpYXRlbHlcblx0XHRcdFx0Ly8gYWZ0ZXIgc2NyaXB0IGZpbmlzaGVzIGJlaW5nIGV2YWx1YXRlZCBhbmQgdGhlIGRlZlEgY2FuIGJlIHJ1biBmcm9tIHRoYXQgY2FsbGJhY2sgdG8gZGV0ZWN0IHRoZSBtb2R1bGUgaWRcblx0XHRcdFx0ZGVmUS5wdXNoKGFyZ3MpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdC8vIElFIHBhdGg6IHBvc3NpYmx5IGFub255bW91cyBtb2R1bGUgYW5kIHRoZXJlZm9yZSBpbmplY3RlZDsgdGhlcmVmb3JlLCBjYW5ub3QgZGVwZW5kIG9uIDEtdG8tMSxcblx0XHRcdFx0Ly8gaW4tb3JkZXIgZXhlYyBvZiBvbkxvYWQgd2l0aCBzY3JpcHQgZXZhbCAoc2luY2UgaXQncyBJRSkgYW5kIG11c3QgbWFudWFsbHkgZGV0ZWN0IGhlcmVcblx0XHRcdFx0dGFyZ2V0TW9kdWxlID0gdGFyZ2V0TW9kdWxlIHx8IGluamVjdGluZ01vZHVsZTtcblx0XHRcdFx0aWYoIXRhcmdldE1vZHVsZSl7XG5cdFx0XHRcdFx0Zm9yKG1pZCBpbiB3YWl0aW5nKXtcblx0XHRcdFx0XHRcdG1vZHVsZSA9IG1vZHVsZXNbbWlkXTtcblx0XHRcdFx0XHRcdGlmKG1vZHVsZSAmJiBtb2R1bGUubm9kZSAmJiBtb2R1bGUubm9kZS5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnKXtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0TW9kdWxlID0gbW9kdWxlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoIDAgICYmICF0YXJnZXRNb2R1bGUpe1xuXHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaTxjb21ib3NQZW5kaW5nLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0TW9kdWxlID0gY29tYm9zUGVuZGluZ1tpXTtcblx0XHRcdFx0XHRcdFx0aWYodGFyZ2V0TW9kdWxlLm5vZGUgJiYgdGFyZ2V0TW9kdWxlLm5vZGUucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyl7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGFyZ2V0TW9kdWxlPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiggMCAgJiYgaXNBcnJheSh0YXJnZXRNb2R1bGUpKXtcblx0XHRcdFx0XHRpbmplY3REZXBlbmRlbmNpZXMoZGVmaW5lTW9kdWxlKGdldE1vZHVsZSh0YXJnZXRNb2R1bGUuc2hpZnQoKSksIGFyZ3NbMV0sIGFyZ3NbMl0pKTtcblx0XHRcdFx0XHRpZighdGFyZ2V0TW9kdWxlLmxlbmd0aCl7XG5cdFx0XHRcdFx0XHRjb21ib3NQZW5kaW5nLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1lbHNlIGlmKHRhcmdldE1vZHVsZSl7XG5cdFx0XHRcdFx0Y29uc3VtZVBlbmRpbmdDYWNoZUluc2VydCh0YXJnZXRNb2R1bGUpO1xuXHRcdFx0XHRcdGluamVjdERlcGVuZGVuY2llcyhkZWZpbmVNb2R1bGUodGFyZ2V0TW9kdWxlLCBhcmdzWzFdLCBhcmdzWzJdKSk7XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHNpZ25hbChlcnJvciwgbWFrZUVycm9yKFwiaWVEZWZpbmVGYWlsZWRcIiwgYXJnc1swXSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGRlZi5hbWQgPSB7XG5cdFx0XHR2ZW5kb3I6XCJkb2pvdG9vbGtpdC5vcmdcIlxuXHRcdH07XG5cblx0XHRpZiggMCApe1xuXHRcdFx0cmVxLmRlZiA9IGRlZjtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGRlZiA9IG5vb3A7XG5cdH1cblx0Ly8gYWxsb3cgY29uZmlnIHRvIG92ZXJyaWRlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgbmFtZWQgZnVuY3Rpb25zOyB0aGlzIGlzIHVzZWZ1bCBmb3Jcblx0Ly8gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLCBlLmcuLCBvdmVycmlkaW5nIGluamVjdFVybCwgZ2V0VGV4dCwgbG9nLCBldGMuIGluIG5vZGUuanMsIFJoaW5vLCBldGMuXG5cdC8vIGFsc28gdXNlZnVsIGZvciB0ZXN0aW5nIGFuZCBtb25rZXkgcGF0Y2hpbmcgbG9hZGVyXG5cdG1peChtaXgocmVxLCBkZWZhdWx0Q29uZmlnLmxvYWRlclBhdGNoKSwgdXNlckNvbmZpZy5sb2FkZXJQYXRjaCk7XG5cblx0Ly8gbm93IHRoYXQgcmVxIGlzIGZ1bGx5IGluaXRpYWxpemVkIGFuZCB3b24ndCBjaGFuZ2UsIHdlIGNhbiBob29rIGl0IHVwIHRvIHRoZSBlcnJvciBzaWduYWxcblx0b24oZXJyb3IsIGZ1bmN0aW9uKGFyZyl7XG5cdFx0dHJ5e1xuXHRcdFx0Y29uc29sZS5lcnJvcihhcmcpO1xuXHRcdFx0aWYoYXJnIGluc3RhbmNlb2YgRXJyb3Ipe1xuXHRcdFx0XHRmb3IodmFyIHAgaW4gYXJnKXtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhwICsgXCI6XCIsIGFyZ1twXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS5sb2coXCIuXCIpO1xuXHRcdFx0fVxuXHRcdH1jYXRjaChlKXt9XG5cdH0pO1xuXG5cdC8vIGFsd2F5cyBwdWJsaXNoIHRoZXNlXG5cdG1peChyZXEsIHtcblx0XHR1aWQ6dWlkLFxuXHRcdGNhY2hlOmNhY2hlLFxuXHRcdHBhY2tzOnBhY2tzXG5cdH0pO1xuXG5cblx0aWYoIDAgKXtcblx0XHRtaXgocmVxLCB7XG5cdFx0XHQvLyB0aGVzZSBtYXkgYmUgaW50ZXJlc3RpbmcgdG8gbG9vayBhdCB3aGVuIGRlYnVnZ2luZ1xuXHRcdFx0cGF0aHM6cGF0aHMsXG5cdFx0XHRhbGlhc2VzOmFsaWFzZXMsXG5cdFx0XHRtb2R1bGVzOm1vZHVsZXMsXG5cdFx0XHRsZWdhY3lNb2RlOmxlZ2FjeU1vZGUsXG5cdFx0XHRleGVjUTpleGVjUSxcblx0XHRcdGRlZlE6ZGVmUSxcblx0XHRcdHdhaXRpbmc6d2FpdGluZyxcblxuXHRcdFx0Ly8gdGhlc2UgYXJlIHVzZWQgZm9yIHRlc3Rpbmdcblx0XHRcdC8vIFRPRE86IG1vdmUgdGVzdGluZyBpbmZyYXN0cnVjdHVyZSB0byBhIGRpZmZlcmVudCBoYXMgZmVhdHVyZVxuXHRcdFx0cGFja3M6cGFja3MsXG5cdFx0XHRtYXBQcm9nczptYXBQcm9ncyxcblx0XHRcdHBhdGhzTWFwUHJvZzpwYXRoc01hcFByb2csXG5cdFx0XHRsaXN0ZW5lclF1ZXVlczpsaXN0ZW5lclF1ZXVlcyxcblxuXHRcdFx0Ly8gdGhlc2UgYXJlIHVzZWQgYnkgdGhlIGJ1aWxkZXIgKGF0IGxlYXN0KVxuXHRcdFx0Y29tcHV0ZU1hcFByb2c6Y29tcHV0ZU1hcFByb2csXG5cdFx0XHRjb21wdXRlQWxpYXNlczpjb21wdXRlQWxpYXNlcyxcblx0XHRcdHJ1bk1hcFByb2c6cnVuTWFwUHJvZyxcblx0XHRcdGNvbXBhY3RQYXRoOmNvbXBhY3RQYXRoLFxuXHRcdFx0Z2V0TW9kdWxlSW5mbzpnZXRNb2R1bGVJbmZvX1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gdGhlIGxvYWRlciBjYW4gYmUgZGVmaW5lZCBleGFjdGx5IG9uY2U7IGxvb2sgZm9yIGdsb2JhbCBkZWZpbmUgd2hpY2ggaXMgdGhlIHN5bWJvbCBBTUQgbG9hZGVycyBhcmVcblx0Ly8gKnJlcXVpcmVkKiB0byBkZWZpbmUgKGFzIG9wcG9zZWQgdG8gcmVxdWlyZSwgd2hpY2ggaXMgb3B0aW9uYWwpXG5cdGlmKGdsb2JhbC5kZWZpbmUpe1xuXHRcdGlmKCAwICl7XG5cdFx0XHRzaWduYWwoZXJyb3IsIG1ha2VFcnJvcihcImRlZmluZUFscmVhZHlEZWZpbmVkXCIsIDApKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9ZWxzZXtcblx0XHRnbG9iYWwuZGVmaW5lID0gZGVmO1xuXHRcdGdsb2JhbC5yZXF1aXJlID0gcmVxO1xuXHRcdGlmKCAwICl7XG5cdFx0XHRyZXF1aXJlID0gcmVxO1xuXHRcdH1cblx0fVxuXG5cdGlmKCAwICAmJiByZXEuY29tYm8gJiYgcmVxLmNvbWJvLnBsdWdpbnMpe1xuXHRcdHZhciBwbHVnaW5zID0gcmVxLmNvbWJvLnBsdWdpbnMsXG5cdFx0XHRwbHVnaW5OYW1lO1xuXHRcdGZvcihwbHVnaW5OYW1lIGluIHBsdWdpbnMpe1xuXHRcdFx0bWl4KG1peChnZXRNb2R1bGUocGx1Z2luTmFtZSksIHBsdWdpbnNbcGx1Z2luTmFtZV0pLCB7aXNDb21ibzoxLCBleGVjdXRlZDpcImV4ZWN1dGVkXCIsIGxvYWQ6MX0pO1xuXHRcdH1cblx0fVxuXG5cdGlmKCAxICAmJiAhIDEgKXtcblx0XHRmb3JFYWNoKGRlbGF5ZWRNb2R1bGVDb25maWcsIGZ1bmN0aW9uKGMpeyBjb25maWcoYyk7IH0pO1xuXHRcdHZhciBib290RGVwcyA9IGRvam9TbmlmZkNvbmZpZy5kZXBzIHx8XHR1c2VyQ29uZmlnLmRlcHMgfHwgZGVmYXVsdENvbmZpZy5kZXBzLFxuXHRcdFx0Ym9vdENhbGxiYWNrID0gZG9qb1NuaWZmQ29uZmlnLmNhbGxiYWNrIHx8IHVzZXJDb25maWcuY2FsbGJhY2sgfHwgZGVmYXVsdENvbmZpZy5jYWxsYmFjaztcblx0XHRyZXEuYm9vdCA9IChib290RGVwcyB8fCBib290Q2FsbGJhY2spID8gW2Jvb3REZXBzIHx8IFtdLCBib290Q2FsbGJhY2tdIDogMDtcblx0fVxuXHRpZighIDEgKXtcblx0XHQhcmVxLmFzeW5jICYmIHJlcShbXCJkb2pvXCJdKTtcblx0XHRyZXEuYm9vdCAmJiByZXEuYXBwbHkobnVsbCwgcmVxLmJvb3QpO1xuXHR9XG59KVxuLmNhbGwodGhpcywgdXNlckNvbmZpZywgZGVmYXVsdENvbmZpZyk7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../../../../private/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-4709JUkgfnxUB4Gi/dojo/dojo.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/dojo-webpack-plugin */
/******/ 	(() => {
/******/ 		(function() { /* Start dojo-webpack-plugin extensions */
/******/ 				function mix(dest, src) { // eslint-disable-line no-unused-vars
/******/ 					for(var n in src) dest[n] = src[n];
/******/ 					return dest;
/******/ 				}
/******/ 		
/******/ 				function toUrl(name, referenceModule) {
/******/ 					return loaderScope.require.toUrl(name, referenceModule);
/******/ 				}
/******/ 		
/******/ 				function toAbsMid(name, referenceModule) {
/******/ 					return loaderScope.require.toAbsMid(name, referenceModule);
/******/ 				}
/******/ 		
/******/ 				// dojo require function.
/******/ 				function req(config, dependencies, callback) {
/******/ 					return contextRequire(config, dependencies, callback, 0, req);
/******/ 				};
/******/ 		
/******/ 				function createContextRequire(module) { // eslint-disable-line no-unused-vars
/******/ 					if (!module) return req;
/******/ 					var moduleId = module.absMid;
/******/ 					if (!moduleId && req.absMidsById[module.id]) {
/******/ 						moduleId = req.absMidsById[module.id];
/******/ 					}
/******/ 					if (!moduleId) return req;
/******/ 					var result = function(a1, a2, a3) {
/******/ 						return contextRequire(a1, a2, a3, moduleId, req);
/******/ 					};
/******/ 					for (var p in req) {
/******/ 						if (req.hasOwnProperty(p)) {
/******/ 							result[p] = req[p];
/******/ 						}
/******/ 					}
/******/ 					result.toUrl = function(name) {
/******/ 						return toUrl(name, moduleId ? {mid: moduleId} : null);
/******/ 					};
/******/ 					result.toAbsMid = function(name) {
/******/ 						return toAbsMid(name, moduleId ? {mid: moduleId} : null);
/******/ 					};
/******/ 		
/******/ 					if (req.undef) {
/******/ 						result.undef = function(mid) {
/******/ 							req.undef(mid, moduleId);
/******/ 						};
/******/ 					}
/******/ 					return result;
/******/ 				}
/******/ 		
/******/ 				function registerAbsMids(absMids) { // eslint-disable-line no-unused-vars
/******/ 					for (var s in absMids) {
/******/ 						req.absMids[s] = absMids[s];
/******/ 						if (!req.absMidsById[absMids[s]]) {
/******/ 							req.absMidsById[absMids[s]] = s;
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				function resolveTernaryHasExpression(expr) { // eslint-disable-line no-unused-vars
/******/ 					// Expects an expression of the form supported by dojo/has.js loader, except that module identifiers are
/******/ 					// integers corresponding to webpack module ids.  Returns a module reference if evaluation of the expression
/******/ 					// using the currently defined features returns a module id, or else undefined.
/******/ 		
/******/ 					var has = findModule("dojo/has", null, false);
/******/ 					var id = has.normalize(expr, function(arg){return arg;});
/******/ 					return id && __webpack_require__(id) || undefined;
/******/ 				}
/******/ 		
/******/ 				function findModule(mid, referenceModule, noInstall, asModuleObj) {
/******/ 					mid = mid.split("!").map(function(segment) {
/******/ 						var isRelative = segment.charAt(0) === '.';
/******/ 						if(isRelative && !referenceModule){
/******/ 							return segment;
/******/ 						}
/******/ 						return toAbsMid(segment, referenceModule ? {mid: referenceModule} : null);
/******/ 					}).join("!");
/******/ 					var result;
/******/ 					if (mid in req.absMids && __webpack_require__.m[req.absMids[mid]]) {
/******/ 						if (noInstall) {
/******/ 							var module = __webpack_module_cache__[req.absMids[mid]];
/******/ 							result = module && (asModuleObj ? module : module.exports);
/******/ 						} else {
/******/ 							result = __webpack_require__(req.absMids[mid]);
/******/ 						}
/******/ 					}
/******/ 					if (!result) {
/******/ 						throw new Error('Module not found: ' + mid);
/******/ 					}
/******/ 					return result;
/******/ 				}
/******/ 		
/******/ 				function dojoModuleFromWebpackModule(webpackModule) { // eslint-disable-line no-unused-vars
/******/ 					if (webpackModule.absMid) return webpackModule;  // Already converted
/******/ 					var result = {i:webpackModule.id};
/******/ 					var id = req.absMidsById[webpackModule.id];
/******/ 					if (id) {
/******/ 						result.id = result.absMid = id;
/******/ 					}
/******/ 					Object.defineProperty(result, "exports", {
/******/ 						get: function() { return webpackModule.exports;},
/******/ 						set: function(value) {webpackModule.exports = value;},
/******/ 						enumerable: true,
/******/ 						configurable: true
/******/ 					});
/******/ 					return result;
/******/ 				}
/******/ 		
/******/ 				function contextRequire(a1, a2, a3, referenceModule, req) { // eslint-disable-line no-shadow
/******/ 					var type = ({}.toString).call(a1);
/******/ 					if (type === '[object String]') {
/******/ 						// a3 is passed by require calls injected into dependency arrays for dependencies specified
/******/ 						// as identifiers (vs. string literals).
/******/ 						var noInstall = !(a3 === false);
/******/ 						var m = findModule(a1, referenceModule, noInstall);
/******/ 						if (typeof m === 'object' && m.__DOJO_WEBPACK_DEFINE_PROMISE__) {
/******/ 							throw new Error('Module not found: ' + a1);
/******/ 						}
/******/ 						return m;
/******/ 					} else if (type === '[object Object]') {
/******/ 						throw new Error('Require config is not supported by WebPack');
/******/ 					}
/******/ 					if (type === '[object Array]') {
/******/ 						var modules = [], callback = a2, errors = [];
/******/ 						a1.forEach(function (mid) {
/******/ 							try {
/******/ 								modules.push(findModule(mid, referenceModule));
/******/ 							} catch (e) {
/******/ 								errors.push({mid: mid, error: e});
/******/ 							}
/******/ 						});
/******/ 						if (errors.length === 0) {
/******/ 							if (callback) {
/******/ 								if (false && isDefinePromise(modules)) { // eslint-disable-line no-undef
/******/ 									Promise.all(wrapPromises(modules)).then(function(deps) { // eslint-disable-line no-undef
/******/ 										callback.apply(this, unwrapPromises(deps)); // eslint-disable-line no-undef
/******/ 									}.bind(this)).catch(function(err){console.error(err);});
/******/ 								} else {
/******/ 									callback.apply(this, modules);
/******/ 								}
/******/ 							}
/******/ 						} else {
/******/ 							var error = new Error("findModules");
/******/ 							error.src = "dojo-webpack-plugin";
/******/ 							error.info = errors;
/******/ 							req.signal("error", error);
/******/ 						}
/******/ 						return req;
/******/ 					} else {
/******/ 						throw new Error('Unsupported require call');
/******/ 					}
/******/ 				}
/******/ 				req.toUrl = toUrl;
/******/ 				req.toAbsMid = toAbsMid;
/******/ 				req.absMids = {};
/******/ 				req.absMidsById = [];
/******/ 				req.async = 1;
/******/ 			var globalObj = this||window;
/******/ 			registerAbsMids({
/******/ 				// "./src/mathworker.js" = "./src/mathworker.js"
/******/ 				// "browser-peers/src/dedworkerpeer" = "./node_modules/browser-peers/src/dedworkerpeer.js"
/******/ 				// "browser-peers/src/peer" = "./node_modules/browser-peers/src/peer.js"
/******/ 				// "browser-peers/src/errors" = "./node_modules/browser-peers/src/errors.js"
/******/ 				// "browser-peers/src/util" = "./node_modules/browser-peers/src/util.js"
/******/ 				// "/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-4709JUkgfnxUB4Gi/dojo/dojo.js" = "../../../../../../private/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-4709JUkgfnxUB4Gi/dojo/dojo.js"
/******/ 			});
/******/ 		
/******/ 			globalObj.require = req;
/******/ 				(self["webpackChunkpfsc_ise"] = self["webpackChunkpfsc_ise"] || []).registerAbsMids = registerAbsMids;
/******/ 		
/******/ 			// expose the Dojo compatibility functions as a properties of __webpack_require__
/******/ 			if (__webpack_require__.dj && __webpack_require__.dj.name !== 'dojo-webpack-plugin') throw new Error("__webpack_require__.dj name collision.")
/******/ 			__webpack_require__.dj = {
/******/ 				name: 'dojo-webpack-plugin',
/******/ 				r: req,
/******/ 				c: createContextRequire,
/******/ 				m: dojoModuleFromWebpackModule,
/******/ 				h: resolveTernaryHasExpression,
/******/ 			};
/******/ 			var loaderScope = Object.create(globalObj, {
/******/ 			   document:{value: globalObj.document},
/******/ 			});
/******/ 			Object.defineProperties(loaderScope, {
/******/ 			   window:{value:loaderScope},
/******/ 			   global:{value:loaderScope}
/******/ 			});
/******/ 			loaderScope.define = loaderScope.require = undefined
/******/ 			globalObj.dojoConfig = globalObj.dojoConfig || {}
/******/ 			var userConfig = mix(globalObj.dojoConfig, ({'packages':[({'name':'dojo','location':'static/dojo'}),({'name':'dijit','location':'static/dijit'}),({'name':'dojox','location':'static/dojox'})],'paths':({'ise':'src'})}));
/******/ 			var defaultConfig = ({'hasCache':({'webpack':1,'host-browser':1,'dom':1,'dojo-loader':1,'dojo-has-api':1,'dojo-dom-ready-api':1,'dojo-sniff':1,'dojo-test-sniff':1,'config-deferredInstrumentation':1,'config-tlmSiblingOfDojo':1})});
/******/ 			var dojoLoader = __webpack_require__("../../../../../../private/var/folders/72/w63wb6p530zdrq455c5zxkpm0000gn/T/tmp-4709JUkgfnxUB4Gi/dojo/dojo.js");
/******/ 			dojoLoader.call(loaderScope, userConfig, defaultConfig, loaderScope, loaderScope);
/******/ 			Object.keys(loaderScope.require.packs).forEach(function(key) {
/******/ 				var pkg = loaderScope.require.packs[key];
/******/ 				if ((/(^\/)|(\:)/.test(pkg.main)	// main path is absolute
/******/ 				    || pkg.main.split('/').reduce(function(acc, pathComp) {
/******/ 							if (acc < 0 || pathComp === '.') return acc;
/******/ 							return (pathComp === '..' ? --acc : ++acc);
/******/ 						}, 0) <= 0) // main path is outside package
/******/ 						&& typeof pkg.realMain === 'undefined'	// hasn't already been adjusted
/******/ 				) {
/******/ 					pkg.realMain = pkg.main;
/******/ 					pkg.main = '';
/******/ 				}
/******/ 			});
/******/ 			function toAbsMid(name, referenceModule) {
/******/ 				var absMid = loaderScope.require.originalToAbsMid(name, referenceModule);
/******/ 				if (absMid.indexOf('/') === absMid.length-1) {
/******/ 					var pkgName = absMid.substring(0, absMid.length-1);
/******/ 					var pkg = loaderScope.require.packs[pkgName];
/******/ 					if (pkg && pkg.realMain) {
/******/ 						absMid = pkgName;
/******/ 					}
/******/ 				}
/******/ 				return absMid;
/******/ 			}
/******/ 			function toUrl(name, referenceModule) {
/******/ 				var url = loaderScope.require.originalToUrl(name, referenceModule);
/******/ 				var pkg = loaderScope.require.packs[name];
/******/ 				if (pkg && pkg.realMain) {
/******/ 					var parts = url.split('?');
/******/ 					if (/(^\/)|(\:)/.test(pkg.realMain)) {
/******/ 						// absolute URL
/******/ 						parts[0] = pkg.realMain;
/******/ 					} else {
/******/ 						// relative URL
/******/ 						parts[0] = parts[0] + '/' + pkg.realMain;
/******/ 					}
/******/ 					url = parts.join('?');
/******/ 				}
/******/ 				return url;
/******/ 			}
/******/ 			loaderScope.require.originalToAbsMid = loaderScope.require.toAbsMid;
/******/ 			loaderScope.require.originalToUrl = loaderScope.require.toUrl;
/******/ 			loaderScope.require.toAbsMid = toAbsMid;
/******/ 			loaderScope.require.toUrl = toUrl;
/******/ 			['baseUrl','has','rawConfig','on','signal'].forEach(function(name) {req[name] = loaderScope.require[name]})
/******/ 			var absMidsWaiting = globalObj["webpackChunkpfsc_ise"].absMidsWaiting;
/******/ 			if (absMidsWaiting) {
/******/ 			   absMidsWaiting.forEach(registerAbsMids);
/******/ 			   delete globalObj["webpackChunkpfsc_ise"].absMidsWaiting;
/******/ 			}
/******/ 		})(); /* End dojo-webpack-plugin extensions */
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/mathworker.js");
/******/ 	
/******/ })()
;